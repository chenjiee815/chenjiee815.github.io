{"pages":[{"text":"Contents list.sort, dict.update返回啥？ tuple的创建，不是少个逗号么 装饰过后了，我的func_name呢？ bool(gevent.spawn(lambda: True)): True? or False? 自定义异常无法正常Pickle反序列化 json.loads(json.dumps({1: 2})) == {1: 2}? list.sort, dict.update返回啥？ 1 2 3 4 5 6 7 def aa (): a = [ 2 , 8 , 3 , 1 , 6 , 4 ] return a . sort () def bb (): b = { 1 : 2 , 3 : 4 , 5 : 6 } return b . update ({ 7 : 8 }) 好吧，虽说我用Python也不少年头了，但是最近还是犯上面例子中的错误。 虽然我知道他们会修改值本身的内容，而我却想当然以为它们会将修改后的值返回出来，但现实是很残酷的，它们都返回None。 1 2 3 4 5 In [ 10 ]: print [ 4 , 2 , 3 ] . sort () None In [ 11 ]: print { \"a\" : 1 , \"b\" : 2 } . update ({ \"c\" : 3 }) None tuple的创建，不是少个逗号么 1 2 3 4 5 6 7 8 In [ 36 ]: a = (); type ( a ) Out [ 36 ]: tuple In [ 37 ]: a = ( 1 ); type ( a ) Out [ 37 ]: int In [ 38 ]: a = ( 1 ,); type ( a ) Out [ 38 ]: tuple 在Python中，括号的功能主要是来进行组合的，而不是用来创建元组的。比如： 1 2 In [ 47 ]: a = ( \"first;\" \"second;\" ); a Out [ 47 ]: 'first;second;' 装饰过后了，我的func_name呢？ Python中不仅可以使用自带的 @staticmethod 等来进行装饰，还可以自己写装饰器来进行装饰。 但是装饰完的函数还是原来的函数么？ 1 2 3 4 5 6 7 8 9 10 11 def wrapper ( func ): def _wrapper ( * args , ** kwargs ): return func ( * args , ** kwargs ) return _wrapper def aa (): return \"aa\" @wrapper def bb (): return \"bb\" 1 2 3 4 5 In [ 11 ]: aa . func_name Out [ 11 ]: 'aa' In [ 12 ]: bb . func_name Out [ 12 ]: '_wrapper' 经过装饰的函数，它的 func_name 已经发生了变化，说明它已经不是原来的函数定义了。 那么如何解决经过装饰的函数还拥有原来的一此属性呢？ 使用 functools.wraps 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import functools def wrapper ( func ): @functools.wraps ( func ) def _wrapper ( * args , ** kwargs ): return func ( * args , ** kwargs ) return _wrapper def aa (): return \"aa\" @wrapper def bb (): return \"bb\" 1 2 3 4 5 In [ 11 ]: aa . func_name Out [ 11 ]: 'aa' In [ 12 ]: bb . func_name Out [ 12 ]: 'bb' Tip 如果某个函数之间已经装饰过了，然后改变装饰器，则原来的函数仍然是使用改变之前的装饰器。 bool(gevent.spawn(lambda: True)): True? or False? 1 2 3 4 5 6 def aa (): return \"aa\" aa_spawn = None aa_spawn = gevent . spawn ( aa ) print bool ( aa_spawn ) == True 上面的代码最后结果是True么？ 是 好，咱们接着看。 1 2 3 4 5 6 7 def aa (): return \"aa\" aa_spawn = None aa_spawn = gevent . spawn ( aa ) aa_spawn . join () print bool ( aa_spawn ) == True 上面的代码最后结果是True么？ 难道不是么，我X，还真不是。 怎么回事啊？ 这个就要看 bool 函数的内部判断逻辑了。 以下情况会被认为是False，其他的情况是True。 None False zero of any numeric type, for example, 0, 0L, 0.0, 0j. any empty sequence, for example, '', (), []. any empty mapping, for example, {}. instances of user-defined classes, if the class defines a __nonzero__() or __len__() method, when that method returns the integer zero or bool value False. 这时候咱们再看一下 aa_spawn 这个对象。 1 2 3 4 5 6 7 8 9 10 In [ 25 ]: dir ( aa_spawn ) Out [ 25 ]: [ 'GreenletExit' , '__class__' , ... ... '__module__' , '__new__' , '__nonzero__' , '__reduce__' , ... ... ] 哦，我看到 __nonzero__ 这个属性了。当gevent.greenlet对象还没运行时，该属性为 True ，但当它执行完了，该属性就会变成 False 了。 SO，判断一个对象是否为真，千万要小心使用诸如以下形式的自动判断啊： 1 2 3 4 5 6 if some_instance : do_something () some_instance and do_something () some_instance or do_something () 自定义异常无法正常Pickle反序列化 我们先来定义一个自定义异常 MyError 1 2 3 4 5 6 7 8 class MyError ( Exception ): def __init__ ( self , desc ): super ( MyError , self ) . __init__ () self . __desc = desc def __str__ ( self ): return \"MyError: {}\" . format ( self . __desc ) 接下来咱们序列化一下： 1 2 3 4 5 6 In [ 10 ]: import pickle In [ 11 ]: p = pickle . loads ( e ) In [ 12 ]: p Out [ 12 ]: \"c__main__ \\n MyError \\n p0 \\n (tRp1 \\n (dp2 \\n S'_MyError__desc' \\n p3 \\n S'saifsdf' \\n p4 \\n sb.\" 貌似序列化成功了，接下咱们再反序列化一下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 In [ 16 ]: pickle . loads ( p ) --------------------------------------------------------------------------- TypeError Traceback ( most recent call last ) < ipython - input - 18 - 6 aaee2b1d950 > in < module > () ----> 1 pickle . loads ( p ) / usr / lib / python2 . 7 / pickle . pyc in loads ( str ) 1380 def loads ( str ): 1381 file = StringIO ( str ) -> 1382 return Unpickler ( file ) . load () 1383 1384 # Doctest / usr / lib / python2 . 7 / pickle . pyc in load ( self ) 856 while 1 : 857 key = read ( 1 ) --> 858 dispatch [ key ]( self ) 859 except _Stop , stopinst : 860 return stopinst . value / usr / lib / python2 . 7 / pickle . pyc in load_reduce ( self ) 1131 args = stack . pop () 1132 func = stack [ - 1 ] -> 1133 value = func ( * args ) 1134 stack [ - 1 ] = value 1135 dispatch [ REDUCE ] = load_reduce TypeError : __init__ () takes exactly 2 arguments ( 1 given ) 好家伙，出现这么信息，竟然异常了。 好吧，有问题，查看官方网站 pickle文档 。 pickle只能序列化和反序列化以下类型： None, True, and False integers, long integers, floating point numbers, complex numbers normal and Unicode strings tuples, lists, sets, and dictionaries containing only picklable objects functions defined at the top level of a module built-in functions defined at the top level of a module classes that are defined at the top level of a module instances of such classes whose __dict__ or the result of calling __getstate__() is picklable(see section The pickle protocol for details). 按照以上定义没有问题啊， MyError 符合其中第7条的要求。事实也是可以序列化，但不能反序列化。好吧，继续看官方文档。 Pickling and unpickling extension types object.__reduce__() When the Pickler encounters an object of a type it knows nothing about — such as an extension type — it looks in two places for a hint of how to pickle it. One alternative is for the object to implement a __reduce__() method. If provided, at pickling time __reduce__() will be called with no arguments, and it must return either a string or a tuple. 原来pickle对自定义异常 一无所知 。所以咱们需要在某个地方告诉它应该怎么序列化和反序列化。 1 2 3 4 5 6 7 8 9 10 11 class MyError ( Exception ): def __init__ ( self , desc ): super ( MyError , self ) . __init__ () self . __desc = desc def __str__ ( self ): return \"MyError: {}\" . format ( self . __desc ) def __reduce__ ( self ): return ( MyError , ( self . __desc ,)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [ 10 ]: import pickle In [ 20 ]: e = MyError ( \"error\" ) In [ 21 ]: p = pickle . dumps ( e ) In [ 24 ]: p Out [ 24 ]: \"c__main__ \\n MyError \\n p0 \\n (S'error' \\n p1 \\n tp2 \\n Rp3 \\n .\" In [ 28 ]: pickle . loads ( p ) Out [ 28 ]: __main__ . MyError () In [ 29 ]: c = pickle . loads ( p ) In [ 30 ]: str ( c ) Out [ 30 ]: 'MyError: error' json.loads(json.dumps({1: 2})) == {1: 2}? 1 2 3 4 5 6 In [ 4 ]: import json In [ 5 ]: a = { 1 : 2 } In [ 7 ]: json . loads ( json . dumps ( a )) == a Out [ 7 ]: False 奇怪，序列化+反序列化前后不应该一样么？ 好吧，我们看一下，JSON序列化再反序列化的数据是什么样本？ 1 2 In [ 6 ]: json . loads ( json . dumps ( a )) Out [ 6 ]: { u'1' : 2 } 字典的Key值由原来的数值类型变成了字符串类型。 JSON为什么会有这种奇怪的行为？ 我们来看一下 JSON中文网 的JSON格式说明。 原来JSON语法规定：一个键值对的集合（Python叫字典），其键必须为string（字符串）。（JSON作为一种数据交换格式，可能需要考虑兼容性， 不是所有语言都支持键为数值类型） 好吧，这种情况我只能Orz...","tags":"python","loc":"http://chenjiee815.github.io/na-xie-nian-wo-men-cai-guo-de-gen-pythonyou-guan-de-keng-chi-xu-geng-xin.html","title":"那些年我们踩过的跟Python有关的坑（持续更新）"},{"text":"这一章节，作者主要想通过一系列的对话，让你了解到类型是什么东东。以及如何使用Java定义类型。 类型是什么？ 类型是一类值的集合的命名 abstract 、 class 、 extends 各代表什么？ abstract 引入了数据类型 class 引入了变体类型 extends 将以上两者联系起来 Tip 第一条建议 当你想要明确一类数据时，使用 abstract class XXX {} 来定义数据类型 使用 class XXX extends XXX {} 来定义其变体类型","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-modern-toys.html","title":"A Little Java, A Few Patterns： Modern Toys"},{"text":"下面就是一些有关Java体验的提示： 在一个文件中给出类的完整层次。 对于每个类的命名不以上标D、V、I、M结尾的，添加 toString 方法时遵守以下规则： 如果一个类没有属性 1 2 3 public String toString () { return \"new \" + getClass (). getName () + \"()\" ; } 如果一个类只有一个属性，比如叫 x 1 2 3 public String toString () { return \"new \" + getClass (). getName () + \"(\" + x + \")\" ; } 如果一个类有两个属性，比如叫 x 和 y 1 2 3 public String toString () { return \"new \" + getClass (). getName () + \"(\" + x + \", \" + y + \")\" ; } 在文件的底部添加如下类： 1 2 3 4 5 6 class Main { public static void main ( String args []) { DataType_or_Interface y = new ______ ; System . out . println ( ... ... ); } } DataType_or_Interface y = new ______; 是用来创建你想尝试的对象。 System.out.println( ... ... ); 是用来填写你想尝试的表达式。 比如，你想尝试第2章定义的 ManhattanPt 的 distanceTo0 方法，你就可以添加如下代码到你文件的最后： 1 2 3 4 5 6 class Main { public static void main ( String args []) { PointD y = new ManhattanPt ( 2 , 8 ); System . out . println ( y . distanceTo0 ()); } } 如果你想尝试多条表达式，就修改 y ，就像第10章里， y._ _ _ _ _ _; y._ _ _ _ _ _; y._ _ _ _ _ _ 替换成 y._ _ _ _ _ _ + \"\\n\" + y._ _ _ _ _ _ + \"\\n\" + y._ _ _ _ _ _ 如果你想尝试第10章中定义的 PiemanM 的多个方法，那么你就将以下代码写在文件的最后面： 1 2 3 4 5 6 7 8 9 10 class Main { public static void main ( String args []) { PiemanI y = new PiemanM (); System . out . println ( y . addTop ( new Anchovy ()) + \"\\n\" + y . addTop ( new Anchovy ()) + \"\\n\" + y . substTop ( new Tuna (), new Anchovy ()) ); } } 最后，编译文件并且执行 Main 类。","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-javaxiao-yong.html","title":"A Little Java, A Few Patterns： Java小用"},{"text":"Contents 本书适用的读者 本书未涉及的方面 感谢 本书阅读指南 一门面向对象编程语言能够让程序员构造可复用的程序组件。其它程序员通过使用这些组件，能够快速地搭建新的大型程序和框架。在理想的状态下，程序员不需要修改任何已经存在的代码，只需要将它们简单地组装在一起然后添加一些新的代码即可。当然这些可复用的组件并不是天上掉下来的馅饼，它是用代价的。它需要一门经过良好设计的面向对象编程语言和严格的编程规范。 Java就是一门这样的语言。这本书会介绍它的面向对象元素：类、属性、方法、继承和接口。这些核心元素都有着简单的语法模型，能够帮助程序员表达它们。并且，Java还实现了内存自动管理，这更是让程序员们从思考机器的实现细节中解放出来，从而能够更专注于程序设计。 这本书的另外一个目的是向读者介绍 设计模式 。设计模式是能够加强代码复用的编程规范的关键所在。设计模式能够帮助程序员很好地组织面向对象组件，这样程序员就能够按照自己所希望的那样，实现整个计算流程了。更重要的是，设计模式有助于沟通程序组件的重要属性（这句不知道怎么意译，只能直译）。如果一个组件按照精确的公式化的模式实践（它的文档也一样），那么其他程序员就能够很容易地理解它的结构并且在自己的程序进行复用，甚至不需要了解该组件的源代码。 本书适用的读者 这本书主要的受众是那些愿意学习面向对象的本质以及设计模式的人，尤其是程序员、设计师和学生等等。读者需要有一些基本的编程经验。如果读者理解函数式编程的基本原理，那么他们将会从本书获得最大收益。了解函数式设计的最好办法是学一门使用Scheme（或者ML）语言进行教学的入门级计算机科学课程，但这并不是必需的。 本书未涉及的方面 Java在它的面向对象核心之上，提供了很多有用的特性及库。当然，这些额外的Java元素对于专业编程来说很重要，但对于本书的重要目标： 面向对象编程及设计模式的使用 来说却没有什么关系。正因为这个原因，本书不是一本完全的Java入门书籍。不过，掌握了本书内容的读者在学习了本书 Commencement 章节补充那些书以后，会很快成长为一名专业的Java程序员。 有关设计模式的书籍发展得非常快。所以对一本入门级的书来说，能够清楚涉及到的设计模式不是很多。但是我们用到的模式的简洁以及强大功能会鼓舞读者继续学习书后所提及的额外的有关设计模式的资料。 感谢 基本是感谢一堆人，以及每个人对本书做了哪些贡献，暂不翻译。 本书阅读指南 不要简单粗暴地过一遍本书。至少用心地读上7次。在读书时记得做标记或者写笔记，在本书的犄角旮旯会有诸多有用的提示。完整得过完每一个例子，而不是简单拿眼睛浏览一下。牢记一句箴言：先动脑，再动手。 本书形式是有关有趣的Java编程的对话。在你理解了书中的例子之后就动手实践它们，通过修改这些程序和例子来看看它们倒底是如何工作的。目前不幸的是大部分的Java实现都没有交互式命令行或者解释器。这就需要你这边做一些必要的重复性工作。接下来的章节会告诉你一些如何体验Java的提示。 我们不会在本书里对设计模式给出任何正式的定义。我们相信读者你有这个能力能够给出你自己对设计模式的定义，这样你才能更好地理解并掌握它们，而不是通过我们直接灌输给你。但是你要确认你自己知道并理解了在本书大部分章节里给出的部分建议。 我们在书中使用一些 标记规定 来在不同层次帮助你理解程序。主要的规定就是通过字体来标识不同类型的单词。（该段下面基本就是告诉你各种类型的单词使用什么字体，这个也不翻译了，到时候一看例子就知道了）。 本书的例子中出现食物名有两个原因。首先，食物比起那些抽象的概念来说更容易可视化（但是你饿的时候读本书就不是一个好主意了）。我们希望我们选择食物名能够有助读者理解本书中的例子和主题。其次，我们希望在读书时能够小分一下心。我们知道当你试图理解这些主题时多少有点沮丧，但是一丢丢分心多少能够帮助你远离沮丧的情绪。 你要准备开始阅读本书喽。祝你好运！我们希望你能够享受阅读本书。","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-xu-yan.html","title":"A Little Java, A Few Patterns： 序言"},{"text":"学习编程不仅是学习一门编程语言的语法和方法，更需要学习如何 程序设计 。任何一本好的讲编程的书籍都需要教会人们程序设计。 在学校里教授的那些程序设计之类的课程，总会和一系列实际使用到的语言绑定在一起。 Felleisoen 和 Friedman 这两位大师将函数式编程很自然地引导到众所周知的面向对象编程。他们将两种编程范式无缝地结合在一起，并且展示它们是如何很好地一起工作地。他们写的这本书就证明了函数式编程与面向对象编程并不冲突，反而能够很好的支持面向对象编程。 我并不惊讶于他们的成功（将两种编程范完美无缺地结合在一起）。因为我已经在好多年前从 Smalltalk 语言中了解到这一概念了。但不幸的是，这么多年过去了，它仍然是面向对象设计中的众多秘密之一。我很高兴 Felleisoen 和 Friedman 最终揭开了它的面目。如是你是一名C++程序员，正在学习Java，并且对从未了解过函数式设计，那这本书对你来说就尤其有用。如果你了解过函数式设计，那么这本书会用一优雅的方式向你介绍Java中基于模式的编程。如果你不了解， Felleisoen 和 Friedman 将会教会你一个强大的新的思维方法。 享受一下披萨吧。","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patternsqian-yan.html","title":"A Little Java, A Few Patterns：前言"},{"text":"文字版本 生命是一段漫长的旅程 想了，就去做。 输了，从头再来。 摔了，爬起来继续。 赢了，还要继续往前走。 死了，没留下任何遗憾。 我的理解 人总是充满各种各样的欲望，欲望促使人们做着能够满足这些欲望的事。当做完一件事，暂时满足了欲望，没有了遗憾。 但是不久，人又会有新的欲望产生，人又要为新欲望而循环反覆做着一样或者不一样的事。但是人的欲望没有止境，做的事就不会有止境。 所以，没有遗憾也只是暂时的，在你临死时你觉得没有遗憾，那只是你运气好而已。你只是上一个欲望得到了满足，而新的欲望没有开始而已。 啥时候 放下 你才是真的没有遗憾。 代码版本 Python版本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 import random import time class Person ( object ): UNKNOWN = \"UNKNOWN\" THOUGHT = \"THOUGHT\" LOST = \"LOST\" WON = \"WON\" DIED = \"DIED\" FELL = \"FELL\" def __init__ ( self , lose_interval = 0.03 , win_interval = 0.03 , fall_interval = 0.01 ): super ( Person , self ) . __init__ () self . thing = None self . __status = self . UNKNOWN self . __lose_interval = lose_interval self . __win_interval = win_interval self . __fall_interval = fall_interval def __repr__ ( self ): return \"Person: {0}\" . format ( self . __status ) def __str__ ( self ): return repr ( self ) def get_status ( self ): return self . thing . status if self . thing else Thing . UNKNOWN def thought ( self ): self . __status = self . THOUGHT self . thing = Thing () self . thing . start_do () def lost ( self ): self . __status = self . LOST if self . thing : self . thing . stop_do () time . sleep ( self . __lose_interval ) self . thing = Thing () self . thing . start_do () def won ( self ): self . __status = self . WON if self . thing : self . thing . end_do () time . sleep ( self . __win_interval ) def died ( self ): self . __status = self . DIED self . thing and self . thing . stop_do () def fell ( self ): self . __status = self . FELL if self . thing : self . thing . stop_do () time . sleep ( self . __fall_interval ) self . thing . restart_do () class Thing ( object ): UNKNOWN = 'UNKNOWN' REGRETS = 'REGRETS' NO_REGRETS = 'NO REGRETS' def __init__ ( self ): super ( Thing , self ) . __init__ () self . status = self . UNKNOWN def start_do ( self ): self . status = self . REGRETS def stop_do ( self ): if self . status == self . UNKNOWN : self . status = self . REGRETS def end_do ( self ): self . status = self . NO_REGRETS def restart_do ( self ): self . status = self . REGRETS class Life ( object ): MIN_TIMES = 0 MAX_TIMES = 120 def __init__ ( self ): super ( Life , self ) . __init__ () self . __person = Person () self . __times = float ( random . randint ( self . MIN_TIMES , self . MAX_TIMES )) * random . random () self . __progress = ( self . __person . thought , self . __person . lost , self . __person . fell , self . __person . won , ) def __is_end ( self ): return self . __times <= 0.0 def __elapse ( self , default = None ): interval = default if default is not None else random . random () if self . __times >= 0.0 : self . __times -= interval def start ( self ): if self . __is_end (): self . __person . died () return while 1 : for going in self . __progress : going () self . __elapse () if self . __is_end (): self . __person . died () return def get_status ( self ): return self . __person . get_status () def main (): life = Life () life . start () print life . get_status () if __name__ == '__main__' : main ()","tags":"life","loc":"http://chenjiee815.github.io/sheng-ming-shi-yi-duan-man-chang-de-lu-tu.html","title":"生命是一段漫长的旅途"},{"text":"Contents 返回表的函数 习题10.1.1 习题10.1.2 习题10.1.3 习题10.1.4 习题10.1.5 习题10.1.6 习题10.1.7 习题10.1.8 返回表的函数 习题10.1.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ;; hours->wages: list-of-numbers -> list-of-numbers ;; 由周工作时间表得到周工资表 ( define ( hours->wages alon ) ( cond [( empty? alon ) empty ] [ else ( cons ( wage ( first alon )) ( hours->wages ( rest alon )))])) ( define PER_HOUR_WAGE 14 ) ;; 每小时工资 ;; wage: number -> number ;; 根据工时计算工资 ( define ( wage h ) ( * PER_HOUR_WAGE h )) 习题10.1.2 对alon中的每个周工作时间进行检查，确保没有>100 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ;; hours->wages: list-of-numbers -> list-of-numbers ;; 由周工作时间表得到周工资表 ( define ( hours->wages alon ) ( cond [( empty? alon ) empty ] [ else ( cons ( wage ( first alon )) ( hours->wages ( rest alon )))])) ( define PER_HOUR_WAGE 14 ) ;; 每小时工资 ( define MAX_HOURS 100 ) ;; 每周最大工作小时数 ;; wage: number -> number ;; 根据工时计算工资 ( define ( wage h ) ( cond [( > h MAX_HOURS ) ( error 'wage \"too many hours\" )] [ else ( * PER_HOUR_WAGE h )])) 习题10.1.3 解题思路和10.1.2是一样的。 习题10.1.4 解题思路和10.1.2是一样的。 习题10.1.5 1 2 3 4 5 6 7 8 9 10 11 12 ;; eliminate-exp: number list-of-numbers -> list-of-numbers ;; 读入一个数和玩具价格表 ;; 返回玩具价格表中所有比较那个数小的值 ( define ( eliminate-exp ua lotp ) ( cond [( empty? lotp ) empty ] [( > ( first lotp ) ua ) ( eliminate-exp ( rest lotp ))] [ else ( cons ( first lotp ) ( eliminate-exp ( rest lotp )))])) ;; 测试 ( eliminate-exp 1.0 ( cons . 95 ( cons 1.0 empty ))) 习题10.1.6 1 2 3 4 5 6 7 8 9 10 11 12 ;; substitute: symbol symbol list-of-symbols -> list-of-symbols ;; 读取两个符号new old，和一个符号表list-of-symbols， ;; 返回一个新的符号表，其中所有old替代为new ( define ( substitute new old name-robot ) ( cond [( empty? lotp ) empty ] [( = old ( first name-robot )) ( cons new ( substitute new old ( rest name-robot )))] [ else ( cons old ( substitute new old ( rest name-robot )))])) ;; 测试 ( substitute ( cons 'robot ( cons 'Barbie ( cons 'dress empty )))) 习题10.1.7 1 2 3 4 5 6 7 8 9 10 ;; recall: symbol list-of-symbols -> list-of-symbols ;; 从符号表lon中移除ty ( define ( recall ty lon ) ( cond [( empty? ty ) empty ] [( = ty ( first lon )) ( recall ty ( rest lon ))] [ else ( cons ( first lon ) ( recall ty ( rest lon )))])) ;; 测试 ( recall ( cons 'doll ( cons 'dress empty ))) 习题10.1.8 1 ;;","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-shi-zhang-biao-de-jin-yi-bu-chu-li.html","title":"HTDP第十章：表的进一步处理"},{"text":"Contents 引言 瓶颈期的状态 我是怎样察觉到自己处在瓶颈期的？ 我在瓶颈期的状态如何？ 如何渡过瓶颈期 什么是我的瓶颈？ 如何解决这些瓶颈？ 掌握计算的本质 掌握目前主要的硬通货 我目前的状态 我在哪些方面提高了？ 为了纪念刚刚出离的瓶颈期，我写了这篇博文。 同时也总结这一下这段时间的心态与所得。 引言 我目前的职业规划还是做 技术 为主。 做为一个 程序员 ，我觉得 技术 才是我们的立身之本。只有在技术上掌握到较高的层次，你才好围绕着技术拓展自己的其它能力。 当你的技术还没达到较高的层次之前，就相当于在打基础。那这个打基础的过程在我的理解里有点像上台阶。 当你走一段比较长的平台，遇到了一个台阶，就是遇到了你的瓶颈。你跨上去了，你就成长了一点，你又会走过一段比较长的平台。但是随后的台阶会越来越高，有人经历了几个台阶后只能原地踏步、有人只经历一两个台阶就另换职业，有人可能会越战越勇，不断得突破自己。 那我比较幸运，在我的IT职业生涯第二年就遇到了的第一个瓶颈期。 瓶颈期的状态 我是怎样察觉到自己处在瓶颈期的？ 说到怎样察觉，我体会到的是： 不是突然遇到一件事就让我察觉到了自己处在瓶颈期。 而是在比较长的一段时间内，遇到很多的事情让你有以下几种感觉： 工作没有目标，没有动力，看不到未来 感觉自己活得好累，事业上平平淡淡，生活上没房没车 感觉自己在技术方面很难进步，反而有些退步 感觉自己不明白的东西太多，而自己基础又太薄弱 ... ... 总之一句话： 感觉自己就是一个loser 干啥啥不行，吃啥啥不剩。 我在瓶颈期的状态如何？ 我是从医药行业跨到IT行业的。 我为什么要来到IT行业？ 因为我热爱编程，觉得编程是件很神奇的事。 以编程作为自己的职业，是我的梦想。 当初我是怀着一腔热血进入IT行业的，冲劲十足，进步神速。只要是和计算机、编程相关的事，我都觉得很有意义，是个学习的机会。 但是经过差不多两年的时间，我发现自己很难进步了。 我目前的工作是以Python为主，所以就看了大量的目前市面流行的Python书籍。但是我发现那些书没啥好看的，基础的我都懂，高深的又比较理论化，感觉投影不到现实编程当中。 工作的内容也慢慢Hold不住了，以前只用写些小型的界面程序、辅助程序等等。现在面对着复杂的业务逻辑，复杂的业务处理流程，我不知道该怎么这才能比较好的实现了。 自己平时都有关注一些新技术、新的Python库，新的语言。然后就会花点时间学点皮毛，但总是无法深入。 不断接触和涌出的各种技术，让我感觉无所适从，难不成有一个我就学一个？学到死？ 谈了恋爱，钱、房子、车子等等这些以前想都不想事情，在女朋友有意无意的提示之下，也觉得这些事成了当务之急。而现在自己，却一无所有。 看了大量道家的书、佛家的书以及这些圈子的人写的各类文章，让我整个人的理想和实现有了很大的矛盾。 总而言之： 整个人生没有了方向，不知道该怎么走，也没有什么动力走下去。 如何渡过瓶颈期 当我意识到自己处在一个瓶颈期时，第一个念头就是怎么出离这个令人迷茫而又不舒服状态。 我就思考我要怎么做。 什么是我的瓶颈？ 我是一个非科班出身的程序员，基础的知识薄弱。 我是一个动态语言为专业的程序员，底层知识薄弱。 我只做过一些小型程序、软件，中型以及大型系统的设计及编程能力薄弱。 我大部分时间只是在熟悉业务，而对承载业务的各类协议、数据库、操作系统等目前硬通货了解不深入。 如何解决这些瓶颈？ 想要有优质的生活，你需要有好的事业。 想要有好的事业，你需要有市场需求的鹤立鸡群的职业技能。 想要有过硬的职业技能，你需要能人所不能。 想要能人所不能，你需要了解技术的本质，一通百通。 在参考了网上一些前辈写的文章，我确定了我以后的两条主线： 先掌握计算的本质、再掌握计算机的本质 掌握目前主要的硬通货 掌握计算的本质 看完《The Little Schemer》、《How to Design Programs》、《structure and interpretation of computer programs》... ... 掌握Scheme、Haskell、prolog。 以实现一门自己的高级语言解释器为一个里程碑。 后面的路暂时还未想到。 掌握目前主要的硬通货 掌握HTTP协议 一个Web框架的整个实现原理 以编写出一个自己的Web框架为里程碑 掌握Python实现 以实现一个简化版本的tiny python为里程碑 Linux内核实现 以编写一个自己的小型操作系统里程碑 我目前的状态 我最近一段时间的心理相对于以前来说，平稳了许多。而且很明显得感觉到自己已经开始慢慢摆脱瓶颈期了。 怎么感觉到的？ 很简单。我现在有了方向，有了动力，并且努力朝着这个方向前进。 我在哪些方面提高了？ 递归 之前的理解 印象中的递归更多的是教科书内的汉诺塔之类的例子。 递归效率不高，递归层次深了更可能会栈溢出。 现在的理解 在看了《The Little Schemer》后，对递归有了更进一步的了解。具体的看 glob标准库的学习 。 怎样读其他人的代码 之前的理解 刚开始学一门语言时，语法不是很熟悉，看别人代码 关注更多的是 作者写的是什么 看完别人的代码，感觉自己懂了，但是当你脱离作者的代码想自己实现时，还要时不时地看一下原作者的代码 现在的理解 但是当你熟悉一门语言后，你应该转换你的观点了， 应该更多的关注是 作者是怎么想的 你了解到了作者在写代码时的整个大脑活动，那作者的代码就内化成你自己的代码，同时，由于你本身处于局外人的身份，你还会发现作者的思路缺陷，能够写出更漂亮的代码 程序设计基本思想 之前的理解 单一职责、自顶向下、模块化、接口先行、自底向上... ... 只知道这些名词是啥意思，但是在代码设计及实现却没有有意识的按照这些思想去做。 现在的理解 自顶向下体现的是一种全局观，根据需求划分出多个功能模块、然后每个功能模块需要提供哪些接口 然后再自底向上挨个实现每个功能模块，当然在每个功能模块内部也同样可以复用以上逻辑 设计模式 之前的理解 以前有过一段做GUI程序的经历，在做GUI时，我觉得GUI这个领域算是面向对象的最佳实践之一。当时也是首次有意识地将设计模式应用到代码中。当然，一开始必然是生搬硬套。对着书，觉得这个设计模式有意思，好，看看程序里哪边可以使用上。 后来，又接触到了函数式编程的概念。网上很多文章将函数式编程和面向对象编程放在了对立面，然后将函数式编程捧得很高，将面向对象编程批得很挫。我也受到这种思想的荼毒，走得比较极端，开始厌恶使用面向对象编程，甚至拒绝使用Python中的class关键字定义类。 现在的理解 设计模式最重要的是什么？ 设计模式最重要的是它的SOLID原则。 单一职责原则：The Single Presponsibility Principle 开放封闭原则：The Open Closed Principle 里氏替换原则：The Liskov Substitution Principle 接口分离原则：The Interface Segregation Principle 依赖倒置原则：The Dependency Inversion Principle 那些所谓的设计模式只是在一定的应该场景中这些原则的全部或者部分的映射。 class定义一个类是提供了一种封装的手段，那么闭包也是。它们都是为了实现封装而提供的工具而已。","tags":"职业生涯","loc":"http://chenjiee815.github.io/zhi-ye-sheng-ya-ping-jing-qi-zhi-wo-de-jing-li.html","title":"职业生涯瓶颈期之我的经历"},{"text":"Contents 简介 代码解析 代码吐槽 总结 简介 glob库提供了以下两个函数： glob 输入 文件路径模式字符串（仅支持Shell通配符） 输出 和模式字符串匹配的真实文件名列表 iglob 输入 文件路径模式字符串（仅支持Shell通配符） 输出 和模式字符串匹配的真实文件名列表迭代器 代码解析 glob库中最重要函数就是 iglob 函数了。 glob 函数其实也是调用 iglob 来实现的。 1 2 def glob ( pathname ): return list ( iglob ( pathname )) 那么接下就主讲 iglob 这个函数。 首先我们分析一下传入的文件路径模式字符串有几种情况： 文件路径模式字符串中没有Shell通配符 文件路径模式字符串中有Shell通配符 这种情况还要再细分： dirname没有Shell通配符，basename有Shell通配符 dirname有Shell通配符，basename没有Shell通配符 dirname有Shell通配符，basename有Shell通配符 经过以上分析，我们为了函数的参数统一，可以将上面的几种情况，归纳如下： dirname没有Shell通配符，basename有Shell通配符 dirname有Shell通配符，basename没有Shell通配符 dirname有Shell通配符，basename有Shell通配符 dirname没有Shell通配符，basename没有Shell通配符 根据以上的分析，我们就可以得出需要以下几个辅助函数： has_magic 判断一个字符串是否有Shell通配符 glob0 处理dirname没有通配符，basename也没有通配符的情况 glob1 处理dirname没有通配符，basename有通配符的情况 glob2 处理dirname有通配符，basename没有通配符的情况 glob3 处理dirname有通配符，basename有通配符的情况 但是我们看一下 iglob 函数的源码，它只用到了 has_magic 、 glob0 、 glob1 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def iglob ( pathname ): # 如果整个文件路径模式字符串中没有Shell通配符 # 直接判断该路径是否存在即可 if not has_magic ( pathname ): if os . path . lexists ( pathname ): yield pathname return # 如果有的话，就要按上面分析的四种情况考虑了 dirname , basename = os . path . split ( pathname ) # 这里针对目录名没有的情况做了一下特殊处理 if not dirname : for name in glob1 ( os . curdir , basename ): yield name return # 这里为什么要先判断dirname != pathname？ # 源代码注释中说得很明白。 # pathname为一个驱动器路径（就是C盘，D盘...） # 或者为一个UNC路径（自行百度/Google）。那么, # os.path.split函数就会将之当作dirname返回。 # 这样会导致下面的代码无限递归，直到Python异常。 # `os.path.split()` returns the argument itself as a dirname if it is a # drive or UNC path. Prevent an infinite recursion if a drive or UNC path # contains magic characters (i.e. r'\\\\?\\C:'). if dirname != pathname and has_magic ( dirname ): dirs = iglob ( dirname ) else : dirs = [ dirname ] if has_magic ( basename ): glob_in_dir = glob1 else : glob_in_dir = glob0 # 这里将dirname中有通配符的情况， # 转换成没有通配符的情况 # 然后对每个dirname使用glob1/glob0进行处理 for dirname in dirs : for name in glob_in_dir ( dirname , basename ): yield os . path . join ( dirname , name ) 代码吐槽 还是按照我上面的解析思路来，添加两个辅助函数 glob2 和 glob3 ，这样 iglob 函数的逻辑就比较清楚了，完全按照我上面的解析思路来的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def iglob ( pathname ): dirname , basename = os . path . split ( pathname ) if dirname != pathname and has_magic ( dirname ): glob_func = glob3 if has_magic ( basename ) else glob2 else : glob_func = glob1 if has_magic ( basename ) else glob0 for name in glob_func ( dirname , basename ): yield name def glob1 ( dirname , pattern ): if not dirname : dirname = os . curdir if isinstance ( pattern , _unicode ) and not isinstance ( dirname , unicode ): dirname = unicode ( dirname , sys . getfilesystemencoding () or sys . getdefaultencoding ()) try : names = os . listdir ( dirname ) except os . error : return [] # .号开头的文件在unix平台上为隐藏文件， # 但是在正则表达式中它又可以匹配任意字符， # 所以需要先单独过滤一下 if pattern [ 0 ] != '.' : names = filter ( lambda x : x [ 0 ] != '.' , names ) return fnmatch . filter ( names , pattern ) def glob0 ( dirname , basename ): if basename == '' : # `os.path.split()` returns an empty basename for paths ending with a # directory separator. 'q*x/' should match only directories. if os . path . isdir ( dirname ): return [ basename ] else : if os . path . lexists ( os . path . join ( dirname , basename )): return [ basename ] return [] def glob2 ( dirpattern , basename ): return [ os . path . join ( dirname , name ) for dirname in iglob ( dirpattern ) for name in glob0 ( dirname , basename ) ] def glob3 ( dirpattern , basepattern ): return [ os . path . join ( dirname , name ) for dirname in iglob ( dirpattern ) for name in glob1 ( dirname , basepattern ) ] 总结 即然用到递归了，就要用得干净利落点。","tags":"Python","loc":"http://chenjiee815.github.io/globbiao-zhun-ku-yuan-ma-xue-xi.html","title":"glob标准库源码学习"},{"text":"Contents 简介 代码解析 代码吐槽 总结 简介 fnmatch模块提供了以下几个函数： filter 输入 一个文件名列表和一个指定模式（仅支持Shell通配符） 输出 一个符合指定模式的文件名列表 fnmatch 输入 一个文件名和一个指定模式（仅支持Shell通配符） 输出 该文件名是否匹配指定模式 说明 具体行为和平台相关，比如某些平台忽略大小写等等 fnmatchcase 输入 一个文件名和一个指定模式（仅支持Shell通配符） 输出 该文件名是否匹配指定模式 说明 大小写敏感 translate 输入 Shell通配符格式的模式字符串 输出 正则格式的模式字符串 代码解析 fnmatch库的还是很简单的，代码加注释才100行多一点。 它主要做的工作就是比较一个给定的文件名和给定的模式字符串，判断两者是否相等。 然后围绕这个功能，提供一系列的相关函数。 至于如何判断两者相等，它的做法是： 使用 正则表达式 既然要使用 正则表达式 ，那么就要考虑如何将一个Shell通配符格式的字符串转换成正则了。 这个功能就是由 translate 函数来实现的。这个函数的源码就是不展示了，它做的主要功能其实就是将Shell通配符支持的几个特殊字符串替换成正则所用的特殊字符串而已。 fnmatch 本质上其实就是调用 fnmatchcase 来实现的。只不过在调用之前使用了 os.path.normcase 方法来消除平台差异而已。 filter 也比较简单， 其实就是对一系列的文件名进行 fnmatchcase 判断，只保留匹配正确的文件名而已。当然它内部代码实现没有复用 fnmatchcase ，这个也是我接下来的槽点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def filter ( names , pat ): \"\"\"Return the subset of the list NAMES that match PAT\"\"\" import os , posixpath result = [] pat = os . path . normcase ( pat ) if not pat in _cache : res = translate ( pat ) if len ( _cache ) >= _MAXCACHE : _cache . clear () _cache [ pat ] = re . compile ( res ) match = _cache [ pat ] . match if os . path is posixpath : # normcase on posix is NOP. Optimize it away from the loop. for name in names : if match ( name ): result . append ( name ) else : for name in names : if match ( os . path . normcase ( name )): result . append ( name ) return result 经过以上解析，其实fnmatch库的最主要函数就是 fnmatchcase 了。 1 2 3 4 5 6 7 8 9 10 11 12 13 def fnmatchcase ( name , pat ): \"\"\"Test whether FILENAME matches PATTERN, including case. This is a version of fnmatch() which doesn't case-normalize its arguments. \"\"\" if not pat in _cache : res = translate ( pat ) if len ( _cache ) >= _MAXCACHE : _cache . clear () _cache [ pat ] = re . compile ( res ) return _cache [ pat ] . match ( name ) is not None 看了代码就知道它的实现太简单了，将参数中的模式字符串调用 translate 函数转换成正则字符串，然后直接使用正则表达式对象的 match 方法就完事了。反而是使用了Cache这个非主要功能，占用了比较多的代码。 代码吐槽 Cache操作直接和函数的主要逻辑混在一起 既然使用到Cache，那么操作Cache的具体代码就要封装起来了啊。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class LimitedCache ( object ): def __init__ ( self , size = 100 ): super ( LimitedCache , self ) . __init__ () self . __max_size = size self . __cache = {} def clear ( self ): self . __cache . clear () def is_full ( self ): cache_size = len ( self . __cache ) return cache_size >= self . __max_size def get ( self , key ): value = self . __cache . get ( key , None ) self . is_full () and self . clear () return value def put ( self , key , value ): self . __cache [ key ] = value CACHE = LimitedCache ( size = 100 ) def fnmatchcase ( name , pat ): def _cache_pat ( pat ): re_pat = translate ( pat ) re_obj = re . compile ( re_pat ) CACHE . put ( ret_obj ) return re_obj re_obj = CACHE . get ( pat ) or _cache_pat ( pat ) return re_obj . match ( name ) is not None 这样看 fnmatchcase 函数是不是比较原来的版本简单明了许多。 Cache功能好像也不是 fnmatchcase 的主要功能吧。 既然不是主要功能，那么我们就不能和实现主要功能的代码混在一块。 那怎么实现？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class LimitedCache ( object ): def __init__ ( self , size = 100 ): super ( LimitedCache , self ) . __init__ () self . __max_size = size self . __cache = {} def clear ( self ): self . __cache . clear () def is_full ( self ): cache_size = len ( self . __cache ) return cache_size >= self . __max_size def get ( self , key ): value = self . __cache . get ( key , None ) self . is_full () and self . clear () return value def put ( self , key , value ): self . __cache [ key ] = value CACHE = LimitedCache ( size = 100 ) def cache_pat ( func ): def _cache_pat ( pat ): re_pat = translate ( pat ) re_obj = re . compile ( re_pat ) CACHE . put ( re_obj ) return re_obj return lambda name , pat : func ( name , CACHE . get ( pat ) or _cache_pat ( pat )) fnmatchcase = cache_pat ( lambda name , re_obj : re_obj . match ( name ) is not None ) # 版本2 # def fnmatchcase(name, pat): # def _fnmatchcase(name, re_obj): # return re_obj.match(name) is not None # return cache_pat(_fnmatchcase)(name, pat) # # 版本3（问题：修改了fnmatchcase的参数） # @cache_pat # def fnmatchcase(name, re_obj): # return re_obj.match(name) is not None 嗯，这样就差不多了。 filter 内部的主要逻辑和 fnmatchcase 差不多么，为什么不复用？ 1 2 3 4 5 6 7 8 9 def fnfilter ( names , pat ): return [ n for n in names if fnmatch ( n )] # 版本2 # return filter(fnmatch, names) def fnfiltercase ( names , pat ): return [ n for n in names if fnmatchcase ( n )] # 版本2 # return filter(fnmatchcase, names) 怎么样，比原来的代码清晰太多了吧。 总结 你是依据什么原则来吐槽的？ 一个函数只做一件事。 Cache值为什么设为100？ 之间我看过相关文章说，Python源码里的某些具体数值是经过大量实践统计出来，我估计这个数值可能也是统计出来的，当然也可能是写个模块的作者个人喜好吧。 PS：要是我写，我就写128，哈哈。 能写Python标准库的作者水平应该不错，为什么你会挑出这么多毛病？ 一般写标准库需要考虑： 库之间的尽量不要有依赖 效率要尽量高 版本兼容性 ... ... LimitedCache一方面是为了封装高内聚的操作，一方面也是为了重用。但这两方面在标准库代码中都不是首要的，你封装了一层，那肯定要多调一层代码，效率就降低了，库之间尽量不要有依赖，那重用这一块就更不用提了。 filter 如果是我那种实现的话，就要每次从Cache中取一次pat。而原来的代码只要在循环开始之前取一次即可。不过话又说回来了，我再提供一个不用Cache的 fnmatchcase 版本不就行了。 PS：这些都是我自己想的，当然有可能作者觉得这几个功能太简单，没必要将代码设计的太复杂。 Simple is better than complex. ， 嘿嘿。","tags":"Python","loc":"http://chenjiee815.github.io/fnmatchbiao-zhun-ku-yuan-ma-xue-xi.html","title":"fnmatch标准库源码学习"},{"text":"Contents 表 习题9.1.3 习题9.1.4 cons和结构体的确切关系 任意长的表的数据定义 处理任意长的表 习题9.3.1 习题9.3.2 习题9.3.3 设计自引用数据定义的函数 更多关于简单表的例子 习题9.5.2 习题9.5.3 习题9.5.4 习题9.5.5 习题9.5.6 习题9.5.7 习题9.5.8 表 结构体 是表达复合信息的一种方法。 如果我们事先不确定有多少个数据放在一起，该用什么？ 这时候可以用 表 。 表 可以表示任意且有限数目的数据。 empty 在Scheme表示为一个空表。 cons 可以从一个表构造出一个更长的表。 表并非一定由同种类型的数据组成，它可以包括任何类型的数据。 first 提取表中的第一个字段，Scheme规范好像是 car rest 提取表中的第二个字段，Scheme规范好像是 cdr 习题9.1.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ;; add-up-3: list-of-3-numbers -> number ;; 求表a-list-of-3-numbers中3个数之和 ( define ( add-up-3 a-list-of-3-numbers ) ( + ( first a-list-of-3-numbers ) ( first ( rest a-list-of-3-numbers )) ( first ( rest ( rest a-list-of-3-numbers ))))) ;; 递归形式和尾递归形式，题目未做要求， ;; 一时兴起写的 ;; 递归形式 ( define ( add-up-3 a-list-of-3-numbers ) ( cond [( null? a-list-of-3-numbers ) 0 ] [ else ( + ( fist a-list-of-3-numbers ) ( add-up-3 ( rest a-list-of-3-numbers )))])) ;; 尾递归形式 ( define ( add-up-3 a-list-of-3-numbers start ) ( cond [( null? a-list-of-3-numbers ) start ] [ else ( add-up-3 ( rest a-list-of-3-numbers ) ( + ( fist a-list-of-3-numbers ) start ))])) ;; distance-to-0-for-3: list-of-3-numbers -> number ;; 三维空间中某个点到原点的距离 ( define ( distance-to-0-for-3 list-of-3-numbers ) ( sqrt ( + ( sqr ( first list-of-3-numbers )) ( sqr ( first ( rest list-of-3-numbers ))) ( sqr ( first ( rest ( rest list-of-3-numbers ))))))) ;; 测试 ( distance-to-0-for-3 ' ( 2 3 4 )) 习题9.1.4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; contains-2-doll?: a-list-of-2-symbols -> boolean ;; 判断一个包含两个符号的表中是否有'doll ;; 模板 ( define ( contains-2-doll? a-list-of-2-symbols ) ... ( first a-list-of-2-symbols ) ... ... ( first ( rest a-list-of-2-symbols ) ... )) ( define DOLL 'doll ) ( define ( contains-2-doll? a-list-of-2-symbols ) ( or ( symbol=? ( first a-list-of-2-symbols )) ( symbol=? ( first ( rest a-list-of-2-symbols ))))) ;; 测试 ( contains-2-doll? ' ( as doll )) ( contains-2-doll? ' ( as sss )) cons和结构体的确切关系 cons其实是一个结构体，first和rest是它的两个选择器。 1 2 3 4 5 6 7 8 9 ( define-struct pair ( left right )) ( define ( out-cons a-value a-list ) ( make-pair ( a-value a-list ))) ( define ( out-first a-pair ) ( pair-left a-pair )) ( define ( our-rest a-pair ) ( pair-right a-pair )) ( define ( out-cons? x ) ( pair? x )) 不过cons还有一个要求，right字段要确保是一个表。 即，要么是cons结构，要么是一个空表。 1 2 3 4 5 ( define ( our-cons a-value a-list ) ( cond [( empty? a-list ) ( make-pair ( a-value a-list ))] [( our-cons? a-list ) ( make-pair ( a-value a-list ))] [ else ( error 'cons \"list as second argument expected\" )])) 任意长的表的数据定义 list-of-symbols(符号表)是下列两者之一： 空表empty (cons s los)，其中s是符号，而los是由符号组成的表 该定义使用了自引用，或者叫递归。 处理任意长的表 习题9.3.1 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; contains-doll?: list-of-symbols -> boolean ;; 判断符号'doll是否在a-list-of-symbols中 ( define ( contains-doll? a-list-of-symbols ) ( cond [( empty? a-list-of-symbols ) false ] [( symbol=? ( first a-list-of-symbols ) 'doll ) true ] [ else ( contains-doll? ( rest a-list-of-symbols ))])) ;;测试 ( contains-doll? empty ) ( contains-doll? ( cons 'ball empty )) ( contains-doll? ( cons 'arrow ( cons 'doll empty ))) ( contains-doll? ( cons 'bow ( cons 'arrow ( cons 'ball empty )))) 习题9.3.2 1 2 3 4 5 6 7 ;; contains-doll?: list-of-symbols -> boolean ;; 判断符号'doll是否在a-list-of-symbols中 ( define ( contains-doll? a-list-of-symbols ) ( cond [( empty? a-list-of-symbols ) false ] [ else ( or ( symbol=? ( first a-list-of-symbols ) 'doll ) ( contains-doll? ( rest a-list-of-symbols )))])) 习题9.3.3 1 2 3 4 5 6 7 ;; contains?: list-of-symbols symbol -> boolean ;; 判断符号a-symbol是否在a-list-of-symbols中 ( define ( contains-doll? a-list-of-symbols a-symbol ) ( cond [( empty? a-list-of-symbols ) false ] [( symbol=? ( first a-list-of-symbols ) a-symbol ) true ] [ else ( contains-doll? ( rest a-list-of-symbols ) a-symbol )])) 设计自引用数据定义的函数 更多关于简单表的例子 习题9.5.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ;; how-many-symbols: list-of-symbols -> number ;; 返回一个符号表中元素的个数 ( define ( how-many-symbols a-list-of-symbols ) ( cond [( empty? a-list-of-symbols ) 0 ] [ else ( + 1 ( how-many-symbols ( rest a-list-of-symbols )))])) ;; how-many-numbers: list-of-numbers -> number ;; 返回一个数值表中元素的个数 ( define ( how-many-numbers a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) 0 ] [ else ( + 1 ( how-many-numbers ( rest a-list-of-numbers )))])) ;; 两者除了参数类型不一样外，函数的具体逻辑是一模一样的 习题9.5.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ;; dollar-store?: list-of-numbers -> boolean ;; 检查一个物价表中是否所有元素小于1 ( define MIN_PRICE 1 ) ( define ( dollar-store? a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) false ] [ else ( and ( < MIN_PRICE ( first a-list-of-numbers )) ( dollar-store? ( rest a-list-of-numbers )))])) ( define ( super-dollar-store? a-list-of-numbers min-price ) ( cond [( empty? a-list-of-numbers ) false ] [ else ( and ( < min-price ( first a-list-of-numbers )) ( super-dollar-store? ( rest a-list-of-numbers ) min-price ))])) ;; 测试 ( dollar-store? empty ) ( not ( dollar-store? ( cons . 75 ( cons 1.95 ( cons . 25 empty ))))) ( dollar-store? ( cons . 75 ( cons . 95 ( cons . 25 empty )))) 习题9.5.4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define-struct temp-range ( min max )) ;; 结构体: (make-temp-range min max) ;; min, max 都为数值 ;; in-temp-range: temp-range number -> boolean ;; 检查某一个数值是否在温度区间内 ( define ( in-temp-range a-temp-range a-temp ) ( and ( >= a-temp ( temp-range-min a-temp-range )) ( <= a-temp ( temp-range-max a-temp-range )))) ;; check-range: list-of-numbers, number -> boolean ;; 检查温度值表中所有元素是否都在温度区间内 ( define ( check-range a-list-of-numbers a-temp-range ) ( cond [( empty? a-list-of-numbers ) true ] [ else ( and ( in-temp-range a-temp-range ( fist a-list-of-numbers )) ( check-range ( rest a-list-of-numbers ) a-temp-range ))])) 习题9.5.5 1 2 3 4 5 6 7 8 9 10 11 12 ( define BASE 10 ) ;; 进制位 ;; convert: list-of-numbers -> number ;; 读取一个数值表，然后输出一个数值 ;; 数值表的顺序和数值的每位数顺序一致 ( define ( convert a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) 0 ] [ else ( + ( * ( expt BASE ( how-many-numbers a-list-of-numbers )) ( first a-list-of-numbers )) ( convert ( rest a-list-of-numbers )))])) 习题9.5.6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ;; sum: list-of-numbers -> number ;; 求一个数值表中所有数值之和 ( define ( sum a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) 0 ] [ else ( + ( first a-list-of-numbers ) ( sum ( rest a-list-of-numbers )))])) ;; delta: list-of-numbers list-of-numbers -> number ;; 第一数值表表示月初的库存清单 ;; 第二数值表表示月末的库存清单 ;; 求两者价格差 ( define ( delta start-list-of-numbers end-list-of-numbers ) ( - ( sum end-list-of-numbers ) ( sum start-list-of-numbers ))) 习题9.5.7 1 2 3 4 5 6 7 8 ;; average-price: list-of-numbers -> number ;; 读入一个价格表并计算其平均价格 ( define ( average-price a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) ( error 'average-price \"non-empty list-of-number expected\" )] [ else ( / ( sum a-list-of-numbers ) ( how-many-numbers a-list-of-numbers ))])) 习题9.5.8 1 2 3 4 5 6 7 8 ;; draw-circles: posn list-of-numbers -> number ;; 读取一个圆心位置和一系列的圆半径数值表 ;; 在画布上画出所有的圆 ( define ( draw-circles center radiuses ) ( cond [( empty? radiuses ) true ] [ else ( and ( draw-circle center ( first radiuses )) ( draw-circles center ( rest radiuses )))]))","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-jiu-zhang-fu-he-shu-ju-lei-xing-zhi-er-biao.html","title":"HTDP第九章：复合数据类型之二：表"},{"text":"Contents 简介 安装 依赖 更新 创建 Pelican 工程目录 使用 Pelican 编写文章 语法高亮 Makefile make html make clean make regenerate make serve make devserver make stopserver 其它make子命令 develop_server.sh 简介 Pelican 是一个用Python实现的静态网站生成器。 通过 reStructuredText 或 MarkDown 语言，直接使用你的编辑器编写博客 使用简单的命令行工具生成博客 易于与版本控制工具和WEB应用配合使用 全静态输出可以方便的在任何地方部署 简单来说，就是你使用 reStructuredText 或者 MarkDown 来生写网站的具体内容，然后用这个工具根据你之前写的内容来生成对应的网页。 这个工具一般用来生成静态的博客是极好的，并且网上也很多技术人的博客也已经是这样来实现的。 本指南只讲解了一些有关 Pelican 的入门知识，如果你想了解更多，请移步 Pelican中文文档 ，或者 Pelican官方文档 。 安装 Pelican 的安装还是很简单的，因为它属于Python的一个第三方库，所以直接一条命令即可： 1 $ pip install pelican 如果系统报没有 pip 这个命令，你可以点击 pip的安装文档 。 依赖 到目前为止， Pelican 依赖于以下Python包： Pelican安装之后，依赖于以下的Python包都将会自动安装： feedgenerator, 生成Atom jinja2, 模板支持 pygments, 语法高亮 docutils, 支持reStructuredText输入格式 pytz, 定义时区 blinker, 消息分发系统 unidecode, Unicode文件转码 six, 兼容Python2、3 MarkupSafe, 安全标记字符串 如果需要以下安装包，可以通过 pip 命令手动安装： markdown, 支持Markdown格式输入 typogrify, 增强排版 更新 Pelican 的更新还是一样依赖于 pip 命令： 1 $ pip install -U pelican 创建 Pelican 工程目录 首先创建一个 Pelican 工程目录 myblog （目录名称自定义）： 1 2 3 $ mkdir myblog $ cd myblog $ pelican-quickstart 运行 pelican-quickstart 后会有一堆的提示信息。 Where do you want to create your new web site? 你想在哪里创建你的网站，默认当前目录 What will be the title of this web site? 网站标题是什么？ Who will be the author of this web site? 网站作者？ What will be the default language of this web site? 网站默认语言？默认为en，我一般写zh。 Do you want to specify a URL prefix? 是否指定一个URL前缀 Do you want to enable article pagination? 文章是否需要分页？ How many articles per page do you want? 每页多少个文章？ 默认10个。 Do you want to generate a Fabfile/Makefile to automate generation and publishing? 是否需要生成Fabfile/Makefile来对文档的生成和发布进行管理。 建议你选择是。 Do you want an auto-reload & simpleHTTP script to assist with theme and site development? 是否需要一个文档更改后能够自动更新的简单HTTP服务器。 建议也选择是。下面会讲到这个服务器，很有用。 下面的问题，都是问你通过哪种方面将你生成的网页上传到你的真实站点。 然后会在 myblog 目录中生成一些目录及文件，其结构 blog/ ├── content # 存放你要写的博客 │ └── (pages) #单纯的页面 ├── output # 生成的输出文件 ├── develop_server.sh# 方便开启测试服务器 ├── Makefile # 方便管理博客的Makefile ├── pelicanconf.py # 主配置文件 └── publishconf.py # 主发布文件，可删除 使用 Pelican 编写文章 Pelican 尽可能地会从文件系统中来获取信息（比如，获取文章分类的方式）。 但是你最好在文件的元数据中提供。 下面以 reStructuredText 为例。 1 2 3 4 5 6 7 ============= |PL| 指南 ============= :date: 2014-06-22 10:00 :tags: pelican, python, blog :category: 学习 Tip 除了标题外，其它元素都不是必须的。 如果没有日期， Pelican 是以对应文件的修改时间为日期。 如果没有分类， Pelican 将使用文件所放置的目录名称作为分类。 语法高亮 Pelican 使用Pyments来支持语法高亮，所以你可以在你的 reStructuredText 文档里使用如下方法： 1 2 3 .. code-block :: identifier your code 其中 identifier 必须存在与这个列表中 list of available lexers 的字段匹配。 Makefile 你可以直接在之前创建的 Pelican 的工程目录里面执行 make 命令： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ make Makefile for a pelican Web site Usage: make html ( re ) generate the web site make clean remove the generated files make regenerate regenerate files upon modification make publish generate using production settings make serve [ PORT = 8000 ] serve site at http://localhost:8000 make devserver [ PORT = 8000 ] start/restart develop_server.sh make stopserver stop local server make ssh_upload upload the web site via SSH make rsync_upload upload the web site via rsync+ssh make dropbox_upload upload the web site via Dropbox make ftp_upload upload the web site via FTP make s3_upload upload the web site via S3 make cf_upload upload the web site via Cloud Files make github upload the web site via gh-pages Set the DEBUG variable to 1 to enable debugging, e.g. make DEBUG = 1 html Pelican 的作者将所有 Pelican 的用到的功能都封装进去了。你可以不用理会 Pelican 提供的其它命令是如何使用的，直接使用 make 的各种子命令就可以了。 关于各个子命令，我下面穿插着讲到。 同时会也讲到这个子命令封装了 Pelican 提供的哪个原始命令。 make html 这个命令将当前content目录中的内容生成对应的网页，不过此命令生成的网页只是简单的HTML内容，并没有CSS样式之类。 make clean 直接清除整个output目录 make regenerate 如果每次检测到变化时，你希望Pelican会自动重新生成页面（本地测试都是基于手动生成），可以使用该命令。 它的生成的页面还是和 make html 是一样的，没有什么CSS样式。 make serve 启动一个后台服务，来显示生成的网页，不过当content目录内容更新时，该服务不会自动更新网页。 make devserver 同样也是启动一个后台服务，不过它会在content目录内容更新时，会自动更新网页内容。 make stopserver 停止用上面两个命令启动的后台服务。 其它make子命令 其它子命令都是用来上传生成的网页到指定服务器用的。 develop_server.sh 该命令开启一个测试用的服务器。 基本使用方法： 1 $ ./develop_server.sh ( start|stop|restart ) [ port ] 可以看到，它的使用方法也是比较简单的： start 开启一个测试服务器，启动成功后，服务器会在后台运行 stop 停止一个测试服务器 restart 重启测试服务器 port 绑定特定的端口号，默认为8000 这个测试服务器比较方便的就是它会自动监控content目录中的文件，如果有新的文件生成、文件内容发生变化，它会立即生成新的页面（在浏览器里手动刷新即可看到新生成的页面），同时它也会在后台打印出详细的debug日志。 make devserver 其实就是对该命令一层简单封装。","tags":"python","loc":"http://chenjiee815.github.io/pelicanru-men-zhi-nan.html","title":"Pelican入门指南"},{"text":"pip官方文档 以下内容是根据pip的1.5.X版本的官方文档写的笔记。 官方文档有用户指南专门一章节，我翻译时将之分割到多个章节中去了。 Contents 安装pip 升级pip 常用命令介绍 配置 配置文件 环境变量 配置的优先级 命令的自动补全 pip install 使用方法 本地快速安装 非递归式升级 特定用户安装 pip uninstall 使用方法 已知缺陷 参数 pip freeze 使用方法 参数 常见应用场景 pip list 使用方法 参数 pip show 使用方法 参数 pip search 使用方法 参数 pip wheel 使用方法 参数 常见应用场景 其它 国内镜像源 安装pip 可以下载 get-pip.py ， 运行命令： 1 $ python get-pip.py 如果setuptools没有安装，该命令同时也会安装它。 如果已经安装了setuptools库，那么可以通过easy_install安装： 1 $ easy_install pip 升级pip 在Linux系统上： 1 $ pip insall -U pip 在Windows系统上： 1 $ python -m pip install -U pip 常用命令介绍 安装包 1 $ pip install SomePackage 升级包 1 2 3 $ pip install --upgrade SomePackage $ pip install -U SomePackage 删除包 1 $ pip uninstall SomePackage 查看某个包安装了哪些文件 1 $ pip show --files SomePackage 列出哪些包过期了，或者说是有新的版本了 1 $ pip list --outdated 配置 配置文件 配置文件路径： Unix: ~/.pip/pip.conf Windows: %HOMEPATH%pippip.ini 当然，如果你想自定义配置文件的存放路径，你可以将你自定义的路径保存到环境变量 PIP_ONFIG_FILE 。 配置文件的格式类似于INI文件。 当你想添加一个对所有命令都生效的参数时，可以将该配置放置在 [global] 段中。例如： 1 2 3 [global] timeout = 60 index-url = http://pypi.douban.com/simple 如果你想针对pip的某个子命令进行配置的话，可以将该子命令名称当作段名称，该段内的配置与 [global] 中的配置冲突则会覆盖之。 比如 freeze 子命令： 1 2 [freeze] timeout = 10 比如 install 子命令： 1 2 3 4 5 6 [install] ignore-installed = true no-dependencies = yes find-links = http://mirror1.example.com http://mirror2.example.com 环境变量 pip的命令行参数也可以通过环境变量来设置。 它的格式为： PIP_<UPPER_LONG_NAME> 。 比如设置超时： 1 $ export PIP_DEFAULT_TIMEOUT = 60 其效果等于： 1 $ pip --default-timeout = 60 [ ... ] 比如设置find-links： 1 $ export PIP_FIND_LINKS = \"http://mirror1.example.com http://mirror2.example.com\" 其效果等于： 1 2 $ pip install --find-links = http://mirror1.example.com --find-links = http://mirror2.example.com 配置的优先级 刚才讲到一个参数的三种配置方法优先级顺序是： 命令行 环境变量 配置文件 命令的自动补全 用过bash/zsh环境的人都知道有自动补全功能。 pip命令想要自动补全功能的话，可以运行以下命令： 1 2 3 $ pip completion --bash >> ~/.profile $ pip completion --zsh >> ~/.zprofile 加入到profile文件后，需要重新进入bash/zsh环境才能生效，你也可以运行以下命令，立即生效自动补全功能： 1 $ eval \"`pip completion --bash`\" pip install 安装Python包 使用方法 1 2 3 4 5 6 7 8 9 $ pip install [ options ] <requirement specifier> ... $ pip install [ options ] -r <requirements file> ... $ pip install [ options ] [ -e ] <vcs project url> ... $ pip install [ options ] [ -e ] < local project path> ... $ pip install [ options ] <archive url/path> ... 本地快速安装 下载你所需要的所有的Python包 1 $ pip install --download <DIR> -r requirements.txt 使用以下命令即可安装刚才下载到本地的Python包 1 $ pip install --no-index --find-links =[ file:// ] <DIR> -r requirements.txt 非递归式升级 其实就是只升级你需要的包，但是该包所依赖的包不安装/升级。 1 $ pip install --upgrade --no-deps SomePackage 特定用户安装 从Python2.6开始，Python就支持将Python包安装到指定的用户目录了。 该用户的目录默认值是由 site.USER_BASE 所指定的。 如果想覆盖该值，则使用环境变量 PYTHONUSERBASE 。 可以通过 --user 参数来指定特定用户。 1 2 $ export PYTHONUSERBASE = /myappenv $ pip install --user SomePackage pip uninstall 卸载Python包 使用方法 1 2 3 $ pip uninstall [ options ] <package> ... $ pip uninstall [ options ] -r <requirements file> ... 已知缺陷 目前已知的两种无法正常删除的情况： 完全使用disutils模块制定的Python包，且通过 python setup.py install 来安装的。这种包没有什么元信息能够知道它倒底安装了哪些文件。 通过 python setup.py develp 来安装的脚本。 参数 -r , --requirement <file> 删除requirements.txt文件中的包含的Python包名，可以跟多个该参数 -y , --yes 在删除时不需要确认 pip freeze 将当前Python环境所有的安装包名输出成requirements格式。 使用方法 1 $ pip freeze [ options ] 参数 -r , --requirement <file> 先输出该requirement文件内的Python包名。 再输出当前环境安装的Python包，requirement文件中有的Python包名则不再显示。 当requirement文件中的包名在环境没有，则会给出提示。 -f , --find-links <url> 从该URL来查找Python包，查找出来的Python包名也会输出出来。 说实话，我还真不知道这个参数的应用场景是什么。 -l , --local 如果一个virtualenv环境被配置成能够读取全局的Python包，那么在该环境内运行 pip freeze -l 时，不会显示全局的Python包名。 常见应用场景 当你需要将一个virtualenv环境中复制到另外一个virtualenv环境时，你可以先在源virtualenv环境运行命令： 1 $ pip freeze > requirements.txt 然后再进入目的virtualenv环境运行命令： 1 $ pip install -r requirements.txt 这样就完成了虚拟环境的复制过程。 这时可能有人会问，virtualenv环境不就是一个目录么，直接拷贝一下，不就一个跟原来一样的新的virtualenv环境么？ 好吧，我觉得这方法一般情况也可以的。 但是如果源virtualenv环境和目的virtualenv环境的Python版本或者操作系统不一样，建议你还是老实地按照上面的说做吧。 pip list 列出当前环境所有已经安装的Python包，包括可编辑的包（including editables）。 好像功能和 pip freeze 功能差不多的么，只是输出的格式不一样。 可编辑的包是啥意思？暂时还不清楚。 使用方法 1 $ pip list [ options ] 参数 -o , --outdated 列出所有有新版本的Python包名（不包括可编辑包） -u , --uptodate 列出所有更新到最新版本的Python包名 -e , --editable 列出所有可编辑的包名 -l , --local 如果一个virtualenv环境被配置成能够读取全局的Python包，那么在该环境内运行 pip list -l 时，不会显示全局的Python包名。 --pre 列出的包中包括预发行或者是开发包，默认只会列出稳定版本的包 -i , --index-url <url> Python Package Index 的URL地址 --extra-index-url <url> 更多的 Python Package Index 的URL地址 --no-index 忽略包索引，只与 --find-links 参数配合使用 -f , --find-links <url> 如果为一个URL或者是一个指定HTML页面的路径，PIP会从该地址解析出包地址。 如果是一个本地目录，PIP就会直接从该目录中查找所需要的包。 --allow-external <package> Allow the installation of externally hosted files --allow-all-external Allow the installation of all externally hosted files --allow-unverified <package> Allow the installation of insecure and unverifiable files --process-dependency-links Enable the processing of dependency links pip show 列出一个或者多个包的信息 使用方法 1 $ pip show [ options ] <package> ... 参数 -f , --files 列出一个已安装包中的所有文件 pip search 从 Python Package Index 上查找Python包名或者其简要描述中包含关键字（<query>）的Python包。 使用方法 1 $ pip search [ options ] <query> 参数 --index <url> Python Package Index URL地址 pip wheel 创建wheel格式的Python包 使用该参数，需要您的环境安装setuptools >= 0.8，并且安装了wheel。 pip wheel 使用setuptools扩展 bdist_wheel 来制作wheel格式的Python包。 如果想更多了解wheel，请看 wheel官方文档 。 使用方法 1 2 3 4 5 6 7 8 9 $ pip pip wheel [ options ] <requirement specifier> ... $ pip wheel [ options ] -r <requirements file> ... $ pip wheel [ options ] <vcs project url> ... $ pip wheel [ options ] < local project path> ... $ pip wheel [ options ] <archive url/path> ... 参数 -w , --wheel-dir <dir> wheel格式Python包的存放目录，默认为 <cwd>/wheelhouse --no-use-wheel 当在 Python Package Index 上查找包时不优先查找wheel格式的Python包 --build-option <options> setup.py bdist_wheel 提供的额外参数 -r , --requirement <file> 从requirements文件进行安装，该参数可以跟多个 --download-cache <dir> 从网上下载的原始Python包的临时存放目录 --no-deps 不安装某个包的依赖包 -b , --build <dir> build目录，在virtualenv环境中默认值为 <venv path>/build ,在正常环境默认值为 <OS temp dir>/pip_build_<username> --global-option <options> bdsit_wheel 命令所用到的一些全局参数 --pre 列出的包中包括预发行或者是开发包，默认只会列出稳定版本的包 --no-clean 不清除build目录 -i , --index-url <url> Python Package Index 的URL地址 (默认为 https://pypi.python.org/simple/ ) --extra-index-url <url> 更多的 Python Package Index 的URL地址 --no-index 忽略包索引，只与 --find-links 参数配合使用 -f , --find-links <url> 如果为一个URL或者是一个指定HTML页面的路径，PIP会从该地址解析出包地址。 如果是一个本地目录，PIP就会直接从该目录中查找所需要的包。 --allow-external <package> Allow the installation of externally hosted files --allow-all-external Allow the installation of all externally hosted files --allow-unverified <package> Allow the installation of insecure and unverifiable files --process-dependency-links Enable the processing of dependency links. 常见应用场景 先将需要的所有第三方Python包打包到本地目录，然后再从本地目录直接安装之前已经打包好的wheel格式的Python包。 1 2 $ pip wheel --wheel-dir = /tmp/wheelhouse SomePackage $ pip install --no-index --find-links = /tmp/wheelhouse SomePackage 其它 国内镜像源 豆瓣PyPI 华中理工大学PyPI 山东理工大学PyPI ， 这个貌似用不了。 中国科学技术大学PyPI 可以用pip的 -i 参数来指定镜像源。 1 $ pip install gevent -i http://pypi.douban.com/simple 如果不想每次手动指定，且永久有效的话，可以写入到pip的配置文件中。 1 2 [global] index-url = http://pypi.douban.com/simple","tags":"python","loc":"http://chenjiee815.github.io/pipzhi-nan.html","title":"pip指南"},{"text":"Contents distutils setuptools distribute easy_install pip distutils2 我先给出对比结果： 推荐使用 setuptools + pip 具体原因看下文。 distutils 目前属于Python标准库的一部分。 只适用于非常简单的应用场景，建议使用 setuptools 。 setuptools setuptools是对distutils的增强, 尤其是引入了包依赖管理。 setuptools可以为Python包创建egg文件。 包含包目录内的数据文件。 自动包含包目录内的所有的包，而不用在setup.py中列举。 自动包含包内和发布有关的所有相关文件，而不用创建一个MANIFEST.in文件。 自动生成经过包装的脚本或Windows执行文件。 支持Pyrex，即在可以setup.py中列出.pyx文件，而最终用户无须安装Pyrex。 支持上传到PyPI。 可以部署开发模式，使项目在sys.path中。 用新命令或setup()参数扩展distutils，为多个项目发布/重用扩展。 基本满足大型项目的安装和发布。 setuptools的诸多功能下面会有具体讲解。 distribute 由于setuptools初期开发进度缓慢, 不支持 Python3, 代码混乱,一帮程序员另起炉灶, fork并且重构setuptools代码, 增加功能。 然后2013年8月，distribute又合并回setuptools 0.7。 easy_install setuptools和distribute自带的安装脚本。 只支持从 PyPI 下载安装Python包。 pip pip的目标非常明确：取代easy_install。 支持安装、卸载包。 支持从任意能够通过VCS或浏览器访问到的地址安装Python包。 pip的功能之强大，可以看下面专门讲解PIP的章节。 distutils2 它本来应该成为Python3的标准库packaging， 在其它Python版本里叫做distutils2。 该项目在2012年已经停止了，官方文档建议使用setuptools + pip。","tags":"python","loc":"http://chenjiee815.github.io/pythonda-bao-gong-ju-dui-bi.html","title":"Python打包工具对比"},{"text":"Contents Scheme的词汇 Scheme的文法 习题8.2.1 习题8.2.2 习题8.2.3 习题8.2.4 Scheme的含义 错误 布尔值表达式 变量定义 结构体的定义 Beginning Student Scheme的完整语法 Scheme的词汇 <var> = x|area-of-disk|... <con> = true|false 'a|'b|... 1|-1|3/5|2.12|... <prm> = +|-|... Scheme的文法 <def> = (define (<var> <var> ... <var>) (exp)) <exp> = <var> | <con> | (<prm> <exp> ... <exp>) | ((var) <exp> ... <exp>) | (cond (<exp> <exp>) ... (<exp> <exp>)) | (cond (<exp> <exp>) ... (else <exp>)) 习题8.2.1 x <var> (= y z) (<prm> <var> <var>) (= (= y z) 0) (<prm> <exp> <var>) (3 + 4) 3 为一个常量 empty?(l) empty? 没有用括号包围，且参数调用也不合法 (x) 这个表达式如果按照本书图8.2的语法规则来说是不正确的。 因为 x 后面没有其它表达式。 但在真正的Scheme语法规则中是正确的。 习题8.2.2 (define (f 'x) x) (<prm> <exp> <var>) (define (f x) x) (<prm> <exp> <exp>) (define (f x y) 3) (<prm> <exp> <con>) (define (f 'x) x) 'x 应该为一个<var> (define (f x y z) (x)) (x) 中的 x 后面没有其它表达式 (define (f) 10) (f) 中的 f 后面没有其它表达式 习题8.2.3 (x) 不合法，因为 x 后面没有其它表达式 (+ 1 (not x)) 符合(<prm> <con> <exp>) (+ 1 2 3) 符合(<prm> <con> <con> <con>) 习题8.2.4 (define (f x) 'x) 符合(<prm> <exp> <exp>) (define (f 'x) x) 不符合， 'x 应该为一个<var> (define (f x y) (+ 'y (not x))) 不符合， 'y 应该为一个数值, (not x) 也应该为一个数值 Note 这一题和标准答案不一样，我还是觉得我的正确 Scheme的含义 错误 表达式计算原则 简化最外（最左的）可以计算的表达式。 布尔值表达式 <exp> = (and <exp> <exp>) | (or <exp> <exp>) 1 2 3 4 5 6 7 8 9 10 11 ( and <exp-1> <exp-2> ) ;; == ( cond [ <exp-1> <exp-2> ] [ else false ]) ( or <exp-1> <exp-2> ) ;; == ( cond [ <exp-1> true ] [ else <exp-2> ]) 变量定义 <def> = (define <var> <exp>) 结构体的定义 <def> = (define-struct <var0> (<var-1> <var-2> ... <var-n>)) <val> = (make-c <val> ... <val>) Beginning Student Scheme的完整语法 <def> = (define (<var> <var> ... <var>) (exp)) | (define <var> <exp>) | (define-struct <var0> (<var-1> <var-2> ... <var-n>)) <exp> = <var> | <con> | (<prm> <exp> ... <exp>) | ((var) <exp> ... <exp>) | (cond (<exp> <exp>) ... (<exp> <exp>)) | (cond (<exp> <exp>) ... (else <exp>)) | (and <exp> <exp>) | (or <exp> <exp>)","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-ba-zhang-yu-fa-he-yu-yi.html","title":"HTDP第八章：语法和语义"},{"text":"Contents 数据混合与区分 习题7.1.3 设计处理混合数据的函数 习题7.2.1 习题7.2.2 再论函数复合 习题7.3.1 补充练习：图形的移动 习题7.4.1 习题7.4.2 习题7.4.3 习题7.4.4 习题7.4.5 习题7.4.6 输入错误 习题7.5.1 习题7.5.2 习题7.5.3 数据混合与区分 之前设计的函数都是只能处理一种类型的数据。 这章要讲的是同一个函数如何能处理不同的类型的数据。 其实很简单，在函数的开头， 通过一定的方法先判断一下传入的数据属于哪一类型即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define PI 3.14 ) ( define-struct square ( nw length )) ;; nw为posn结构体， length为数值 ( define-struct circle ( center radius )) ;; center为posn结构体， radius为数值 ;; perimeter: a-shape -> number ;; 传入一个图形来获取其周长（只支持正方形、圆形） ( define ( perimeter a-shape ) ( cond (( square? a-shape ) ( * ( square-length a-shape ) 4 )) (( circle? a-shape ) ( * 2 ( circle-radius a-shape ) PI )))) 习题7.1.3 1 2 3 4 5 6 ;; area: a-shape -> number ;; 传入一个图形来获取其面积（只支持正方形、圆形） ( define ( area a-shape ) ( cond (( square? a-shape ) ( sqr ( square-length a-shape ))) (( circle? a-shape ) ( * ( sqr ( circle-radius a-shape )) PI )))) 设计处理混合数据的函数 习题7.2.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ( define-struct spider ( legs space )) ( define-struct elephant ( space )) ( define-struct monkey ( intelligence space )) ;; animal是下列三者之一 ;; 1. 结构体：(make-spider l s) ;; l为数值，s为数值 ;; 2. 结构体：(make-elephant s) ;; s为数值 ;; 3. 结构体：(make-monkey (i s)) ;; i为数值，s为数值 ;; 模板 ;; (define (f a-animal) ;; (cond ;; ((spider? a-animal) ...(spider-space a-animal)...) ;; ((elephant? a-animal) ...(elephant-space a-animal)...) ;; ((monkey? a-animal) ...(monkey-space)...))) ;; fits?: animal, number -> boolean ;; 判断笼子是否能容得下一个动物 ( define ( fits? animal cage-area ) ( cond [( spider? animal ) ( = ( spider-space animal ) cage-area )] [( elephant? animal ) ( = ( elephant-space animal ) cage-area )] [( monkey? animal ) ( = ( monkey-space animal ) cage-area )])) ;; 测试 ( fits? ( make-spider 6 10 ) 500 ) ( fits? ( make-elephant 10000 ) 5000 ) ( fits? ( make-monkey 30 1000 ) 800 ) 习题7.2.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ( define-struct bus ( area passengers )) ( define-struct luxurycar ( area passengers )) ( define-struct coach ( area passengers )) ( define-struct subway ( area passengers )) ;; vehicle是以下四者之一 ;; 1. 结构体：(make-bus a p) ;; a, p都为数值 ;; 2. 结构体：(make-luxurycar a p) ;; a, p都为数值 ;; 3. 结构体：(make-coach a p) ;; a, p都为数值 ;; 4. 结构体：(make-subway a p) ;; a, p都为数值 ;; 模板 ;; (define (f a-vehicle) ;; (cond ;; [(bus? a-vehicle) ;; ...(bus-area a-vehicle)... ;; ...(bus-passengers a-vehicle)...] ;; [(luxurycar? a-vehicle) ;; ...(luxurycar-area a-vehicle)... ;; ...(luxurycar-passengers a-vehicle)...] ;; [(coach? a-vehicle) ;; ...(coach-area a-vehicle)... ;; ...(coach-passengers a-vehicle)...] ;; [(subway? a-vehicle) ;; ...(subway-area a-vehicle)... ;; ...(subway-passengers a-vehicle)...])) 再论函数复合 习题7.3.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( define PI 3.14 ) ( define-struct circle ( center radius )) ( define-struct square ( nw length )) ( define-struct rectangle ( nw width length )) ;; shape 是下列三者之一 ;; 1. 结构体: (make-circle c r) ;; c是posn结构体，s是数值n ;; 2. 结构体：(make-square n l) ;; n是posn结构体，l是数值 ;; 3. 结构体：(make-rectangle n w l) ;; n是posn结构体，w, l是数值 ;; perimeter: shape -> number ;; 计算a-shape的周长 ( define ( perimeter a-shape ) ( cond [( circle? a-shape ) ( * ( * 2 ( circle-radius a-shape )) PI )] [( square? a-shape ) ( * ( square-length a-shape ) 4 )] [( rectangle? a-shape ) ( * 2 ( + ( rectangle-width a-shape ) ( rectangle-length a-shape )))])) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ( define PI 3.14 ) ( define-struct circle ( center radius )) ;; 结构体: (make-circle c r) ;; c是posn结构体，s是数值n ( define-struct square ( nw length )) ;; 结构体：(make-square n l) ;; n是posn结构体，l是数值 ( define-struct rectangle ( nw width length )) ;; 结构体：(make-rectangle n w l) ;; n是posn结构体，w, l是数值 ;; shape是下列三者之一 ;; 1. circle ;; 2. square ;; 3. rectangle ;; perimeter: shape -> number ;; 计算a-shape的周长 ( define ( perimeter a-shape ) ( cond [( circle? a-shape ) ( perimeter-circle a-shape )] [( square? a-shape ) ( perimeter-square a-shape )] [( rectangle? a-shape ) ( perimeter-rectangle a-shape )])) ;; perimeter-circle: circle -> number ;; 计算circle的周长 ( define ( perimeter-circle a-circle ) ( * ( * 2 ( circle-radius a-circle )) PI )) ;; perimeter-square: square -> number ;; 计算square的周长 ( define ( perimeter-square a-square ) ( * ( square-length a-square ) 4 )) ;; perimeter-rectangle: rectangle -> number ;; 计算rectangle的周长 ( define ( perimeter-rectangle a-rectangle ) ( * 2 ( + ( rectangle-width a-rectangle ) ( rectangle-length a-rectangle )))) 补充练习：图形的移动 这章的练习是6.6章节的扩展。 习题7.4.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define-struct circle ( point radius color )) ( define-struct rectangle ( nw-corner width height color )) ;; shape 是下列二者之一 ;; 1. 结构体: (make-circle point radius color) ;; point为posn结构体，radius为一个整数，color为一个符号 ;; 2. 结构体：(make-rectangle nw-corner width height color) ;; nw-color 为一个posn结构体 ;; width height 为数值 ;; color 为符号 ;; 模板 ( define ( fun-for-shape a-shape ) ( cond [( circle? a-shape ) ... ( circle-point a-shape ) ... ... ( circle-radius a-shape ) ... ... ( circle-color a-shape ) ... ] [( rectangle? a-shape ) ... ( rectangle-nw-corner a-shape ) ... ... ( rectangle-width a-shape ) ... ... ( rectangle-height a-shape ) ... ... ( rectangle-color a-shape ) ... ])) 习题7.4.2 1 2 3 4 5 6 7 8 ;; draw-shape: shape -> boolean ;; 将一个图形画到画布上 ( define ( draw-shape a-shape ) ( cond [( circle? a-shape ) ( draw-a-circle a-shape )] [( rectangle? a-shape ) ( draw-a-rectangle a-shape )])) 习题7.4.3 1 2 3 4 5 6 7 8 9 ;; translate-shape: shape number -> shape ;; 根据原始的图形和一个数delta， ;; 输出另外一个图形，其位于原始图形的右边 ( define ( translate-shape a-shape delta ) ( cond [( circle? a-shape ) ( translate-circle a-shape delta )] [( rectangle? a-shape ) ( translate-rectangle a-shape delta )])) 习题7.4.4 1 2 3 4 5 6 7 8 ;; clear-shape: shape -> boolean ;; 在画布上清除一个图形 ( define ( clear-shape a-shape ) ( cond [( circle? a-shape ) ( clear-a-circle a-shape )] [( rectangle? a-shape ) ( clear-a-rectangle a-shape )])) 习题7.4.5 1 2 3 4 5 6 7 8 ;; draw-and-clear-shape: shape -> boolean ;; 在画布上画出一个图形，然后过一段时间清除 ( define ( draw-and-clear-shape a-shape ) ( cond [( circle? a-shape ) ( draw-and-clear-circle a-shape )] [( rectangle? a-shape ) ( draw-and-clear-rectangle a-shape )])) 习题7.4.6 1 2 3 4 5 6 7 8 ;; move-shape: delta shape -> shape ;; 绘制并消除一个图形，再平移delta个像素 ( define ( move-shape delta a-shape ) ( cond [( circle? a-shape ) ( move-circle a-shape )] [( rectangle? a-shape ) ( move-rectangle a-shape )])) 输入错误 习题7.5.1 1 2 3 4 5 6 7 8 9 ( define PI 3.14 ) ( define ( area-of-disk r ) ( * PI ( * r r ))) ( define ( checked-area-of-disk v ) ( cond [( and ( number? v ) ( > v 0 )) ( area-of-disk v )] [ else ( error 'check-area-of-disk \"positive number expected\" )])) 习题7.5.2 懒得到各章节找对应的函数了。 习题7.5.3 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define-struct vec ( x y )) ;; 结构体: (make-vec x y) ;; x, y 都为正数 ( define ( positive-number? v ) ( and ( number? v ) ( > v 0 ))) ( define ( check-make-vec x y ) ( cond [( and ( positive-number? x ) ( positive-number? y )) ( make-vec x y )] [ else ( error 'check-make-vec \"positive number expected\" )]))","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-qi-zhang-shu-ju-de-duo-yang-xing.html","title":"HTDP第七章：数据的多样性"},{"text":"补充练习：绘制简单图形 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; 红绿灯的大小 ( define WIDTH 50 ) ( define HEIGHT 160 ) ( define BULB-RADIUS 20 ) ( define BULB-DISTANCE 10 ) ;; 灯泡的位置 ( define X-BULBS ( quotient WIDTH 2 )) ( define Y-RED ( + BULB-DISTANCE BULB-RADIUS )) ( define Y-YELLOW ( + Y-RED BULB-DISTANCE ( * 2 BULB-RADIUS ))) ( define Y-GREEN ( + Y-YELLOW BULB-DISTANCE ( * 2 BULB-RADIUS ))) ;; 绘制红灯亮时的灯光 ( start WIDTH HEIGHT ) ( draw-solid-disk ( make-posn X-BULBS Y-RED ) BULB-RADIUS 'red ) ( draw-circle ( make-posn X-BULBS Y-YELLOW ) BULB-RADIUS 'yellow ) ( draw-circle ( make-posn X-BULBS Y-GREEN ) BULB-RADIUS 'green ) 习题6.2.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ;; clear-bulb: symbol -> boolean ;; 关闭对应颜色的红绿灯 ( define ( clear-bulb color ) ( cond (( symbol=? color 'red ) ( clear-red-bulb )) (( symbol=? color 'green ) ( clear-green-bulb )) (( symbol=? color 'yellow ) ( clear-yellow-bulb )))) ;; clear-red-bulb ;; 关闭红灯 ( define ( clear-red-bulb ) ( and ( clear-solid-disk ( make-posn X-BULBS Y-RED ) BULB-RADIUS 'red ) ( draw-circle ( make-posn X-BULBS Y-RED ) BULB-RADIUS 'red ))) ;; clear-yellow-bulb ;; 关闭黄灯 ( define ( clear-yellow-bulb ) ( and ( clear-solid-disk ( make-posn X-BULBS Y-YELLOW ) BULB-RADIUS 'yellow ) ( draw-circle ( make-posn X-BULBS Y-YELLOW ) BULB-RADIUS 'yellow ))) ;; clear-green-bulb ;; 关闭绿灯 ( define ( clear-green-bulb ) ( and ( clear-solid-disk ( make-posn X-BULBS Y-GREEN ) BULB-RADIUS 'green ) ( draw-circle ( make-posn X-BULBS Y-GREEN ) BULB-RADIUS 'green ))) 习题6.2.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ;; draw-bulb: symbol -> boolean ;; 打开对应颜色的红绿灯 ( define ( draw-bulb color ) ( cond (( symbol=? color 'red ) ( draw-red-bulb )) (( symbol=? color 'green ) ( draw-green-bulb )) (( symbol=? color 'yellow ) ( draw-yellow-bulb )))) ;; draw-red-bulb ;; 打开红灯 ( define ( draw-red-bulb ) ( draw-solid-disk ( make-posn X-BULBS Y-RED ) BULB-RADIUS 'red )) ;; draw-yellow-bulb ;; 打开黄灯 ( define ( draw-yellow-bulb ) ( draw-solid-disk ( make-posn X-BULBS Y-YELLOW ) BULB-RADIUS 'yellow )) ;; draw-green-bulb ;; 打开绿灯 ( define ( draw-green-bulb ) ( draw-solid-disk ( make-posn X-BULBS Y-GREEN ) BULB-RADIUS 'green )) 习题6.2.4 1 2 3 4 ;; switch: symbol symbol -> boolean ;; 关闭第一个灯，打开第二个灯 ( define ( switch close open ) ( and ( clear-bulb close ) ( draw-bulb open ))) 习题6.2.5 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; next: symbol -> symbol ;; 将当前红绿灯颜色救困扶危为下一颜色 ( define ( next current-color ) ( cond (( and ( symbol=? current-color 'red ) ( switch 'red 'green )) 'green ) (( and ( symbol=? current-color 'yellow ) ( switch 'yellow 'red )) 'red ) (( and ( symbol=? current-color 'green ) ( switch 'green 'yellow )) 'yellow ))) 结构体定义 Racket创建结构体： 1 2 3 4 5 ( define-struct structname ( field1 field2 ... )) ( define tmp_entry ( make-structname field1 field2 ... )) ( structname-field1 tmp_entry ) ( structname-field2 tmp_entry ) ... 习题6.3.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define-struct movie ( title producer )) ( define m ( make-movie 'title 'producer )) ( movie-title m ) ( movie-producer m ) ( define-struct boyfriend ( name hair eyes phone )) ( define d ( make-boyfriend 'name 'hair 'eyes 'phone )) ( boyfriend-name d ) ( boyfriend-hair d ) ( boyfriend-eyes d ) ( boyfriend-phone d ) ( define-struct cheerleader ( name number )) ( define r ( make-cheerleader 'name 'number )) ( cheerleader-name r ) ( cheerleader-number r ) ... 习题6.3.3 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define-struct plane ( name acceleration max-speed voyage )) ;; within-range: plane number -> boolean ;; 确定某个飞机是否能够到达指定目标 ( define ( within-range plane distence ) ( >= ( plane-voyage plane ) distence )) ;; reduce-reduce: plane -> plane ( define ( reduce-range plane ) ( make-plane ( plane-name plane ) ( plane-acceleration plane ) ( plane-max-speed plane ) ( * 0.8 ( plane-voyage plane )))) 数据定义 Scheme规范中没有强制在代码中提供方法来指定结构中每个字段的具体数据定义， 但是可以通过注释的方式来进行说明。 不过具体到各个Scheme方言，它们或多或少都在代码内提供相关方法来指定了。 设计处理复合数据的函数 习题6.5.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ( define-struct movie ( title producer )) ;; movie-template: movie -> ??? ( define ( movie-template a-movie ) ... ( movie-title a-movie ) ... ... ( movie-producer a-movie ) ... ) ( define-struct boyfriend ( name hair eyes phone )) ;; boyfriend-template: boyfriend -> ??? ( define ( boyfriend-template a-boyfriend ) ... ( boyfriend-name a-boyfriend ) ... ... ( boyfriend-hair a-boyfriend ) ... ... ( boyfriend-eyes a-boyfriend ) ... ... ( boyfriend-phone a-boyfriend ) ... ) ( define-struct cheerleader ( name number )) ;; cheerleader-template: cheerleader -> ??? ( define ( cheerleader-template a-cheerleader ) ... ( cheerleader-name a-cheerleader ) ... ... ( cheerleader-number a-cheerleader ) ... ) ( define-struct CD ( artist title price )) ;; CD-template: CD -> ?? ( define ( CD-template a-CD ) ... ( CD-artist a-CD ) ... ... ( CD-title a-CD ) ... ... ( CD-price a-CD ) ... ) ( define-struct sweater ( material size producer )) ;; sweater-template: sweater -> ??? ( define ( sweater-template a-sweater ) ... ( sweater-material a-sweater ) ... ... ( sweater-size a-sweater ) ... ... ( sweater-producer a-sweater ) ... ) 习题6.5.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ( define-struct time ( hours minutes seconds )) ;; hours, minutes, seconds 都为一个整数 ;; time->seconds: time -> number ;; 将时间转换成零晨到当前time的秒数 ;; (0 0 1) 就离零晨1秒 ;; (0 1 1) 就离零晨61秒 ;; (1 1 1) 就离零晨3661秒 ;; time-template: time -> ?? ( define ( time-template a-time ) ... ( time-hours a-time ) ... ... ( time-minutes a-time ) ... ... ( time-seconds a-time ) ... ) ( define ( time->seconds t ) ( + ( * 60 60 ( time-hours t )) ( * 60 ( time-minutes t )) ( time-seconds t ))) ;; 测试time->seconds ( eq? ( time->seconds ( make-time 0 0 0 )) 0 ) ( eq? ( time->seconds ( make-time 0 0 1 )) 1 ) ( eq? ( time->seconds ( make-time 0 1 0 )) 60 ) ( eq? ( time->seconds ( make-time 1 0 0 )) ( * 60 60 )) ( eq? ( time->seconds ( make-time 1 1 1 )) ( + ( * 60 60 ) 60 1 )) 补充练习：圆和长方形的移动 作者将实现这个补充练习的要求：圆和长方形的移动， 拆分成多个习题，每个习题基本是一个对应一个功能函数， 当你做完所有习题，就能体会到作者来做这这个练习的做题思路了。 并且每步的习题设计都是按照之前提出的 设计决窍 来执行的。 所以一定要按步骤完成，不要为了做习题而做习题， 而是掌握 设计决窍 ，了解作者的设计思路/思想并模仿以及学会它。 习题6.6.1 按照 设计决窍 ,第一步先说明数据定义，并设计该数据定义的模板。 1 2 3 4 5 6 7 8 ( define-struct circle ( point radius color )) ;; point为posn结构体，radius为一个整数，color为一个符号 ;; fun-for-circle: circle -> ?? ( define ( fun-for-circle a-circle ) ... ( circle-point a-circle ) ... ... ( circle-radius a-circle ) ... ... ( circle-color a-color ) ... ) 习题6.6.2 从这一题开始就是作者的做题思路了， 他将这一练习拆分成多个函数，如果让你自己做，你会有什么思路? 1 2 3 4 5 6 7 8 9 10 11 12 ;; draw-a-circle: circle -> boolean ;; 在屏幕上绘制一个圆 ( define ( draw-a-circle circle ) ( draw-circle ( circle-point circle ) ( circle-radius circle ) ( circle-color circle ))) ;; 测试 ( start 300 300 ) ( draw-a-circle ( make-circle ( make-posn 100 100 ) 50 'red )) ( draw-a-circle ( make-circle ( make-posn 150 150 ) 10 'yellow )) 习题6.6.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; posn-distance: posn posn -> number ;; 得到两点之间的距离 ( define ( posn-distance posn-a posn-b ) ( sqrt ( + ( sqr ( - ( posn-x posn-a ) ( posn-x posn-b ))) ( sqr ( - ( posn-y posn-a ) ( posn-y posn-b )))))) ;; 测试 ( = ( posn-distance ( make-posn 1 1 ) ( make-posn 4 5 )) 5 ) ;; in-circle?: circle posn -> boolean ;; 判断posn结构体表示的点是否在圆内 ( define ( in-circle? circle posn ) ( <= ( posn-distance ( circle-point circle ) posn ) ( circle-radius circle ))) ;; 测试 ( eq? ( in-circle? ( make-circle ( make-posn 100 100 ) 50 'red ) ( make-posn 110 110 )) #t ) ( eq? ( in-circle? ( make-circle ( make-posn 100 100 ) 50 'red ) ( make-posn 200 210 )) #f ) 习题6.6.4 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; translate-circle: circle number -> circle ;; 根据原始的圆circle和一个数delta， ;; 输出另外一个圆，其圆心位于原始圆的右边 ( define ( translate-circle circle delta ) ( make-circle ( make-posn ( + ( posn-x ( circle-point circle )) delta ) ( posn-y ( circle-point circle ))) ( circle-radius circle ) ( circle-color circle ))) ;; 测试 ( eq? ( translate-circle ( make-circle ( make-posn 100 100 ) 50 'red ) 200 ) ( make-circle ( make-posn 300 100 ) 50 'red )) 习题6.6.5 1 2 3 4 5 6 7 8 9 10 11 12 ;; clear-a-circle: circle -> boolean ;; 在画布上清除一个圆 ( define ( clear-a-circle circle ) ( clear-circle ( circle-point circle ) ( circle-radius circle ) ( circle-color circle ))) ;; 测试 ( start 300 300 ) ( define a-circle ( make-circle ( make-posn 100 100 ) 50 'red )) ( draw-a-circle a-circle ) ( clear-a-circle a-circle ) 习题6.6.6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ;; draw-and-clear-circle: circle -> boolean ;; 在画布上画出一个圆，然后过一段时间清除 ( define ( draw-and-clear-circle circle ) ( and ( draw-a-circle circle ) ( sleep-for-a-while 1 ) ( clear-a-circle circle ))) ;; 测试 ( start 300 300 ) ( draw-and-clear-circle ( make-circle ( make-posn 100 100 ) 50 'red )) ;; move-circle: number circle -> circle ;; 绘制并消除一个圆，再平移delta个像素 ( define ( move-circle delta a-circle ) ( cond (( draw-and-clear-circle a-circle ) ( translate-circle a-circle delta )) ( else a-circle ))) ;; 测试 ( start 200 100 ) ( draw-a-circle ( move-circle 10 ( move-circle 10 ( move-circle 10 ( make-circle ( make-posn 100 50 ) 20 'red ))))) 习题6.6.7 1 2 3 4 5 6 7 8 9 10 11 ( define-struct rectangle ( nw-corner width height color )) ;; nw-color 为一个posn结构体 ;; width height 为数值 ;; color 为符号 ;; fun-for-rect: rectangle -> ?? ( define ( fun-for-rect a-rectangle ) ... ( rectangle-nw-corner a-rectangle ) ... ... ( rectangle-width a-rectangle ) ... ... ( rectangle-height a-rectangle ) ... ... ( rectangle-color a-rectangle ) ... ) 习题6.6.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; draw-a-rectangle: rectangle -> boolean ;; 在画布上画出一个实心长方形 ( define ( draw-a-rectangle a-rectangle ) ( draw-solid-rect ( rectangle-nw-corner a-rectangle ) ( rectangle-width a-rectangle ) ( rectangle-height a-rectangle ) ( rectangle-color a-rectangle ))) ;; 测试 ( start 300 300 ) ( draw-a-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) 习题6.6.9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ( define-struct distance ( x y )) ;; x y 为数值 ;; fun-for-distance: distance -> ?? ( define ( fun-for-distance a-distance ) ... ( distance-x a-distance ) ... ... ( distance-y a-distance ) ... ) ;; in-rectangle?: rectangle posn ;; 判断一个像素是否在长方形内部 ( define ( in-rectangle? a-rectangle point ) ( let ( dis ( make-distance ( - ( posn-x point ) ( posn-x ( rectangle-nw-corner a-rectangle ))) ( - ( posn-y point ) ( posn-y ( rectangle-nw-corner a-rectangle ))))) ( and ( > ( distance-x dis ) 0 ) ( > ( distance-y dis ) 0 ) ( > ( distance-x dis ) ( rectangle-width a-rectangle )) ( > ( distance-y dis ) ( rectangle-height a-rectangle ))))) 习题6.6.10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ;; translate-rectangle: rectangle -> rectangle ;; 根据原始的长方形和一个数delta， ;; 输出另外一个长方形，其位于原始长方形的右边， ;; 左上角和原长方形的左上角距离为delta ( define ( translate-rectangle a-rectangle ) ( let (( nw-corner ( rectangle-nw-corner a-rectangle ))) ( make-rectangle ( make-posn ( + ( posn-x nw-corner ) delta ) ( posn-y nw-corner )) ( rectangle-width a-rectangle ) ( rectangle-height a-rectangle ) ( rectangle-color a-rectangle )))) ;; 测试 ( define src-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) ( define new-rectangle ( translate-rectangle src-rectangle 20 )) ( = ( + ( posn-x ( rectangle-nw-corner src-rectangle )) 20 ) ( posn-x ( rectangle-nw-corner new-rectangle ))) 习题6.6.11 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; clear-a-rectangle: rectangle -> boolean ;; 清除一个长方形 ( define ( clear-a-rectangle rectangle ) ( clear-solid-rect ( rectangle-nw-corner a-rectangle ) ( rectangle-width a-rectangle ) ( rectangle-height a-rectangle ) ( rectangle-color a-rectangle ))) ;; 测试 ( start 300 300 ) ( define a-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) ( draw-a-rectangle a-rectangle ) ( clear-a-rectangle a-rectangle ) 习题6.6.12 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; draw-and-clear-rectangle: rectangle -> boolean ;; 在画布上画出一个圆，然后过一段时间清除 ( define ( draw-and-clear-rectangle rectangle ) ( and ( draw-a-rectangle rectangle ) ( sleep-for-a-while 1 ) ( clear-a-rectangle rectangle ))) ;; 测试 ( start 300 300 ) ( draw-and-clear-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) ;; move-rectangle: number rectangle -> rectangle ;; 绘制并清除一个长方形，然后平移delta个像素 ( define ( move-rectangle delta a-rectangle ) ( cond (( draw-and-clear-rectangle a-rectangle ) ( translate-rectangle a-rectangle delta )) ( else a-rectangle ))) ;; 创建一个长方形，并移动4次 ( define a-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) ( draw-a-rectangle ( move-rectangle 10 ( move-rectangle 10 ( move-rectangle 10 ( move-rectangle 10 a-rectangle ))))) 补充练习：刽子手游戏 习题6.7.1 这一题我是直接复制官方的答案， 我压根没看懂它给的三个快照图片... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 ;; draw-next-part: symbol -> boolean ;; 绘制人体的某一部分， ;; 函数输入为以下七个符号之一: ;; 'right-leg 'left-leg 'left-arm 'right-arm 'body 'head 'noose ( define ( draw-next-part body-part ) ( cond [( eq? body-part 'body ) ( draw-solid-line ( make-posn 100 60 ) ( make-posn 100 130 ) 'black )] [( eq? body-part 'right-leg ) ( draw-solid-line ( make-posn 100 130 ) ( make-posn 30 170 ) 'black )] [( eq? body-part 'left-leg ) ( draw-solid-line ( make-posn 100 130 ) ( make-posn 170 170 ) 'black )] [( eq? body-part 'right-arm ) ( draw-solid-line ( make-posn 100 75 ) ( make-posn 40 65 ) 'black )] [( eq? body-part 'left-arm ) ( draw-solid-line ( make-posn 100 75 ) ( make-posn 160 65 ) 'black )] [( eq? body-part 'head ) ( and ( draw-solid-disk ( make-posn 120 50 ) 30 'red ) ( draw-solid-line ( make-posn 115 35 ) ( make-posn 123 43 ) 'black ) ( draw-solid-line ( make-posn 123 35 ) ( make-posn 115 43 ) 'black ) ( draw-solid-line ( make-posn 131 40 ) ( make-posn 139 48 ) 'black ) ( draw-solid-line ( make-posn 139 40 ) ( make-posn 131 48 ) 'black ))] [( eq? body-part 'noose ) ( and ( draw-solid-line ( make-posn 100 30 ) ( make-posn 100 10 ) 'black ) ( draw-solid-line ( make-posn 100 10 ) ( make-posn 0 10 ) 'black ))])) ;; 测试 ( start 200 200 ) ( draw-next-part 'noose ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( draw-next-part 'right-arm ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( draw-next-part 'right-arm ) ( draw-next-part 'left-arm ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( draw-next-part 'right-arm ) ( draw-next-part 'left-arm ) ( draw-next-part 'right-leg ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( draw-next-part 'right-arm ) ( draw-next-part 'left-arm ) ( draw-next-part 'right-leg ) ( draw-next-part 'left-leg ) 习题6.7.2 1 2 3 4 5 6 7 8 ( define-struct chars ( a b c )) ;; a, b, c 都是符号类型 ;; chars-template: a-chars -> ??? ( define ( chars-template a-chars ) ... ( chars-a a-chars ) ... ... ( chars-b a-chars ) ... ... ( chars-c a-chars ) ... ) 习题6.7.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; reveal: chars chars symbol -> chars ( define ( reveal chosen status char ) ( make-chars ( cond (( symbol=? ( chars-a chosen ) char ) char ) ( else ( chars-a status ))) ( cond (( symbol=? ( chars-b chosen ) char ) char ) ( else ( chars-b status ))) ( cond (( symbol=? ( chars-c chosen ) char ) char ) ( else ( chars-c status ))))) ;; 测试 ( reveal ( make-chars 't 'e 'a ) ( make-chars '_ 'e '_ ) 'u ) ( reveal ( make-chars 'a 'l 'e ) ( make-chars 'a '_ '_ ) 'e ) ( reveal ( make-chars 'a 'l 'l ) ( make-chars '_ '_ '_ ) 'l )","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-liu-zhang-fu-he-shu-ju-zhi-yi-jie-gou-ti.html","title":"HTDP第六章：复合数据之一：结构体"},{"text":"习题5.1.1 1 2 3 4 5 6 7 ;; replay: symbol -> symbol ;; 用布尔表达式来来表示问候与回答 ( define ( reply s ) ( or ( and ( symbol=? s 'GoodMorning ) 'Hi ) ( and ( symbol=? s 'HowAreYou? ) 'Fine ) ( and ( symbol=? s 'GoodAternoon ) 'INeedANap ) ( and ( symbol=? s 'GoodEvening ) 'BoyAmITired ))) 习题5.1.2 1 2 3 4 5 6 7 ;; check-guess: number number -> symbol ;; 比较猜测的数和目的数得出猜测数是猜大了、是猜小了还是猜对了 ( define ( check-guess guess target ) ( cond (( < guess target ) 'TooSmall ) (( > guess target ) 'TooLarge ) ( else 'Perfect ))) 习题5.1.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; check-guess3: number number number number -> symbol ;; 分别输入一个三位数的每位数，然后再进行猜大小 ( define ( check-guess3 n1 n2 n3 target ) ( let (( guess ( number3 n1 n2 n3 ))) ( cond (( < guess target ) 'TooSmall ) (( > guess target ) 'TooLarge ) ( else 'Perfect )))) ;; number3: number number number -> number ;; 根据一个三位数每位数，得出其数 ( define ( number3 n1 n2 n3 ) ( + n1 ( * 10 n2 ) ( * 100 n3 ))) 习题5.1.4 1 2 3 4 5 6 7 8 ;; what-kind: number number number -> symbol ;; 根据一个方程的三个系数得出该方程是否为退化方程，如果不是则该方程有几个解 ( define ( what-kind a b c ) ( cond (( eq? a 0 ) 'degenerate ) (( > ( * b b ) ( * 4 a c )) 'two ) (( < ( * b b ) ( * 4 a c )) 'one ) ( else 'none ))) 习题5.1.5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; check-color: symbol symbol symbol symbol -> symbol ;; 猜颜色游戏，模块第一个人的行为 ( define ( check-color t1 t2 g1 g2 ) ( cond (( and ( symbol=? t1 g1 ) ( symbol=? t2 g2 )) 'Perfect ) (( or ( symbol=? t1 g1 ) ( symbol=? t2 g2 )) 'OneColorAtCorrectPosition ) (( or ( symbol=? t1 g2 ) ( symbol=? t2 g1 )) 'OneColorOccurs ) ( else 'NothingCorrect )))","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-wu-zhang-fu-hao-xin-xi.html","title":"HTDP第五章：符号信息"},{"text":"布尔类型和关系 这一小段主要介绍了Scheme中有关布尔运算的知识， 为下面的段落打基础。 条件和条件函数 虽然书中给出了第二种语法，但是Racket以下两种都是支持的。 然后我又试了Scheme的另外一个方言Guile，也是两者都支持的。 这都属于语法而已，没必要在这里纠结，只要了解它支持即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 ( cond (( condition1 ) expresssion1 ) (( condition2 ) expresssion2 ) ... ( else else_expression ) ) ( cond [( condition1 ) expression1 ] [( condition2 ) expression2 ] ... [ else else_expression2 ] ) 条件函数的设计 习题4.4.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; interest: number -> number ;; 根据存款得出年存款收益（本金+利息） ( define ( interest amount ) ( + amount ( rate-amount amount ))) ;; rate-amount: number -> number ;; 根据存款得出其利息 ( define ( rate-amount amount ) ( * amount ( rate amount ))) ;; rate: number -> number ;; 根据存款额度得出其利率 ( define ( rate amount ) ( cond (( <= amount 1000 ) 0.040 ) (( <= amount 5000 ) 0.045 ) ( else 0.050 ))) 习题4.4.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; tax: number -> number ;; 根据毛收入得出其税款 ( define ( tax income ) ( * income ( rate-tax income ))) ;; rate-tax: number -> number ;; 根据毛收入的额度得出其税率 ( define ( rate-tax income ) ( cond (( <= income 240 ) 0.000 ) (( <= income 480 ) 0.150 ) ( else 0.280 ))) ;; 每小时12美元收入 ( define HOUR_INCOME 12 ) ( define ( netpay-someone work_hours ) ( netpay HOUR_INCOME work_hours )) ;; netpay: number number -> number ;; 根据每周工作的小时数和每小时的毛收入得出其每周的净收入（毛收入-税款） ( define ( netpay hour_income work_hours ) ( * ( net-income hour_income ) work_hours )) ;; net-incone: number -> number ;; 根据毛收入获取其净收入 ( define ( net-income income ) ( - income ( tax income ))) 习题4.4.3 这一题目有好几种解法。 我这里写出两种，其中一种就是将每种条件都写出来。 但是有一个问题就是后期如果有更多的奖励级别， 越后面的级别，要累加的函数就越多。 有没有方法避免呢？ 递归。第二种解法就是用的递归。 至于其它解法，也是在这两种解法的基础上演化而来。 比如加入缓存机制，使用连续等等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ;; 0等级奖赏标准 ( define LEVEL0_CONSUMPTION_STD 500 ) ;; 1等级奖赏标准 ( define LEVEL1_CONSUMPTION_STD 1500 ) ;; 2等级奖赏标准 ( define LEVEL2_CONSUMPTION_STD 2500 ) ;; pay-back: number -> number ;; 根据一年的消费额来得出其奖励金额 ( define ( pay-back year_consumption ) ( cond (( <= year_consumption LEVEL0_CONSUMPTION_STD ) ( level0 year_consumption )) (( <= year_consumption LEVEL1_CONSUMPTION_STD ) ( + ( level0 LEVEL0_CONSUMPTION_STD ) ( level1 ( - year_consumption LEVEL0_CONSUMPTION_STD )))) (( <= year_consumption LEVEL2_CONSUMPTION_STD ) ( + ( level0 LEVEL0_CONSUMPTION_STD ) ( level1 ( - LEVEL1_CONSUMPTION_STD LEVEL0_CONSUMPTION_STD )) ( level2 ( - year_consumption LEVEL1_CONSUMPTION_STD )))) ( else ( + ( level0 LEVEL0_CONSUMPTION_STD ) ( level1 ( - LEVEL1_CONSUMPTION_STD LEVEL0_CONSUMPTION_STD )) ( level2 ( - LEVEL2_CONSUMPTION_STD LEVEL1_CONSUMPTION_STD )) ( level3 ( - year_consumption LEVEL2_CONSUMPTION_STD )))))) ;; level0: number -> number ;; 0等级奖赏额度 ( define ( level0 consumption ) ( level ( * 0.25 ( / 1 100 )) consumption )) ;; level1: number -> number ;; 1等级奖赏额度 ( define ( level1 consumption ) ( level ( * 0.50 ( / 1 100 )) consumption )) ;; level2: number -> number ;; 2等级奖赏额度 ( define ( level2 consumption ) ( level ( * 0.75 ( / 1 100 )) consumption )) ;; level3: number -> number ;; 3等级奖赏额度 ( define ( level3 consumption ) ( level ( * 1.0 ( / 1 100 )) consumption )) ;; level: number -> number ;; 根据等级奖赏比例来得出其奖赏额度 ( define ( level rate consumption ) ( * rate consumption )) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ;; 0等级奖赏标准 ( define LEVEL0_CONSUMPTION_STD 500 ) ;; 1等级奖赏标准 ( define LEVEL1_CONSUMPTION_STD 1500 ) ;; 2等级奖赏标准 ( define LEVEL2_CONSUMPTION_STD 2500 ) ;; pay-back: number -> number ;; 根据一年的消费额来得出其奖励金额 ( define ( pay-back year_consumption ) ( cond (( > year_consumption LEVEL2_CONSUMPTION_STD ) ( + ( level3 ( - year_consumption LEVEL2_CONSUMPTION_STD )) ( pay-back LEVEL2_CONSUMPTION_STD ))) (( > year_consumption LEVEL1_CONSUMPTION_STD ) ( + ( level2 ( - year_consumption LEVEL1_CONSUMPTION_STD )) ( pay-back LEVEL1_CONSUMPTION_STD ))) (( > year_consumption LEVEL0_CONSUMPTION_STD ) ( + ( level1 ( - year_consumption LEVEL0_CONSUMPTION_STD )) ( pay-back LEVE0_CONSUMPTION_STD ))) ( else ( level0 year_consumption )))) ;; level0: number -> number ;; 0等级奖赏额度 ( define ( level0 consumption ) ( level ( * 0.25 ( / 1 100 )) consumption )) ;; level1: number -> number ;; 1等级奖赏额度 ( define ( level1 consumption ) ( level ( * 0.50 ( / 1 100 )) consumption )) ;; level2: number -> number ;; 2等级奖赏额度 ( define ( level2 consumption ) ( level ( * 0.75 ( / 1 100 )) consumption )) ;; level3: number -> number ;; 3等级奖赏额度 ( define ( level3 consumption ) ( level ( * 1.0 ( / 1 100 )) consumption )) ;; level: number -> number ;; 根据等级奖赏比例来得出其奖赏额度 ( define ( level rate consumption ) ( * rate consumption )) 习题4.4.4 1 2 3 4 5 6 7 ;; how-many: number number number -> number ;; 根据方程ax&#94;2 + bx + c = 0, 得出该方程解的个数 ( define ( how-many a b c ) ( cond (( > ( * b b ) ( * 4 a c )) 2 ) (( < ( * b b ) ( * 4 a c )) 0 ) ( else 1 )))","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-si-zhang-tiao-jian-biao-da-shi-he-han-shu.html","title":"HTDP第四章：条件表达式和函数"},{"text":"函数复合 电影院定制电影票价格的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ;; profit: number -> number ;; 利润 ( define ( profit ticket-price ) ( - ( revenue ticket-price ) ( cost ticket-price ))) ;; revenue: number -> number ;; 收入 ( define ( revenue ticket-price ) ( * ( attendees ticket-price ) ticket-price )) ;; cost: number -> number ;; 支出 ( define ( cost ticket-price ) ( + 180 ( * 0.04 ( attendees ticket-price )))) ;; attendees: number -> number ;; 观众数 ( define ( attendees ticket-price ) ( + 120 ( * 10 ( - 5.0 ticket-price ) 15 ))) 上面是使用辅助函数实现的代码。由该问题引出一条程序设计原则： 辅助函数原则 对在表述中所提到的或在进行实例计算中所发现的每种依赖关系 都使用一个辅助函数进行明确表达。 习题3.14，这一题能够很明显看到使用辅助函数的好处， 虽然需求改变，但是只需要改变cost函数的具体算法即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; profit: number -> number ;; 利润 ( define ( profit ticket-price ) ( - ( revenue ticket-price ) ( cost ticket-price ))) ;; revenue: number -> number ;; 收入 ( define ( revenue ticket-price ) ( * ( attendees ticket-price ) ticket-price )) ;; cost: number -> number ;; 支出 ( define ( cost ticket-price ) ( * ( + 0.04 1.5 ) ( attendees ticket-price ))) ;; attendees: number -> number ;; 观众数 ( define ( attendees ticket-price ) ( + 120 ( * 10 ( - 5.0 ticket-price ) 15 ))) 变量定义 变量定义原则 给频繁使用的常量定义一个名字，并在程序中使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ( define FILM_COST 180 ) ( define ATTENDEES_COST 0.04 ) ( define ATTENDEES_AT_MAX_TICKET_PRICE 120 ) ( define MAX_TICKET_PRICE 5.0 ) ( define PER_ADD_ATTENDEES_NUM 15 ) ( define PER_SUB_TICKET_PRICE 0.1 ) ;; profit: number -> number ;; 利润 ( define ( profit ticket-price ) ( - ( revenue ticket-price ) ( cost ticket-price ))) ;; revenue: number -> number ;; 收入 ( define ( revenue ticket-price ) ( * ( attendees ticket-price ) ticket-price )) ;; cost: number -> number ;; 支出 ( define ( cost ticket-price ) ( + FILM_COST ( * ATTENDEES_COST ( attendees ticket-price )))) ;; attendees: number -> number ;; 观众数 ( define ( attendees ticket-price ) ( + ATTENDEES_AT_MAX_TICKET_PRICE ( * ( / PER_ADD_ATTENDEES_NUM PER_SUB_TICKET_PRICE ) ( - MAX_TICKET_PRICE ticket-price )))) 函数复合练习 习题3.3.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ;; british->metric: number -> number ;; 英制转换成公制 ( define ( british->metric reduced_unit num ) ( * reduced_unit num )) ( define INCHES->CM_UNIT 2.54 ) ;; inches->cm: number -> number ( define ( inches->cm num ) ( british->metric INCHES->CM_UNIT num )) ( define FEET->INCHES_UNIT 12 ) ;; feet->inches: number -> number ( define ( feet->inches num ) ( british->metric FEET->INCHES_UNIT num )) ( define YARDS->FEET_UNIT 3 ) ;; yards->feet: number -> number ( define ( yards->feet num ) ( british->metric YARDS->FEET_UNIT num )) ( define RODS->YARDS_UNIT ( / 1 2 ) 5 ) ;; rods->yards: number -> number ( define ( rods->yards num ) ( british->metric RODS->YARDS_UNIT num )) ( define FURLONGS->RODS_UNIT 40 ) ;; furlongs->rods: number -> number ( define ( furlongs->rods num ) ( british->metric FURLONGS->RODS_UNIT num )) ( define MILES->FURLONGS_UNIT 8 ) ;; miles->furlongs: number -> number ( define ( miles->furlongs num ) ( british->metric MILES->FURLONGS_UNIT num )) ;; feet->cm: number -> number ( define ( feet->cm num ) ( inches->cm ( feet->inches num ))) ;; yards->cm: number -> number ( define ( yards->cm num ) ( inches->cm ( feet->inches ( yards->feet num )))) ;; yards->cm: number -> number ( define ( rods->inches num ) ( feet->inches ( yards->feet ( rods->yards num )))) ;; yards->cm: number -> number ( define ( miles->feet num ) ( yards->feet ( rods->yards ( furlongs->rods ( miles->furlongs num ))))) 习题3.3.2 1 2 3 4 5 6 ( define PI 3.14 ) ;; volume-cylinder: number -> number ;; 求圆柱体体积 ( define ( volume-cylinder radius height ) ( * PI ( * radius radius ) height )) 习题3.3.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define PI 3.14 ) ;; circumference-bottem: number -> number ;; 底部的周长 ( define ( circumference-bottem radius ) ( * 2 PI radius )) ;; area-bottem: number -> number ;; 底部面积 ( define ( area-bottem radius ) ( * PI ( * radius radius ))) ;; area-flank: number number -> number ;; 侧面积 ( define ( area-flank radius height ) ( * height ( circumference-bottem radius ))) ;; area-cylinder: number number -> number ;; 求圆柱体的表面积 ( define ( area-cylinder radius height ) ( + ( area-flank radius height ) ( * 2 ( area-bottem radius )))) 习题3.3.4 单一函数版本 Pass 辅助函数版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ( define PI 3.14 ) ;; area-pipe: number number number -> number ;; 管道（中空的圆柱体）的表面积 ( define ( area-pipe inner_radius length thickness ) ( let (( outer_radius ( outer-radius inner_radius thickness ))) ( + ( outer-area-flank length outer_radius ) ( inner-area-flank length inner_radius ) ( * 2 ( area-ring outer_radius inner_radius ))))) ;; outer-area-flank: number number -> number ;; 外部的侧面积 ( define ( outer-area-flank length outer_radius ) ( area-flank outer_radius length )) ;; inner-area-flank: number number -> number ;; 内部的侧面积 ( define ( inner-area-flank length inner_radius ) ( area-flank inner_radius length )) ;; area-ring: number number -> number ;; 空心圆的面积 ( define ( area-ring outer_radius inner_radius ) ( - ( area-cycle outer_radius ) ( area-cycle inner_radius ))) ;; outer-radius: number number -> number ;; 外半径 ( define ( outer-radius inner_radius thickness ) ( + inner_radius thickness )) ;; area-flank: number number -> number ;; 侧面积 ( define ( area-flank radius height ) ( * height ( circumference-cycle radius ))) ;; area-cycle: number -> number ;; 圆面积 ( define ( area-cycle radius ) ( * PI ( * radius radius ))) ;; circumference-cycle: number -> number ;; 圆周长 ( define ( circumference-cycle radius ) ( * 2 PI radius )) 习题3.3.5 1 2 3 4 5 6 7 8 9 10 11 ( define G 9.8 ) ;; 重力加速度 ;; height: number -> number ;; 计算火箭升空后在给定时刻所到达的高度 ( define ( height sec ) ( * ( / 1 2 ) ( speed sec ) sec )) ;; speed: number -> number ;; 计算火箭升空后在给定时刻所到达的速度 ( define ( speed sec ) ( * G sec )) 习题3.3.6 Pass","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-san-zhang-cheng-xu-jiu-shi-han-shu-jia-shang-bian-liang-ding-yi.html","title":"HTDP第三章：程序就是函数加上变量定义"},{"text":"这一章开始4小段简单介绍了一下Racket/Scheme语法。 Racket/Scheme的语法相当简单，所以廖廖几页就说完了。 相关的习题也是讲解： 各种不符合Racket/Scheme语法情况下的代码的运行出错提示是什么。 2.5段则给出了一个 设计诀窍 表格。 其实就是设计一个函数的具体步骤有哪些。 程序设计原则 这里我也具体列出下面每章都会提及的程序设计原则。 辅助函数原则 对在表述中所提到的或在进行实例计算中所发现的每种依赖关系 都使用一个辅助函数进行明确表达。 变量定义原则 给频繁使用的常量定义一个名字，并在程序中使用。 表达式计算原则 简化最外（最左的）可以计算的表达式。","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-er-zhang-shu-biao-da-shi-he-jian-dan-cheng-xu.html","title":"HTDP第二章：数、表达式和简单程序"},{"text":"第一章对程序设计这个概念作了一个简单介绍。 本书主要使用的是Scheme语言的一种方言，叫做Racket。 我在这里简单说介绍一下 HTDP 用到的教学软件包。 从 Racket官方网站 下载最新版本的Racket软件。 运行命令 drracket 。 在 语言 中 选择语言... 选择 教学语言(ctl-T) 。 级别随便选择，我一开始做习题就是选择 初级 。 然后根据课后习题的要求，在 语言 中选择 加载教学包... 。","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-yi-zhang-xue-sheng-lao-shi-he-ji-suan-ji.html","title":"HTDP第一章：学生、老师和计算机"},{"text":"Contents HTTP的连接过程 HTTP和HTTPS网络协议栈区别 HTTP的连接过程 HTTP连接本质上就是TCP连接和一些使用连接的规则。 HTTP和HTTPS网络协议栈区别 HTTPS连接其中就是在HTTP和TCP层之间插入一个TSL/SSL层。 HTTP要传送一条报文时， 会以流的形式将报文数据通过一条打开的TCP连接按序传输。 TCP收到数据流后，会将数据流分成多个小段， 并将该段封装在IP分组中。 每个IP分组包括： 一个IP分组首部（通常为20个字节） 一个TCP段首部（通常为20个字节） 一个TCP数据块（0个或者多个字节）","tags":"http","loc":"http://chenjiee815.github.io/httpquan-wei-zhi-nan-bi-ji-di-si-zhang-lian-jie-guan-li.html","title":"《HTTP权威指南》笔记 第四章 连接管理"},{"text":"Contents 起始行 请求行 响应行 状态码 首部 主体 起始行 所有的HTTP报文都以一个起始行作为开始。 请求报文的起始行（请求行）说明： 要做些什么 。 响应报文的起始行（响应行）说明： 发生了什么 。 请求行 包含一个方法和一个请求URL。 这个方法描述了服务器应该执行的操作， 请求URL描述了要对哪个资源执行这个方法。 此外，它还包含了客户端使用HTTP版本。 响应行 包含服务器使用HTTP版本、数字状态码及其对应的原因短语。 所有这些字段通过空格来进行分隔。 状态码 状态码表示为三位数字。 200~299之间的状态码表示成功。 300~399之间的状态码表示资源已经被移走。 400~499之间的状态码表示客户端请求出错。 500~599之间的状态码表示服务器响应出错。 首部 本质上是一些KeyValue对的列表。 将长的首部行分为多行可以提高可读性， 多出来的每行前面至少要有一个空格或者制表符。 主体 主体是HTTP要传输的具体内容。","tags":"http","loc":"http://chenjiee815.github.io/httpquan-wei-zhi-nan-bi-ji-di-san-zhang-httpbao-wen.html","title":"《HTTP权威指南》笔记 第三章 HTTP报文"},{"text":"Contents URL语法 相对URL 转义字符 保留字符 URL语法 大多数URL的格式： <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag> 其中最重要的是scheme, host, path。 相对URL 有时候网页里面的URL不是绝对路径的， 那么就会有相应的算法将之转换成绝对URL。 转义字符 为了在URL中表示各种不安全的字符， 需要在URL用转义字符来表示这些不安全的字符。 这种转义表示法包含一个百分号，后面跟着两个表示字符ASCII码的16进制数。 一些编码字符举例 字符 ASCII码 示例URL ~ 126(0x7E) http://www.joes-hardware.com/%7Ejoe 空格 32(0x20) http://www.joes-hardware.com/more%20tools.html 保留字符 在URL中，有几个字符被保留起来，有特殊的用途。","tags":"http","loc":"http://chenjiee815.github.io/httpquan-wei-zhi-nan-bi-ji-di-er-zhang-urlyu-zi-yuan.html","title":"《HTTP权威指南》笔记 第二章 URL与资源"},{"text":"这一章主要介绍了HTTP协议的一些基本概念， 这样大家会对HTTP有一个基本的了解。 Contents Web客户端和服务器 Web资源 媒体类型 URI URL URN 事务 方法 状态码 报文 连接 Web的结构组件 代理 缓存 网关 隧道 Agent代理 Web客户端和服务器 Web资源 资源既可以是静态文件，也可以是根据需求动态生成的。 媒体类型 资源多了，就要分类。HTTP采用了MIME类型。 MIME类型原来是在邮件里面使用的，由于它很成熟也很好用， 所以HTTP也采用了。 Web服务器会为所有的HTTP对象数据附加一个MIME类型。 当浏览器从服务器中取回一个对象时，会去查看相关的MIME类型， 这样它就知道如何处理这个对象了。 常用MIME类型举例： HTML格式的文本文档：text/tml 普通的ASCII文本文档：text/plain JPEG格式的图片：image/jpeg URI Uniform Resource Idenifier: 统一资源标识符 URI有两种形式：URL和URN。 URL 统一资源定位符，它描述了一台特定服务器上某资源的特定位置。 大部分URL都遵循一种标准格式： 第一部分：方案(scheme)，说明了使用的协议类型。 第二部分：服务器地址。 其余部分：服务器上的某个资源。 URN 统一资源名，作为特定内容的唯一名称使用，与资源的所在地无关。 现实中用的很少，还处于试验阶段。 事务 一个HTTP事务由一条（客户端发给服务器）的请求消息和 一个（从服务器发回客户端）的响应消息组成。 这种通信是通过名为HTTP报文（HTTP message）的格式化数据块进行的。 方法 每条HTTP请求报文都包含一个方法，这些叫做HTTP方法（HTTP method）。 这些方法会告诉服务器要执行什么动作。 常见的HTTP方法 方法名 说明 GET 获取资源 PUT 更新资源 DELETE 删除资源 POST 添加资源 HEAD 获取HTTP响应首部 状态码 每条HTTP响应报文返回时都会携带一个状态码。 状态码是一个三位数字，用来告知客户端请求是否成功， 或者是否需要采取其它动作。 HTTP的响应报文中除了会返回状态码之外，还会同时返回对应的原因短语。 常见HTTP状态码： 200 OK：文档正常返回 302 Redirect：重定向，到其它地方获取资源 404 Not Found：没找到，无法找到该资源 报文 HTTP报文是由一行行的简单字符串组成的。HTTP报文都是纯文本，非二进制代码。 HTTP报文分为： 请求报文（request message） 响应报文（response message） HTTP报文包括以下三个部分： 起始行 报文的第一行就是起始行， 在请求报文里说明要做些什么， 在响应报文中说明出现了什么情况。 首部字段 起始行后面有零个或多个首部字段。 每个字段都包含一个名字和一个值。两者用：号分割。 首部以一个空行结束。 主体 空行之后就是可选的报文主体了。其中包含了所有类型的数据。 请求报文主体中包含了要发给服务器的数据；响应报文主体中包含了 要返回客户端的数据。主体中可以包含任意的二进制数据。 连接 HTTP是个应用层协议，它将联网的具体细节交给了TCP/IP协议。 所以在HTTP客户端向服务器发送报文之前，需要用IP地址及端口号在 客户端与服务器之间建立一条TCP/IP连接。 之前有讲过，客户端是通过URL来请求资源的。 所以IP地址及端口也是从URL中获取到的。 下面简单介绍一下浏览器的连接步骤： 浏览器从URL中解析出服务器的主机名/域名 浏览器将主机名/域名通过DNS服务转换成服务器的IP地址 浏览器将端口号从URL中解析出来（没有则用默认的端口号） 浏览器建立一条与服务器的TCP连接 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器回送一条HTTP响应报文 浏览器关闭连接，渲染并显示文档 Web的结构组件 代理 位于客户端和服务器之间。 一般的应用场景是，客户端无法访问某些服务器，但是可以连接到某台设备， 而这台设备可以访问这些服务器，那么就可以在这个设备上开启一个代理服务器， 客户端通过走这台设备的代理就可以访问那些它之前无法访问的服务器了。 缓存 它是一种特殊的代理服务器，可以将经过代理传送的常用文档保存下来， 当有其它客户端或者该客户端再次请求相同文档时， 就可以直接将缓存的文档返回了。 网关 也是一种特殊的代理服务器中，通常是将HTTP请求转换成其它协议的请求。 隧道 对HTTP通信报文进行盲转发的特殊代理。 在一条或者多条HTTP连接上转发非HTTP数据，转发时不会窥探数据。 常用的就是HTTPS，通过HTTP连接承载加密安全套接字层（SSL）。 Agent代理 是指代表客户发起HTTP请求的客户端程序。 最有代表性的就是：浏览器。","tags":"http","loc":"http://chenjiee815.github.io/httpquan-wei-zhi-nan-bi-ji-di-yi-zhang-httpgai-shu.html","title":"《HTTP权威指南》笔记 第一章 HTTP概述"},{"text":"setuptools官方文档 以下内容是根据官方文档做的笔记。 Contents 推荐用法 基本用法 版本号格式 可选的setup()函数参数 使用 find_packages() 脚本的自动生成 Eggsecutable 脚本 依赖的声明 数据文件的安装 依赖包的声明 easy_install pkg_resources 命名空间包 工作集对象 推荐用法 在项目根目录添加 ez_setup.py 文件， 然后在setup.py文件的开头添加如下代码： 1 2 from ez_setup import use_setuptools use_setuptools () 这样写的话，其他人安装你的Python包时， 如果没有安装setuptools工具，该脚本就会自动下载并安装setuptools。 当然也可以通过这个脚本来直接安装、更新setuptools： 1 $ sudo python ez_setup.py -U setuptools 基本用法 下面是一个最基本的setup.py。 1 2 3 4 5 6 from setuptools import setup , find_packages setup ( name = \"HelloWorld\" , version = \"0.1\" , packages = find_packages (), ) 就是这里的几行代码，就可以自动查找需要打包的文件， 将当前的项目打包成eggs，支持上传到 PyPI 。 当然如果需要上传到 PyPI ，最好再添加一些额外信息。 版本号格式 setuptools能够支持大部分的版本号格式。 如果您不是很确定您定义的版本号是否被setuptools支持， 您可以使用pkg_resources.parse_version()来判断。 1 2 3 4 5 6 7 >>> from pkg_resources import parse_version >>> parse_version ( '1.9.a.dev' ) == parse_version ( '1.9a0dev' ) True >>> parse_version ( '2.1-rc2' ) < parse_version ( '2.1' ) True >>> parse_version ( '0.6a9dev-r41475' ) < parse_version ( '0.6a9' ) True 可选的setup()函数参数 include_package_data 如果设置为True，setuptools就会在项目目录里自动查找所有的数据文件 这些数据文件包括被CVS/SVN进行版本管理的， 或者你在MANIFEST.in中指定的文件。 详见 数据文件的安装 。 exclude_package_data 它的值为一个字典。 打包时排除某些文件/目录， 即使该文件/目录在 include_package_data 指定的范围内。 详见 数据文件的安装 。 package_data 它的值也为一个字典。 如果 include_package_data 值为True，那么这个参数就没必要再用。 它提供了更细粒度的控制哪些文件该被打包。 详见 数据文件的安装 。 zip_safe 它的值为True/False。它用来指定打出来的ZIP包是否能够安全的被安装， 或者直接运行。 如果你不提供该值， bdist_egg 子命令每次打包时都需要做检查。 zip包形式能够占用更少的磁盘空间，且加载速度更快（ 就一个文件，虽然要解压，但是CPU速度远快于磁盘速度）。 install_requires 该值为一个列表，其中每个值表示该包所依赖的包的名称。 当你在安装该包时，setuptools会自动安装它所依赖的那些包。 详见 依赖包的声明 。 entry_points 该值为一个字典。是用来动态地发现该包所提供的服务或者插件。 详见 `服务和插件的动态发现`_ 。 额外插一句，该值也可以用来 脚本的自动生成 。 extras_require 该值为一个字典。用来指定你的包所提供的额外功能所需要用来的依赖包。 详见 依赖的声明 。 setup_requires 该值为一个字符串列表。 当你在执行setup.py时需要安装哪些额外的包，你可以在该值里面指定。 Note 这些包默认只会下载下来，并不会进行安装。 如果需要安装请配合使用 install_requires 和 setup_requires dependency_links 该值为一个字符串列表。 用来查找依赖包的URLs。 namespace_packages 该值为一个字符串列表。 命名空间包是一个包含多个其它包的虚拟包。 详见 命名空间包 。 test_suite 该值为一个字符串。 用来指定测试该包用的一个测试套件。比如 nosetest 。 指定之后，就可以通过 python setup.py test 来进行测试。 详见 `test命令`_ 。 tests_require 该值为一个字符串或者一个字符串列表。 如果测试该包需要安装一些额外的包，请在该值内指定。 Note 这些额外的包并不会安装到系统里，默认只会下载下来。 test_loader 如果你不想用setuptools的默认查找测试用例的规则，而是想自己自定义， 那么，这个参数正合你意。 eager_resources 该值为一个字符串列表。 详见 `资源的自动扩展`_ 。 use_2to3 在编译过程中使用 2to3 脚本来将Python2的代码转换成Python3的代码。 convert_2to3_doctests 该值为一个字符串列表。 用来指定哪些 doctest 源代码需要使用 2to3 脚本进行转换的。 use_2to3_fixers 该值为一个字符串列表。 在 2to3 的转换过程中还哪些额外的fixers。 使用 find_packages() 针对简单的项目，你可以直接手工在 packages 参数里指定需要打包的文件。 但是针对非常大型的项目（Twisted, PEAK, Zope, Chandler, etc.）， find_packages() 是派得上用场了。 find_packages() 有三个参数： where, 指定源目录，默认为 setup.py 脚本所在的目录。 exclude, 类似于 exclude_package_data include, 类似于 include_package_data 脚本的自动生成 打包和安装脚本对于 distutils 模块来说有点棘手。 没有一个比较容易的指定符合各个平台（Windows、Linux，etc）约定的脚本名称。 你需要专门为 main 函数创建一个脚本。 setuptools 就解决如上的所有问题。它可以自动创建脚本。 在Windows平台甚至直接生成exe文件。 当然，想要 setuptools 自动完成这一切， 你需要在 entry_points 参数说明。 1 2 3 4 5 6 7 8 9 10 11 12 setup ( # other arguments here... entry_points = { 'console_scripts' : [ 'foo = my_package.some_module:main_func' , 'bar = other_module:some_func' , ], 'gui_scripts' : [ 'baz = my_package_gui.start_func' , ] } ) Eggsecutable 脚本 某些情况，你可能需要让一个egg格式的Python包能够直接被执行。 那么，你只需要像下面一样做就可以了： 1 2 3 4 5 6 7 8 setup ( # other arguments here... entry_points = { 'setuptools.installation' : [ 'eggsecutable = my_package.some_module:main_func' , ] } ) Note eggsecutable 的egg包不能被重命名或者通过连接来执行。 依赖的声明 数据文件的安装 setuptools提供三种方式来定制包内的数据文件。 你需要将打开 include_package_data 参数。 1 2 3 4 5 from setuptools import setup , find_packages setup ( ... include_package_data = True ) 这个参数会告诉setuptools自动查找包内包含的数据文件， 但是自动查找是有要求的。 这些数据文件必须是在CVS/SVN这些版本管理工具的仓库里面受版本控制的 （当然你也可以写setuptools扩展来支持其它的版本管理工具）， 或者在 MANIFEST.in 文件中被指定的。 如果你想有比较细粒度地控制setuptools打包哪些数据文件， 那么你可以使用 package_data 参数。 1 2 3 4 5 6 7 8 9 10 from setuptools import setup , find_packages setup ( ... package_data = { # If any package contains *.txt or *.rst files, include them: '' : [ '*.txt' , '*.rst' ], # And include any *.msg files found in the 'hello' package, too: 'hello' : [ '*.msg' ], } ) package_data 参数是一个字典，它的Key值是包内目录的名称， Value值是一个包含通配符字符串的列表。 比如一个包的内部目录结构 setup.py src/ mypkg/ __init__.py mypkg.txt data/ somefile.dat otherdata.dat 那么它对应的 package_data 参数就是： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from setuptools import setup , find_packages setup ( ... packages = find_packages ( 'src' ), # include all packages under src package_dir = { '' : 'src' }, # tell distutils packages are under src package_data = { # If any package contains *.txt files, include them: '' : [ '*.txt' ], # And include any *.dat files found in the 'data' subdirectory # of the 'mypkg' package, also: 'mypkg' : [ 'data/*.dat' ], } ) 注意：上面两个示例中 package_data 的一个Key值是一个空字符串， 这个就代表会在所有的目录里查找对应的数据文件。 注意：如果你使用到了路径，请使用 / 来指定路径分隔， 即使在Windows平台也是这样，setuptools会根据当前的打包平台自动识别。 注意：在Python2.4之后的distutils模块也添加对该参数的支持。 如果你指定了 include_package_data 参数，那么 package_data 将无效。 但是还有些情况，以上两个参数还是满足不了。 比如你想在你发布的Python包内包含README文件， 但是安装的时候又不希望安装它。 这时候，你就需要 exclude_package_data 参数来帮忙了。 1 2 3 4 5 6 7 8 9 10 11 from setuptools import setup , find_packages setup ( ... packages = find_packages ( 'src' ), # include all packages under src package_dir = { '' : 'src' }, # tell distutils packages are under src include_package_data = True , # include everything in source control # ...but exclude README.txt from all packages exclude_package_data = { '' : [ 'README.txt' ] }, ) exclude_package_data 参数和 package_data 是一样的， 也是字典，在该字典里匹配到的所有文件都不会被安装。 即使这个文件符合 include_package_data 或者 package_data 参数 的要求。 注意： disutils模块的打包流程会导致一种现象， 你之前的包有包含过某些数据文件，但之后你又删除了该数据文件。 那么这些数据文件在你的打包目录便会变成孤儿，你最好运行命令 python setup.py clean --all 来完全删除它们。 你的这个包的使用者或者其它代码贡献者通过版本管理工具追踪版本时， 他们就会知道是你做了某些改变，然后需要删除这此文件的， 那么他们也就能够放心大胆运行 python setup.py clean --all 命令了。 依赖包的声明 easy_install pkg_resources 该模块的全称为： Package Discovery and Resource Access 这个模块主要有以下几个功能： 提供API给Python库来让它们能够访问它们自己的资源文件 能让扩展的应用和框架自动发现插件 给zip格式的eggs包内的C扩展提示运行时支持 能够合并各种独立分发的Python模块，就是下文的命名空间包 提供API来管理当前\"工作集\"中的Python包 命名空间包 命名空间包本质算是一个虚拟包， 这个包主要将多个独立分发的包集合成一个，方便安装。 比如： peak 是一个命名空间包，它包含了一系列不同用途的子包。 那么如何创建一个命名空间包呢？ 在 setup() 函数中添加 namespace_package 参数。 该参数为一个列表，然后将需要集合的包的名称写进去。 你也必须在命名空间包的 __init__.py 文件中添加 __declare_namespace() 函数的调用。 工作集对象 Docutils System Messages System Message: ERROR/3 ( /media/cj/self/git/chenjiee815_blogs/chenjiee815_blogs/content/python/tools/setuptools_guide.rst , line 120); backlink Unknown target name: \"服务和插件的动态发现\". System Message: ERROR/3 ( /media/cj/self/git/chenjiee815_blogs/chenjiee815_blogs/content/python/tools/setuptools_guide.rst , line 158); backlink Unknown target name: \"test命令\". System Message: ERROR/3 ( /media/cj/self/git/chenjiee815_blogs/chenjiee815_blogs/content/python/tools/setuptools_guide.rst , line 180); backlink Unknown target name: \"资源的自动扩展\".","tags":"python","loc":"http://chenjiee815.github.io/setuptoolszhi-nan-wei-wan-dai-xu.html","title":"setuptools指南：未完待续"},{"text":"背景 应该是前三周的DNA会议，我做了第一次P3的演讲。 很遗憾，那次的演讲由于超时没有通过。 这事虽然对我打击不是很大，但是却让我反思了一下自己的演讲水平。 有多烂？事实在这里 我发现自己从P1到P3的整个演讲历程走得磕磕跘跘： P1做了三次，其中有一次说到一半忘词说不下去了。 P2做了两次，第一次超时了，第二次也是勉强过了。 P3正如大家所见，我正在做第二次的P3演讲。 为什么会这么烂？原因何在？ 认为演讲水平不好，只是上台的经历比较少，经历多了，自然会讲得比较好。 认为演讲时紧张，还是上台的经历比较少，经历多了，脸皮就厚了。 没有做好提前准备，既然是备稿演讲，你的稿子在哪？每次只是打个提纲。 每次演讲完成，没有回顾自己在演讲时被拍摄的视频，找出缺点并改正。 在演讲时，一遇到需要表演的地方，就觉得很假，就会把一个很有感觉的事说得平淡无奇。 如何解决这些问题？ 难道自己就没有优点？ 结尾","tags":"dna","loc":"http://chenjiee815.github.io/wo-de-yan-jiang-shui-ping-wei-shi-yao-zhe-yao-lan.html","title":"我的演讲水平为什么这么烂？"},{"text":"Contents Flask扩展导入方式 Flask的扩展包都列在了 Flask扩展注册 中。 这些包本质都属于Python库， 所以你都可以通过 easy_install 或者 pip 来进行安装。 Flask扩展导入方式 Flask扩展的导入方式在Flask 0.8版本前后还是有点区别的。 如果你使用的是Flask 0.8或者其更新的版本，你可以通过： 1 from flast.ext import ext_name 的方式来导入扩展包。 如果你使用的是比Flask 0.8旧的版本， 你只能通过直接导入扩展包的名称来导入了。 但是Flask官方还是提供了一个兼容模块用来兼容老版本的Flask。 你可以从这里下载： flaskext_compat.py 使用方法: 1 2 3 4 import flaskext_compat flaskext_compat . activate () from flast.ext import ext_name","tags":"python","loc":"http://chenjiee815.github.io/flaskkuo-zhan-ji-zhi-wei-wan-dai-xu.html","title":"Flask扩展机制（未完待续）"},{"text":"Contents 总纲 scheme十戒 scheme五律 第一章: Toys 基本概念 其它概念 第二章: Do It, Do It Again, and Again, and Again… lat操作 基本概念 应用 第三章: Cons the Magnificent lat操作 应用 第四章: Numbers Games 数字操作 基本概念 应用 综合操作 第五章: *Oh My Gawd*: It's Full of Stars 第六章: Shadows 应用 第七章: Friends and Relations set操作 基本概念 应用 pair操作 基本概念 应用 rel操作 基本概念 fun操作 基本概念 应用 fullfun操作 基本概念 应用 第八章: Lambda the Ultimate 第九章: … and Again, and Again, and Again, … 第十章: What Is the Value of All of This? 总纲 scheme十戒 当对一个原子列表进行递归时，要注意两个问题：(null? lat) and else。 当对一个数字进行递归时，要注意两个问题：(zero? n) and else。 当对一个S表达式列表进行递归时，要注意三个问题：(null? l), (atom? (car l)) 和 else。 使用cons来创建列表。 当创建一个列表时，先描述第一个元素，然后用cons来将它和递归连接在一起 递归时，至少要改变一个参数。 例如：递归一个原子列表使用(cdr lat)；递归一个数字使用(sub1 n)； 递归一个S表达式时，如果这个表达式即不(null? l)，也不(atom? (car l))， 那么使用(car l) 和 (cdr l)。 并且该参数必须要越来越接近终止元素。在终止条件里面必须要对正在变化的参数进行检查： 当使用cdr时，终止条件使用null? 当使用sub1时，终止条件使用zero? 当你使用+来创建一个值时，必须总要用0来作为终止，0加上任何值都不会改变原来的值。 当你使用*来创建一个值时，必须总要用1来作为终止，1乘以任务值都不会改变原来的值。 当你使用cons来创建一个值时，必须总要用()来作为终止。 当函数运行正确后再考虑简化函数。 当一个对象的子对象是与其本身表现一致时，这时候可用递归操作。比如： 一个列表的子列表 一个算术表达式的子表达式 使用help函数来简化表述。 使用新的函数来抽象公共模式。 创建函数时，尽量能够一次性获取更多的值。 scheme五律 car函数最初只是用在非空列表上的。 cdr函数最初只是用在非空列表上的，(cdr non-null-list)的结果是另一个列表。 cons函数最初只接受两个参数，第二个参数必须是一个列表，它返回的结果也是一个列表。 null?函数只对列表有用。 eq?函数只接受两个参数，两个参数必须都是非数字的原子。 第一章: Toys 作者目的：使读者了解scheme一些基本概念和一些常用函数，为接下来的章节打基础。 基本概念 S表达式: scheme中所以元素都可以叫做S表达式。 atom: 原子，是指一个非列表的S表达式。 list: 列表，用()包围起来的S表达式。 car: 返回非空列表中的首个S表达式， 所以它操作的对象一定要是非空的列表(十戒第一条)。 cdr: 取出非空列表中的除首个S表达式的列表， 它操作的对象也是要非空列表(十戒第一条)。 cons: 将两个S表达式连接成一个列表，第二个必须是一个列表。 null?: 只判断列表是否为空(scheme五律第四条)。 atom?: 用来判断一个S表达式是否为一个原子。 1 2 3 ( define atom? ( lambda ( m ) ( and ( not ( pair? m )) ( not ( null? m ))))) eq?: 用来判断两个非数字的的原子是否相等， (PS: guile的实现不太一样，它还可以比较数字。) 其它概念 define: 用来定义一个名称，或者一个函数。 lambda: 用来定义一个函数。 cond: 相当于其它语言中的switch。 else: 永远返回#t, 即True。 第二章: Do It, Do It Again, and Again, and Again… lat操作 基本概念 lat: 列表中包含的每个S表达式都是原子的列表。 应用 lat?: 判断列表中是否每个S表达式都是原子。 1 2 3 4 5 6 ( define lat? ( lambda ( l ) ( cond (( null? l ) #t ) (( atom? ( car l )) ( lat? ( cdr l ))) ( else #f )))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define col ( lambda ( lat nolat ) ( null? nolat ))) ( define lat?&co ( lambda ( l col ) ( cond (( null? l ) ( col ' () ' ())) (( atom? ( car l )) ( lat?&co ( cdr l ) ( lambda ( lat nolat ) ( col ( cons ( car l ) lat ) nolat )))) ( else ( lat?&co ( cdr l ) ( lambda ( lat nolat ) ( col lat ( cons ( car l ) nolat )))))))) member?: 用来判断一个S表达式是否在一个列表之内。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( define member? ( lambda ( a lat ) ( cond (( null? lat ) #f ) (( eq? a ( car lat )) #t ) ( else ( member? a ( cdr lat )))))) ; CPS变换 ( define col ( lambda ( in out ) ( not ( null? in )))) ( define member?&co ( lambda ( a lat col ) ( cond (( null? lat ) #f ) (( eq? a ( car lat )) ( member?&co a ( cdr lat ) ( lambda ( in out ) ( col ( cons a in ) out )))) ( else ( member?&co a ( cdr lat ) ( lambda ( in out ) ( col in ( cons a out )))))))) 第三章: Cons the Magnificent lat操作 应用 rember: 将一个S表达式从一个列表中删除。 1 2 3 4 5 6 ( define rember ( lambda ( a lat ) ( cond (( null? lat ) ' ()) (( eq? a ( car lat )) ( cdr lat )) ( else ( cons ( car lat ) ( rember a ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define col ( lambda ( rmcount leftlat ) ( display rmcount ) ( newline ) ( display leftlat ) ( newline ) leftlat )) ( define rember&co ( lambda ( a lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? a ( car lat )) ( col 1 ( cdr lat ))) ( else ( rember&co a ( cdr lat ) ( lambda ( rmcount leftlat ) ( col rmcount ( cons ( car lat ) leftlat )))))))) firsts: 从一个列表中的获取其每个子列表的首个S表达式，并以列表形式返回 1 2 3 4 5 ( define firsts ( lambda ( l ) ( cond (( null? l ) ' ()) ( else ( cons ( car ( car l )) ( firsts ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( first_ed ) ( display first_ed ) ( newline ) first_ed )) ( define firsts&co ( lambda ( l col ) ( display l ) ( newline ) ( cond (( null? l ) ( col ' ())) ( else ( firsts&co ( cdr l ) ( lambda ( first_ed ) ( col ( cons ( car ( car l )) first_ed )))))))) insertR: 将一个S表达式插入到一个列表中指定S表达式的右边， 并返回修改后的列表 insertL: 基本同上，只不过是插入到左边 Tip insert*函数的整体逻辑与rember是差不多的。 1 2 3 4 5 6 ( define insertR ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons old ( cons new ( cdr lat )))) ( else ( cons ( car lat ) ( insertR new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define col ( lambda ( newlat ) ( display newlat ) ( newline ) newlat )) ( define insertR&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col ' ())) (( eq? old ( car lat )) ( col ( cons old ( cons new ( cdr lat ))))) ( else ( insertR&co new old ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat ) ))))))) 1 2 3 4 5 6 ( define insertL ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons new lat )) ( else ( cons ( car lat ) ( insertL new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ( define col ( lambda ( newlat ) ( display newlat ) ( newline ) newlat )) ( define insertL&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col ' ())) (( eq? old ( car lat )) ( col ( cons new lat ))) ( else ( insertL&co new old ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) subst: 用新的S表达式替代列表中指定的S表达式， 并返回修改后的列表 subst2: 用来替代列表中指定的两个S表达式 Tip subst*函数的整体逻辑也与rember是差不多的。 1 2 3 4 5 6 ( define subst ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons new ( cdr lat ))) ( else ( cons ( car lat ) ( subst new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define col ( lambda ( newlat ) ( display newlat ) ( newline ) newlat )) ( define subst&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col ' ())) (( eq? old ( car lat )) ( col ( cons new ( cdr lat )))) ( else ( subst&co new old ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define subst2 ( lambda ( new old1 old2 lat ) ( cond (( null? lat ) ' ()) (( eq? old1 ( car lat )) ( cons new ( cdr lat ))) (( eq? old2 ( car lat )) ( cons new ( cdr lat ))) ( else ( cons ( car lat ) ( subst2 new old1 old2 ( cdr lat ))))))) ;subst2简化版本 ( define subst2 ( lambda ( new old1 old2 lat ) ( cond (( null? lat ) ' ()) (( or ( eq? old2 ( car lat )) ( eq? old1 ( car lat ))) ( cons new ( cdr lat ))) ( else ( cons ( car lat ) ( subst2 new old1 old2 ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define col ( lambda ( newlat ) ( display newlat ) ( newline ) newlat )) ( define subst2&co ( lambda ( new old1 old2 lat col ) ( cond (( null? lat ) ( col ' ())) (( or ( eq? old1 ( car lat )) ( eq? old2 ( car lat ))) ( col ( cons new ( cdr lat )))) ( else ( subst&co new old1 old2 ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) multirember: 基本同rember, 只不过是列表中所有符合的S表达式都会删除. Tip 其逻辑基本是在rember逻辑上进行扩充的。 1 2 3 4 5 6 ( define multirember ( lambda ( a lat ) ( cond (( null? lat ) ' ()) (( eq? a ( car lat )) ( multirember a ( cdr lat ))) ( else ( cons ( car lat ) ( multirember a ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define col ( lambda ( rmcount newlat ) ( display rmcount ) ( display \" \" ) ( display newlat ) ( newline ) newlat )) ( define multirember&co ( lambda ( a lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? a ( car lat )) ( multirember&co a ( cdr lat ) ( lambda ( rmcount newlat ) ( col ( + rmcount 1 ) newlat )))) ( else ( multirember&co a ( cdr lat ) ( lambda ( rmcount newlat ) ( col rmcount ( cons ( car lat ) newlat )))))))) multiinsertR: 基本同insertR, 只不过是列表中所有符合的s表达式都会插入其右边。 注意：其逻辑基本是在insertR逻辑上进行扩充的。 1 2 3 4 5 6 7 ( define multiinsertR ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons old ( cons new ( multiinsertR new old ( cdr lat ))))) ( else ( cons ( car lat ) ( multiinsertR new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define col ( lambda ( inscount newlat ) ( display inscount ) ( display \" \" ) ( display newlat ) ( newline ) newlat )) ( define multiinsertR&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? old ( car lat )) ( multiinsertR&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col ( + inscount 1 ) ( cons old ( cons new newlat )))))) ( else ( multiinsertR&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col inscount ( cons ( car lat ) newlat )))))))) multiinsertL: 基本同insertL, 只不过是列表中所有符合的s表达式都会插入其左边. 注意：其逻辑基本是在insertL逻辑上进行扩充的。 1 2 3 4 5 6 7 ( define multiinsertL ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons new ( cons old ( multiinsertL new old ( cdr lat ))))) ( else ( cons ( car lat ) ( multiinsertL new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ( define col ( lambda ( inscount newlat ) ( display inscount ) ( display \" \" ) ( display newlat ) ( newline ) newlat )) ( define mutlinsertL&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? old ( car lat )) ( mutlinsertL&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col ( + inscount 1 ) ( cons new ( cons old newlat )))))) ( else ( mutlinsertL&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col inscount ( cons ( car lat ) newlat )))))))) multisubst: 基本同sbust, 只不过是列表中所有符合的s表达式都替换 1 2 3 4 5 6 7 ( define multisubst ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons new ( multisubst new old ( cdr lat )))) ( else ( cons ( car lat ) ( multisubst new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ( define col ( lambda ( stcount newlat ) ( display stcount ) ( display \" \" ) ( display newlat ) ( newline ) newlat )) ( define mutlsubst&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? old ( car lat )) ( mutlisubst&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col ( + inscount 1 ) ( cons new newlat ))))) ( else ( mutlisubst&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col inscount ( cons ( car lat ) newlat )))))))) 第四章: Numbers Games 数字操作 基本概念 数字也是一个atom number?: 判断一个S表达式是否为数字 tup: 列表中包含的每个s表达式都是数字的列表。 应用 add1: 对数字加1 sub1: 对数字减1 +: 将两个数字相加 1 2 3 4 5 ( define + ( lambda ( a b ) ( cond (( zero? b ) a ) ( else ( add1 ( + a ( sub1 b ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define myadd&co ( lambda ( a b col ) ( cond (( zero? b ) ( col a )) ( else ( myadd&co a ( - b 1 ) ( lambda ( num ) ( col ( + num 1 )))))))) -: 将两个数字相减 1 2 3 4 5 ( define - ( lambda ( a b ) ( cond (( zero? b ) a ) ( else ( sub1 ( - a ( sub1 b ))))))) 1 2 3 4 5 6 7 8 9 10 11 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mysub&co ( lambda ( a b col ) ( cond (( zero? b ) ( col a )) ( else ( mysub&co ( - a 1 ) ( - b 1 ) col ))))) addtup: 一个tup中的所有数字相加 1 2 3 4 5 ( define addtup ( lambda ( tup ) ( cond (( null? tup ) 0 ) ( else ( + ( car tup ) ( addtup ( cdr tup ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define addtup&co ( lambda ( tup col ) ( cond (( null? tup ) ( col 0 )) ( else ( addtup&co ( cdr tup ) ( lambda ( sum ) ( col ( + sum ( car tup ))))))))) *: 将两个数字相乘 1 2 3 4 5 ( define * ( lambda ( n m ) ( cond (( zero? m ) 0 ) ( else ( + n ( * n ( sub1 m ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mymulti&co ( lambda ( n m col ) ( cond (( zero? m ) ( col 0 )) ( else ( mymulti&co n ( - m 1 ) ( lambda ( num ) ( + num n ))))))) tup+: 将两个tup中相对的数字相加,然后返回相加后的tup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; 该函数允许两个参数的长度不一样 ( define tup+ ( lambda ( tup1 tup2 ) ( cond (( null? tup2 ) tup1 ) (( null? tup1 ) tup2 ) ( else ( cons ( +_ ( car tup1 ) ( car tup2 )) ( tup+ ( cdr tup1 ) ( cdr tup2 ))))))) ; 该函数的两个参数长度必须一样 ( define tup+ ( lambda ( tup1 tup2 ) ( cond (( and ( null? tup1 ) ( null? tup2 )) ' ()) ( else ( cons ( +_ ( car tup1 ) ( car tup2 )) ( tup+ ( cdr tup1 ) ( cdr tup2 ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( newtup ) ( display newtup ) ( newline ) newtup )) ( define tup+&co ( lambda ( tup1 tup2 col ) ( cond (( null? tup1 ) ( col tup2 )) (( null? tup2 ) ( col tup1 )) ( else ( tup+&co ( cdr tup1 ) ( cdr tup2 ) ( lambda ( newtup ) ( col ( cons ( + ( car tup1 ) ( car tup2 )) newtup )))))))) <: 比较两个数字的大小 >: 比较两个数字的大小 1 2 3 4 5 6 ( define > ( lambda ( n m ) ( cond (( zero? n ) #f ) (( zero? m ) #t ) ( else ( > ( sub1 n ) ( sub1 m )))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mylt&co ( lambda ( n m col ) ( cond (( zero? n ) ( col #f )) (( zero? m ) ( col #t )) ( else ( mylt&co ( - n 1 ) ( - m 1 ) col ))))) 1 2 3 4 5 6 7 ( define < ( lambda ( n m ) ( cond (( zero? m ) #f ) (( zero? n ) #t ) ( else ( < ( sub1 n ) ( sub1 m )))))) ;基本同上 =: 比较两个数字是否相等 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define = ( lambda ( n m ) ( cond (( zero? m ) ( zero? n )) (( zero? n ) #f ) ( else ( = ( sub1 n ) ( sub1 m )))))) ( define = ( lambda ( n m ) ( cond (( > n m ) #f ) (( < n m ) #f ) ( else #t )))) &#94;: 阶乘 1 2 3 4 5 6 ( define &#94; ( lambda ( n m ) ( cond (( zero? n ) 0 ) (( zero? m ) 1 ) ( else ( * n ( &#94; n ( sub1 m ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mypower&co ( lambda ( n m col ) ( cond (( zero? n ) ( col 0 )) (( zero? m ) ( col 1 )) ( else ( mypower&co n ( - m 1 ) ( lambda ( num ) ( col ( * n num )))))))) /: 除 1 2 3 4 5 ( define / ( lambda ( n m ) ( cond (( < n m ) 0 ) ( else ( add1 ( / ( - n m ) m )))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mydiv&co ( lambda ( n m col ) ( cond (( < n m ) ( col 0 )) ( else ( mydiv&co ( - n m ) m ( lambda ( num ) ( col ( + num 1 )))))))) 综合操作 length: 返回一个lat的长度 1 2 3 4 5 ( define length ( lambda ( lat ) ( cond (( null? lat ) 0 ) ( else ( add1 ( length ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define length&co ( lambda ( lat col ) ( cond (( null? lat ) ( col 0 )) ( else ( length&co ( cdr lat ) ( lambda ( num ) ( col ( + num 1 )))))))) pick: 根据传入的数字,获取其对应在lat中位置的S表达式 1 2 3 4 5 ( define pick ( lambda ( n lat ) ( cond (( zero? ( sub1 n )) ( car lat )) ( else ( pick ( sub1 n ) ( cdr lat )))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define pick&co ( lambda ( n lat col ) ( cond (( null? lat ) ( col ' ())) (( zero? ( - n 1 )) ( col ( car lat ))) ( else ( pick&co ( - n 1 ) ( cdr lat ) col ))))) rempick: 根据传入的数字, 删除其对应在lat中位置的S表达式,并返回剩余列表 1 2 3 4 5 6 ( define rempick ( lambda ( n lat ) ( cond (( null? lat ) ' ()) (( zero? ( sub1 n )) ( cdr lat )) ( else ( cons ( car lat ) ( rempick ( sub1 n ) ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define rempick&co ( lambda ( n lat col ) ( cond (( null? lat ) ( col ' ())) (( zero? ( - n 1 )) ( col ( cdr lat ))) ( else ( rempick&co ( - n 1 ) ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) no-nums: 选出列表中的非数字S表达式, 并以列表形式返回 1 2 3 4 5 6 ( define no-nums ( lambda ( lat ) ( cond (( null? lat ) ' ()) (( number? ( car lat )) ( no-nums ( cdr lat ))) ( else ( cons ( car lat ) ( no-nums ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define nonum&co ( lambda ( lat col ) ( cond (( null? lat ) ( col ' ())) (( number? ( car lat )) ( nonum&co ( cdr lat ) col )) ( else ( nonum&co ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) all-nums: 跟上面相反, 只返回数字列表 1 2 3 4 5 6 7 8 ( define all-nums ( lambda ( lat ) ( cond (( null? lat ) ' ()) (( not ( number? ( car lat ))) ( all-nums ( cdr lat ))) ( else ( cons ( car lat ) ( all-nums ( cdr lat ))))))) ;逻辑基本同上 eqan?: 比较两个S表达式是否是相等 1 2 3 4 5 6 7 8 ( define eqan? ( lambda ( a1 a2 ) ( cond (( and ( number? a1 ) ( number? a2 )) ( = a1 a2 )) (( or ( number? a1 ) ( number? a2 )) #f ) ( else ( eq? a1 a2 ))))) occur?: 检查列表中有几个指定的S表达式 1 2 3 4 5 6 7 ( define occur ( lambda ( a lat ) ( cond (( null? lat ) 0 ) (( eqan? a ( car lat )) ( add1 ( occur a ( cdr lat )))) ( else ( occur a ( cdr lat )))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define occur&co ( lambda ( n lat col ) ( cond (( null? lat ) ( col 0 )) (( eq? n ( car lat )) ( occur&co n ( cdr lat ) ( lambda ( num ) ( col ( + num 1 ))))) ( else ( occur&co n ( cdr lat ) col ))))) one?: 判断一个数字是否为1 1 2 3 4 5 6 7 8 9 10 ( define one? ( lambda ( n ) ( cond (( zero? n ) #f ) ( else ( zero? ( sub1 n )))))) ( define one? ( lambda ( n ) ( cond ( else ( =_ n 1 ))))) 第五章: *Oh My Gawd*: It's Full of Stars rember*: 基本同rember, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define rember* ( lambda ( a l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( rember* a ( cdr l ))) ( else ( cons ( car l ) ( rember* a ( cdr l )))))) ( else ( cons ( rember* a ( car l )) ( rember* a ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define rember*&co ( lambda ( a l col ) ( cond (( null? l ) ( col ' ())) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( rember*&co a ( cdr l ) col )) ( else ( rember*&co a ( cdr l ) ( lambda ( newl ) ( col ( cons ( car l ) newl ))))))) ( else ( rember*&co a ( car l ) ( lambda ( carl ) ( rember*&co a ( cdr l ) ( lambda ( cdrl ) ( col ( cons carl cdrl )))))))))) insertR*: 基本同insertR, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define insertR* ( lambda ( new old l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( cons old ( cons new ( insertR* new old ( cdr l ))))) ( else ( cons ( car l ) ( insertR* new old ( cdr l )))))) ( else ( cons ( insertR* new old ( car l )) ( insertR* new old ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define insertR*&co ( lambda ( new old l col ) ( cond (( null? l ) ( col ' ())) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( insertR*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons old ( cons new newl )))))) ( else ( insertR*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons ( car l ) newl ))))))) ( else ( insertR*&co new old ( car l ) ( lambda ( carl ) ( insertR*&co new old ( cdr l ) ( lambda ( cdrl ) ( col ( cons carl cdrl )))))))))) occur*: 基本同occur, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define occur* ( lambda ( a l ) ( cond (( null? l ) 0 ) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( add1 ( occur* a ( cdr l )))) ( else ( occur* a ( cdr l ))))) ( else ( +_ ( occur* a ( car l )) ( occur* a ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define occur*&co ( lambda ( a l col ) ( cond (( null? l ) ( col 0 )) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( occur*&co a ( cdr l ) ( lambda ( num ) ( col ( + num 1 ))))) ( else ( occur*&co a ( cdr l ) col )))) ( else ( occur*&co a ( car l ) ( lambda ( carnum ) ( occur*&co a ( cdr l ) ( lambda ( cdrnum ) ( col ( + carnum cdrnum )))))))))) subst*: 基本同subst, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define subst* ( lambda ( new old l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( cons new ( subst* new old ( cdr l )))) ( else ( cons ( car l ) ( subst* new old ( cdr l )))))) ( else ( cons ( subst* new old ( car l )) ( subst* new old ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define subst*&co ( lambda ( new old l col ) ( cond (( null? l ) ( col l )) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( subst*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons new newl ))))) ( else ( subst*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons ( car l ) newl ))))))) ( else ( subst*&co new old ( car l ) ( lambda ( carl ) ( subst*&co new old ( cdr l ) ( lambda ( cdrl ) ( col ( cons carl cdrl )))))))))) insertL*: 基本同insertL, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define insertL* ( lambda ( new old l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( cons new ( cons old ( insertL* new old ( cdr l ))))) ( else ( cons ( car l ) ( insertL* new old ( cdr l )))))) ( else ( cons ( insertL* new old ( car l )) ( insertL* new old ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define insertL*&co ( lambda ( new old l col ) ( cond (( null? l ) ( col l )) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( insertL*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons new ( cons old newl )))))) ( else ( insertL*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons old newl ))))))) ( else ( insertL*&co new old ( car l ) ( lambda ( carl ) ( insertL*&co new old ( cdr l ) ( lambda ( cdrl ) ( col ( cons carl cdrl )))))))))) member*: 基本同member, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 ( define member* ( lambda ( a l ) ( cond (( null? l ) #f ) (( atom? a ( car l )) ( cond (( eq? a ( car l )) #t ) ( else ( member* a ( cdr l ))))) ( else ( or ( member* a ( car l )) ( member* a ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define member*&co ( lambda ( a l col ) ( cond (( null? l ) ( col #f )) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( col #t )) ( else ( member*&co a ( cdr l ) col )))) ( else ( member*&co a ( car l ) ( lambda ( incar ) ( member*&co a ( cdr l ) ( lambda ( incdr ) ( col ( or incar incdr )))))))))) leftmost: 找出不包含空列表的列表/嵌套列表中的最左边的一个atom 1 2 3 4 5 ( define leftmost ( lambda ( l ) ( cond (( atom? ( car l )) ( car l )) ( else ( leftmost ( car l )))))) eqlist?: 判断两个列表/嵌套列表是否相同 Tip 作者通过equal?来简化了eqlist?， 而且equal?也是通过eqlist?来实现的。 只当函数正确的前提下再进行简化/优化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ( define eqlist? ( lambda ( l1 l2 ) ( cond (( and ( null? l1 ) ( null? l2 )) #t ) (( and ( null? l1 ) ( atom? ( car l2 ))) #f ) (( null? l1 ) #f ) (( and ( atom? ( car l1 )) ( null? l2 )) #f ) (( and ( atom? ( car l1 )) ( atom? ( car l2 ))) ( and ( eqan? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 )))) (( atom? ( car l1 )) #f ) (( null? l2 ) #f ) (( atom? ( car l2 )) #f ) ( else ( and ( eqlist? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 ))))))) ( define eqlist? ( lambda ( l1 l2 ) ( cond (( and ( null? l1 ) ( null? l2 )) #t ) (( or ( null? l1 ) ( null? l2 )) #f ) (( and ( atom? ( car l1 )) ( atom? ( car l2 ))) ( and ( eqan? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 )))) (( or ( atom? ( car l1 )) ( atom? ( car l2 ))) #f ) ( else ( and ( eqlist? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 ))))))) 1 2 3 4 5 6 7 ( define equal? ( lambda ( s1 s2 ) ( cond (( and ( atom? s1 ) ( atom? s2 )) ( eqan? s1 s2 )) (( or ( atom? s1 ) ( atom? s2 )) #f ) ( else ( eqlist? s1 s2 ))))) 1 2 3 4 5 6 7 8 ( define eqlist? ( lambda ( l1 l2 ) ( cond (( and ( null? l1 ) ( null? l2 )) #t ) (( or ( null? l1 ) ( null? l2 )) #f ) ( else ( and ( equal? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 ))))))) rember: 重写之前简单的rember, 参数s代表任何S表达式,参数l代码任何列表 1 2 3 4 5 6 ( define rember ( lambda ( s l ) ( cond (( null? l ) ' ()) (( equal? s ( car l )) ( cdr l )) ( else ( cons ( car l ) ( rember s ( cdr l ))))))) 第六章: Shadows 这一章讲的是有关算术表达式的相关内容, 它通过帮助函数来 支持前缀中缀后缀算术表达式. 但我这里只写了前缀表达式的代码. 应用 判断一个S表达式是否为算术表达式 1 2 3 4 5 6 7 8 9 10 ( define numbered? ( lambda ( aexp ) ( cond (( atom? aexp ) ( number? aexp )) (( or ( eq? ( car ( cdr aexp )) '+ ) ( eq? ( car ( cdr aexp )) '* ) ( eq? ( car ( cdr aexp )) '&#94; )) ( and ( numberd? ( car aexp )) ( numberd? ( car ( cdr ( cdr aexp )))))) ( else #f )))) &#94;: 倍数 1 2 3 ( define &#94; ( lambda ( n m ) ( expt n m ))) value: 获取一个算术表达式的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ( define value ( lambda ( nexp ) ( cond (( atom? nexp ) nexp ) (( eq? ( car nexp ) '+ ) ( + ( value ( cdr nexp )) ( value ( cdr ( cdr nexp ))))) (( eq? ( car nexp ) '* ) ( * ( value ( cdr nexp )) ( value ( cdr ( cdr nexp ))))) ( else ( &#94; ( value ( cdr nexp )) ( value ( cdr ( cdr nexp )))))))) ; 帮助函数 ( define 1 st-sub-exp ( lambda ( aexp ) ( car ( cdr aexp )))) ; 帮助函数 ( define 2 nd-sub-exp ( lambda ( aexp ) ( car ( cdr ( cdr aexp ))))) ; 帮助函数 ( define operator ( lambda ( aexp ) ( car aexp ))) ; 使用帮助函数重写的value函数 ; 这样修改后的函数, 其实即可以用在前缀,也可以用在后缀表达式上 ; 只要修改几个帮助函数即可 ( define value ( lambda ( nexp ) ( cond (( atom? nexp ) nexp ) (( eq? ( operator nexp ) '+ ) ( + ( value ( 1 st-sub-exp nexp )) ( value ( 2 nd-sub-exp nexp )))) (( eq? ( operator nexp ) '* ) ( * ( value ( 1 st-sub-exp nexp )) ( value ( 2 nd-sub-exp )))) ( else ( &#94; ( value ( 1 st-sub-exp nexp )) ( value ( 2 nd-sub-exp nexp ))))))) 接下来作者用()来表示0, (())表示1, (() ())表示2… 然后定义了对应的原语函数: sero?, edd1, zub1, 第七章: Friends and Relations set操作 基本概念 set: 集合, 类似于列表, 但是它其中的元素唯一 应用 set?: 判断一个S表达式是否为set 1 2 3 4 5 6 ( define set? ( lambda ( lat ) ( cond (( null? lat ) #t ) (( member? ( car lat ) ( cdr lat )) #f ) ( else ( set? ( cdr lat )))))) makeset: 生成一个set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ( define makeset ( lambda ( lat ) ( cond (( null? lat ) ' ()) (( member? ( car lat ) ( cdr lat )) ( makeset ( cdr lat ))) ( else ( cons ( car lat ) ( makeset ( cdr lat ))))))) ;使用multirember, 另外一种思路 ( define makeset ( lambda ( lat ) ( cond (( null? lat ) ' ()) ( else ( cons ( car lat ) ( makeset ( multirember ( car lat ) ( cdr lat )))))))) subset?: 判断set1是否是set2的子集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define subset? ( lambda ( set1 set2 ) ( cond (( null? set1 ) #t ) (( member? ( car set1 ) set2 ) ( subset? ( cdr set1 ) set2 )) ( else #f )))) ( define subset? ( lambda ( set1 set2 ) ( cond (( null? set1 ) #t ) (( and ( member? ( car set1 ) set2 ) ( subset? ( cdr set1 ) set2 )))))) eqset?: 判断两个set是否相等 1 2 3 4 ( define eqset? ( lambda ( set1 set2 ) (( and ( subset? set1 set2 ) ( subset? set2 set1 ))))) interset?: 判断set1是否至少有一个S表达式在set2中 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define intersect? ( lambda ( set1 set2 ) ( cond (( null? set1 ) #t ) (( member? ( car set1 ) set2 ) #t ) ( else ( intersect? ( cdr set1 ) set2 ))))) ( define intersect? ( lambda ( set1 set2 ) ( cond (( null? set1 ) #t ) (( or ( member? ( car set1 ) set2 ) ( intersect? ( cdr set1 ) set2 )))))) interset: 求两个set的交集 1 2 3 4 5 6 7 8 9 10 ( define intersect ( lambda ( set1 set2 ) ( cond (( or ( null? set1 ) ( null? set2 )) ' ()) (( member? ( car set1 ) set2 ) ( cons ( car set1 ) ( intersect ( cdr set1 ) set2 ))) ( else ( intersect ( cdr set1 ) set2 ))))) union: 求两个set的并集 1 2 3 4 5 6 7 8 9 ( define union ( lambda ( set1 set2 ) ( cond (( null? set1 ) set2 ) (( null? set2 ) set1 ) (( member? ( car set1 ) set2 ) ( union ( cdr set1 ) set2 )) ( else ( cons ( car set1 ) ( union ( cdr set1 ) set2 )))))) intersectall: 获取set中每个子set的交集 1 2 3 4 5 6 ( define intersectall ( lambda ( l-set ) ( cond (( null? ( cdr l-set )) ( car l-set )) ( else ( intersect ( car l-set ) ( intersectall ( cdr l-set ))))))) pair操作 基本概念 pair: 点对, 只包含两个S表达式的列表 应用 a-pair?: 判断一个S表达式是否为pair 1 2 3 4 5 6 7 8 ( define a-pair? ( lambda ( x ) ( cond (( atom? x ) #f ) (( null? x ) #f ) (( null? ( cdr lat ) #f )) (( null? ( cdr ( cdr lat ))) #t ) ( else #f )))) first: 获取pair的第一个S表达式 1 2 3 ( define first ( lambda ( p ) ( car p ))) second: 获取pair的第二个S表达式 1 2 3 ( define second ( lambda ( p ) ( car ( cdr p )))) build: 生成一个pair 1 2 3 ( define build ( lambda ( s1 s2 ) ( cons s1 ( cons s2 ' ())))) rel操作 基本概念 rel: 是一个内部嵌套pair的list, 但是其所有子pair是唯一的 fun操作 基本概念 fun: 同rel, 但其所有子pair的第一个元素也是唯一的, 类似于字典(key->value) 应用 fun?: 判断一个S表达式是否为fun 1 2 3 ( define fun? ( lambda ( rel ) ( set? ( firsts rel )))) revrel: 将fun中所有子pair的两个元素对调 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define revrel ( lambda ( rel ) (( null? rel ) ' ()) ( else ( cons ( build ( second ( car rel )) ( first ( car rel ))) ( revrel ( cdr rel )))))) ; 如果将其中的pair中两元素对调写成一个单独的函数 ; 则revrel看起来会更简洁明了 ( define revpair ( lambda ( pair ) ( build ( second pair ) ( first pair )))) ( define revrel ( lambda ( rel ) (( null? rel ) ' ()) ( else ( cons ( revpair ( car rel )) ( revrel ( cdr rel )))))) fullfun操作 基本概念 fullfun: 基本同fun, 但其所有子pair的第二个元素也是唯一的 应用 fullfun?: 判断一个S表达式是否为fullfun 1 2 3 4 5 6 7 ( define fullfun? ( lambda ( fun ) ( set? ( seconds fun )))) ( define fullfun? ( lambda ( fun ) ( fun? ( revrel fun )))) 第八章: Lambda the Ultimate 这一章才算开始高能, 下面的九,十章则更是要下一翻功夫了. 说高能, 并不是指有多难(除了连续概念的讲解), 而是指这一章揭示了很多更深入的东西, 更深入的抽象. rember-f: 基本同rember, 但是其中的eq/equal比较函数, 当作参数传入进来, 具体的比较操作就抽象比来, 可以用来支持各种对象/类型的删除操作. 只需要你定义好其对象/类型的eq/equal比较函数即可. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ( define rember-f ( lambda ( test? a l ) ( cond (( null? l ) ' ()) (( test? a ( car l )) ( cdr l )) ( else ( cons ( car l ) ( rember-f ( test? a ( cdr l )))))))) ; 定义成为一个高阶函数 ( define rember-f ( lambda ( test? ) ( lambda ( a l ) ( cond (( null? l ) ' ()) (( test? a ( car l )) ( cdr l )) ( else ( cons ( car l ) ( rember-f ( test? a ( cdr l ))))))))) ( define rember-eq? ( lambda ( a l ) ( rember-f eq? ))) ( define rember-equal? ( lambda ( a l ) ( rember-f equal? ))) eq?-c: 返回一个函数, 用来与固定S表达式比较. 1 2 3 4 5 6 7 8 ( define eq?-c ( lambda ( a ) ( lambda ( x ) ( eq? x a )))) ; 与salad比较 ( define eq?-salad ( eq?-c 'salad )) insert-q: 返回一个函数, 具体的操作函数当作参数传入 1 2 3 ( define seqL ( lambda ( new old l ) ( cons new ( cons old l )))) 1 2 3 ( define seqR ( lambda ( new old l ) ( cons old ( cons new l )))) 1 2 3 ( define seqS ( lambda ( new old l ) ( cons new l ))) 1 2 3 4 5 6 7 8 9 ( define insert-g ( lambda ( seq ) ( lambda ( new old l ) ( cond (( null? l ) ' ()) (( eq? ( car l ) old ) ( seq new old ( cdr l ))) ( else ( cons ( car l ) (( insert-g seq ) new old ( cdr l )))))))) 1 2 ( define insertL ( insert-g seqL )) 1 2 ( define insertR ( insert-g seqR )) 1 2 ( define subst ( insert-g seqS )) value: 重写之前的value, 将里面的操作抽象出来 1 2 3 4 5 6 ( define atom-to-function ( lambda ( x ) ( cond (( eq? x '+ ) + ) (( eq? x '* ) * ) ( else &#94; )))) 1 2 3 4 5 6 7 8 ( define value ( lambda ( nexp ) ( cond (( atom? nexp ) nexp ) ( else (( atom-to-function ( operator nexp )) ( value ( 1 st-sub-exp nexp )) ( value ( 2 nd-sub-exp nexp ))))))) multirember-f: 同上, 用test?代替eq?/equal? 1 2 3 4 5 6 7 8 9 ( define multirember-f ( lambda ( test? ) ( lambda ( a lat ) ( cond (( null? lat ) ' ()) (( test? a ( car lat )) (( multirember-f test? ) a ( cdr lat ))) ( else ( cons ( car lat ) (( multirember-f test? ) a ( cdr lat )))))))) 1 2 ( define multirember-eq? ( multirember-f eq? )) 1 2 ( define multirember-equal? ( multirember-f equal? )) multiremberT: 基本同上, 不过test?可以带参数， 将每次递归都不会变化的test?和a参数都存放到test?函数中. 以后写函数, 可以将哪些参数是不变的, 哪些参数是变化的区分开来. 1 2 3 4 5 6 7 8 ( define multiremberT ( lambda ( test? lat ) ( cond (( null? lat ) ' ()) (( test? ( car lat )) ( multiremberT test? ( cdr lat ))) ( else ( cons ( car lat ) ( multiremberT test? ( cdr lat ))))))) multirember&co: 将具体的操作放入col中 其中的col相当于一个收集器(collector), 它将lat中和a参数不相同的 放入col的第一个参数中, 相同的放入第二个参数中. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define multirember&co ( lambda ( a lat col ) ( cond (( null? lat ) ( col ' () ' ())) (( eq? ( car lat ) a ) ( multirember&co a ( cdr lat ) ( lambda ( newlat seen ) ( col newlat ( cons ( car lat ) seen ))))) ( else ( multirember&co a ( cdr lat ) ( lambda ( newlat seen ) ( col ( cons ( car lat ) newlat ) seen ))))))) 1 2 3 ( define a-friend ( lambda ( x y ) ( null? y ))) multiinsertLR: 将new插入到oldL的左边,oldR的右边. 1 2 3 4 5 6 7 8 9 10 ( define multiinsertLR ( lambda ( new oldL oldR lat ) ( cond (( null? lat ) ' ()) (( eq? oldL ( car lat )) ( cons new ( cons oldL ( multiinsertLR new oldL oldR ( cdr lat ))))) (( eq? oldR ( car lat )) ( cons oldR ( cons new ( multiinsertLR new oldL oldR ( cdr lat ))))) ( else ( cons ( car lat ) ( multiinsertLR new oldL oldR ( cdr lat ))))))) multiinsertLR&co: 将具体的操作放入col中 col的newlat参数存放最后插入new参数后的newlat, L参数是在oldL参数左边插入的次数, R参数是在oldR参数右边插入的次数. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define multiinsertLR&co ( lambda ( new oldL oldR lat col ) ( cond (( null? lat ) ( col ' () 0 0 )) (( eq? oldL ( car lat )) ( multiinsertLR&co new oldL oldR ( cdr lat ) ( lambda ( newlat L R ) ( col ( cons new ( cons oldL newlat )) ( add1 L ) R )))) (( eq? oldR ( car lat )) ( multiinsertLR&co new oldL oldR ( cdr lat ) ( lambda ( newlat L R ) ( col ( cons oldR ( cons new newlat )) L ( add1 R ))))) ( else ( multiinsertLR&co new oldL oldR ( cdr lat ) ( lambda ( newlat L R ) ( col ( car lat ) L R ))))))) evens-only*: 找出嵌套队列中所有的偶数 1 2 3 4 5 ; 此处要用之前定义的运算符号,用系统自带的会出错 ; lisp支持分数, 即3/2不缺失其精度 ( define even? ( lambda ( n ) ( =_ ( *_ ( /_ n 2 ) 2 ) n ))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define evens-only* ( lambda ( l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( even? ( car l )) ( cons ( car l ) ( evens-only* ( cdr l )))) ( else ( evens-only* ( cdr l ))))) ( else ( cons ( evens-only* ( car l )) ( evens-only* ( cdr l ))))))) evens-only*&co: 将具体的操作放入col中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ( define evens-only*&co ( lambda ( l col ) ( cond (( null? l ) ( col ' () 1 0 )) (( atom? ( car l )) ( cond (( even? ( car l )) ( evens-only*&co ( cdr l ) ( lambda ( newlat m s ) ( col ( cons ( car l ) newlat ) ( * ( car l ) m ) s )))) ( else ( evens-only*&co ( cdr l ) ( lambda ( newlat m s ) ( col newlat m ( + ( car l ) s ))))))) ( else ( evens-only*&co ( car l ) ( lambda ( al am as ) ( evens-only*&co ( cdr l ) ( lambda ( dl dm ds ) ( col ( cons al dl ) ( * am dm ) ( + as ds )))))))))) 这里建议一下，最好将从第二章开始的所有递归函数都用cps形式手动重写一遍 第九章: … and Again, and Again, and Again, … looking/keep-looking: 1 2 3 4 5 6 7 8 9 10 ( define looking ( lambda ( a lat ) ( keep-looing a ( pick 1 lat ) lat ))) ( define keep-looing ( lambda ( a sorn lat ) ( cond (( number? sorn ) ( keep-looking a ( pick sorn lat ) lat )) ( else ( eq? sorn a ))))) shift: 1 2 3 4 5 ( define shift ( lambda ( pair ) ( build ( first ( first pair )) ( build ( second ( first pair )) ( second pair ))))) align: 接下来讲的是停机理论和Y算子的概念, 基本都是理论上的东西 第十章: What Is the Value of All of This? 1 2 3 4 5 6 ( define lookup-in-entry ( lambda ( name entry entry-f ) ( lookup-in-entry-help name ( first entry ) ( second entry ) entry-f )))","tags":"scheme","loc":"http://chenjiee815.github.io/thelittleschemerbi-ji.html","title":"TheLittleSchemer笔记"}]}