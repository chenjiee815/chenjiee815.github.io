{"pages":[{"text":"Contents 简介 HTTP 各版本协议简介 HTTP/0.9 HTTP/1.0 HTTP/1.1 默认值 DEFAULT_ERROR_MESSAGE DEFAULT_ERROR_CONTENT_TYPE _quote_html HTTPServer allow_reuse_address BaseHTTPRequestHandler URL 长度限制 打印日志的相关方法 responses 简介 该模块不实现任何具体的 HTTP 请求（比如 GET、POST、HEAD... ...）， 如果想了解深入了解，可以参见 SimpleHTTPServer 模块。 该模块只是实现了一个基本框架，让用户只需要关心如何处理具体的 HTTP 请求，并且部分实现了 HTTP/1.1 的长连接功能。 HTTP 各版本协议简介 HTTP 的消息格式定义基本如下： 起始行，必选，定义请求方法、请求路径等等 首部，可选，定义该消息的元数据 主体，可选，消息附带的数据 消息头部与消息体使用 rn 来进行分割。 HTTP/0.9 HTTP 的 1991 原型版本称为 HTTP/0.9 ，它的初衷是为了获取简单的 HTML。 该协议有很多严重的设计缺陷，只适用于与老客户端进行交互，并且它只支持 GET 方法。 它的请求消息就一行： <command> <path> 同时它的响应消息不包含消息头部，只包含响应数据。 HTTP/1.0 该版本是第一个得到广泛应用的版本。 它添加了版本号、各种 HTTP 首部、一些额外的 HTTP 方法，以及对多媒体对象的处理。 请求消息格式： <command> <path> <version> HTTP 请求首部 HTTP 请求主体 响应消息格式： <version> <responsecode> <responsestring> HTTP 响应首部 HTTP 响应主体 HTTP/1.1 该版本重点关注的是校正 HTTP 设计中的结构性缺陷。明确语义，引入重要的性能优化措施，并删除一些不好的特性。 比如本模块里部分支持 HTTP/1.1 定义的长连接功能。 默认值 这两个没啥好解释的。 DEFAULT_ERROR_MESSAGE 1 2 3 4 5 6 7 8 9 10 11 DEFAULT_ERROR_MESSAGE = \"\"\" \\ <head> <title>Error response</title> </head> <body> <h1>Error response</h1> <p>Error code %(code)d . <p>Message: %(message)s . <p>Error code explanation: %(code)s = %(explain)s . </body> \"\"\" DEFAULT_ERROR_CONTENT_TYPE DEFAULT_ERROR_CONTENT_TYPE = \"text/html\" _quote_html 1 2 def _quote_html ( html ): return html . replace ( \"&\" , \"&amp;\" ) . replace ( \"<\" , \"&lt;\" ) . replace ( \">\" , \"&gt;\" ) 对 URL 进行简单的转码，用来防止 XSS 。 详情参见： Issue1100201 该 Bug 简单来说就是利用上面的 DEFAULT_ERROR_MESSAGE 会将 URL 也包含在内的特点， 构造一个包含可执行代码 ( 比如 JS 代码 ) 的 URL，这样就会导致 HTTPServer 返回的错误页面中的代码会被浏览器执行。 HTTPServer HTTPServer 的代码量很少，原因很简单，HTTP 协议基本可分为两个方面： 规定了 TCP 通信的格式与内容 规定了如何使用 TCP 连接 它本质上就是一个 TCPServer ，主要看它是如何进行请求处理的。 1 2 3 4 5 6 7 8 9 10 class HTTPServer ( SocketServer . TCPServer ): allow_reuse_address = 1 def server_bind ( self ): # 重载 `server_bind` 是为了获取 `server_name` 和 `server_port` SocketServer . TCPServer . server_bind ( self ) host , port = self . socket . getsockname ()[: 2 ] self . server_name = socket . getfqdn ( host ) self . server_port = port allow_reuse_address 一般来说，一个端口释放后会等待两分钟之后才能再被使用， allow_reuse_address 是让端口释放后立即就可以被再次使用。 如果想了解有关详情，请 Google SO_REUSEADDR BaseHTTPRequestHandler 该类就是进行具体 HTTP 请求（GET、POST... ...）的类。 如果用户想处理 HTTP 请求（假定 HTTP 方法为 SPAM），只需要定义 do_SPAM 方法即可。 Note 此处的 SPAM 是大小写敏感的。 只需要按如下格式编写代码即可： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyHTTPRequestHandler ( BaseHTTPRequestHandler ): HELLO_WORLD = ''' \\ <html> <body> <p>Hello, web!</p> </body> </html> ''' def do_GET ( self ): self . send_response ( 200 ) self . send_header ( \"Content-type\" , \"text/html\" ) self . send_header ( \"Content-Length\" , str ( len ( self . HELLO_WORLD )) self . end_headers () self . wfile . write ( self . HELLO_WORLD ) 此外， BaseHTTPRequestHandler 中还有一系列的属性，可以获取以及处理与请求相关的信息。 client_address: 客户端 IP command: HTTP 方法 path: HTTP 请求路径 version: HTTP 版本号 headers: HTTP 请求首部，它是 mimetools.Message 实例 rfile: 读入请求消息的文件对象 wfile: 写入响应消息的文件对象 Warning 如果要返回响应消息，第一行必须要写入响应首行；然后再写入 0 到多个的响应头部；然后再写入一个空行；最后根据需要再写入消息主体。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 class BaseHTTPRequestHandler ( SocketServer . StreamRequestHandler ): sys_version = \"Python/\" + sys . version . split ()[ 0 ] server_version = \"BaseHTTP/\" + __version__ default_request_version = \"HTTP/0.9\" def parse_request ( self ): # 解释一个 HTTP 请求的首行及头部，并将解析结果放到自身的各个属性中 self . command = None # set in case of error on the first line self . request_version = version = self . default_request_version self . close_connection = 1 requestline = self . raw_requestline requestline = requestline . rstrip ( ' \\r\\n ' ) self . requestline = requestline words = requestline . split () if len ( words ) == 3 : # 非 HTTP/0.9 版本 command , path , version = words if version [: 5 ] != 'HTTP/' : self . send_error ( 400 , \"Bad request version ( %r )\" % version ) return False try : # 解释请求消息中的 HTTP 版本号，这里最好也封装起来 base_version_number = version . split ( '/' , 1 )[ 1 ] version_number = base_version_number . split ( \".\" ) # RFC 2145 section 3.1 says there can be only one \".\" and # - major and minor numbers MUST be treated as # separate integers; # - HTTP/2.4 is a lower version than HTTP/2.13, which in # turn is lower than HTTP/12.3; # - Leading zeros MUST be ignored by recipients. if len ( version_number ) != 2 : raise ValueError version_number = int ( version_number [ 0 ]), int ( version_number [ 1 ]) except ( ValueError , IndexError ): self . send_error ( 400 , \"Bad request version ( %r )\" % version ) return False if version_number >= ( 1 , 1 ) and self . protocol_version >= \"HTTP/1.1\" : self . close_connection = 0 if version_number >= ( 2 , 0 ): self . send_error ( 505 , \"Invalid HTTP Version ( %s )\" % base_version_number ) return False elif len ( words ) == 2 : # 请求首行只有两个字段，说明是 HTTP/0.9 command , path = words self . close_connection = 1 if command != 'GET' : # HTTP/0.9 只支持 GET 方法 self . send_error ( 400 , \"Bad HTTP/0.9 request type ( %r )\" % command ) return False elif not words : return False else : self . send_error ( 400 , \"Bad request syntax ( %r )\" % requestline ) return False self . command , self . path , self . request_version = command , path , version # Examine the headers and look for a Connection directive self . headers = self . MessageClass ( self . rfile , 0 ) # 这里就是所谓的部分支持 HTTP/1.1 版本的长连接功能 conntype = self . headers . get ( 'Connection' , \"\" ) if conntype . lower () == 'close' : self . close_connection = 1 elif ( conntype . lower () == 'keep-alive' and self . protocol_version >= \"HTTP/1.1\" ): self . close_connection = 0 return True def handle_one_request ( self ): \"\"\" 处理一次请求 \"\"\" try : # 读取请求数据的第一行，不过这里限制了第一行的大小 # 由于方法名和版本号长度基本算固定的，所以这里就相当于限制 URL 的长度 self . raw_requestline = self . rfile . readline ( 65537 ) if len ( self . raw_requestline ) > 65536 : # HTTP 请求首行太长了，对应的 HTTP code 码就是 414 self . requestline = '' self . request_version = '' self . command = '' self . send_error ( 414 ) return # 没有读到任何数据，说明通信异常，该 socket 连接可以直接关闭 if not self . raw_requestline : self . close_connection = 1 return # 解析请求消息出错 if not self . parse_request (): # An error code has been sent, just exit return # 以下的几行代码可以封装起来 # 根据 HTTP 方法来调用 `do_SPAM` 方法。 mname = 'do_' + self . command if not hasattr ( self , mname ): self . send_error ( 501 , \"Unsupported method ( %r )\" % self . command ) return method = getattr ( self , mname ) method () self . wfile . flush () except socket . timeout , e : self . log_error ( \"Request timed out: %r \" , e ) self . close_connection = 1 return def handle ( self ): \"\"\" 入口方法，从这里开始整个 HTTP 请求处理及响应 \"\"\" self . close_connection = 1 # 关闭连接标志 self . handle_one_request () while not self . close_connection : self . handle_one_request () def send_error ( self , code , message = None ): \"\"\" 发送一个错误格式的响应消息 \"\"\" try : # 网上有人吐槽 `long` 为 Python 的内置类型，不建议当作变量名 short , long = self . responses [ code ] except KeyError : short , long = '???' , '???' if message is None : message = short explain = long self . log_error ( \"code %d , message %s \" , code , message ) # 这里使用了 `_quote_html` ，至于为什么使用，上面已有说明。 content = ( self . error_message_format % { 'code' : code , 'message' : _quote_html ( message ), 'explain' : explain }) self . send_response ( code , message ) self . send_header ( \"Content-Type\" , self . error_content_type ) self . send_header ( 'Connection' , 'close' ) self . end_headers () # 这里的 HTTP code 码都硬编码了，不建议。 if self . command != 'HEAD' and code >= 200 and code not in ( 204 , 304 ): self . wfile . write ( content ) error_message_format = DEFAULT_ERROR_MESSAGE error_content_type = DEFAULT_ERROR_CONTENT_TYPE def send_response ( self , code , message = None ): \"\"\" 发送响应消息 \"\"\" self . log_request ( code ) if message is None : if code in self . responses : message = self . responses [ code ][ 0 ] else : message = '' # HTTP/0.9 版本没有响应消息头部定义 if self . request_version != 'HTTP/0.9' : # 响应消息首行 self . wfile . write ( \" %s %d %s \\r\\n \" % ( self . protocol_version , code , message )) # print (self.protocol_version, code, message) self . send_header ( 'Server' , self . version_string ()) self . send_header ( 'Date' , self . date_time_string ()) def send_header ( self , keyword , value ): # 写入响应头部，HTTP/0.9 版本没有响应消息头部定义 if self . request_version != 'HTTP/0.9' : self . wfile . write ( \" %s : %s \\r\\n \" % ( keyword , value )) # HTTP/1.1 协议规定 # 如果不需要支持长连接，则返回 `close` # 反之，返回 `keep-alive` if keyword . lower () == 'connection' : if value . lower () == 'close' : self . close_connection = 1 elif value . lower () == 'keep-alive' : self . close_connection = 0 def end_headers ( self ): # HTTP 消息头部和消息体之间有一个空行，以 \\r\\n 分割 # HTTP/0.9 版本只要求返回消息体，没有响应消息头部定义 if self . request_version != 'HTTP/0.9' : self . wfile . write ( \" \\r\\n \" ) def log_request ( self , code = '-' , size = '-' ): # 打印请求信息 self . log_message ( '\" %s \" %s %s ' , self . requestline , str ( code ), str ( size )) def log_error ( self , format , * args ): # 打印错误信息，不过这里还是简单调用了 log_message 方法，进行标准输出了 # 规范的做法应该进行错误输出 self . log_message ( format , * args ) def log_message ( self , format , * args ): # 可重载，详见下面的说明 sys . stderr . write ( \" %s - - [ %s ] %s \\n \" % ( self . client_address [ 0 ], self . log_date_time_string (), format % args )) def version_string ( self ): return self . server_version + ' ' + self . sys_version def date_time_string ( self , timestamp = None ): # 当前的日期与时间字符串，用于响应消息头部中的 Date 字段 if timestamp is None : timestamp = time . time () year , month , day , hh , mm , ss , wd , y , z = time . gmtime ( timestamp ) s = \" %s , %02d %3s %4d %02d : %02d : %02d GMT\" % ( self . weekdayname [ wd ], day , self . monthname [ month ], year , hh , mm , ss ) return s def log_date_time_string ( self ): # 当前的时间，用于日志记录 now = time . time () year , month , day , hh , mm , ss , x , y , z = time . localtime ( now ) s = \" %02d / %3s / %04d %02d : %02d : %02d \" % ( day , self . monthname [ month ], year , hh , mm , ss ) return s weekdayname = [ 'Mon' , 'Tue' , 'Wed' , 'Thu' , 'Fri' , 'Sat' , 'Sun' ] monthname = [ None , 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' ] def address_string ( self ): # 获取客户端地址，用来进行日志记录。 # 此处可能会有 DNS 解析问题。 host , port = self . client_address [: 2 ] return socket . getfqdn ( host ) # Essentially static class variables # The version of the HTTP protocol we support. # Set this to HTTP/1.1 to enable automatic keepalive protocol_version = \"HTTP/1.0\" # The Message-like class used to parse headers MessageClass = mimetools . Message responses = { 100 : ( 'Continue' , 'Request received, please continue' ), ... ... 200 : ( 'OK' , 'Request fulfilled, document follows' ), ... ... 300 : ( 'Multiple Choices' , 'Object has several resources -- see URI list' ), ... ... 400 : ( 'Bad Request' , 'Bad request syntax or unsupported method' ), ... ... 500 : ( 'Internal Server Error' , 'Server got itself in trouble' ), ... ... } URL 长度限制 HTTP 协议规范里面貌似没有对 URL 的长度做出限制，但是各家浏览器以及 Web 服务器在实现时，都对 URL 的长度做了不同程序的限制。 本模块的代码也对 URL 的长度做了限制，大概 65530 左右的样子 ( 该值不确定，因为代码中只对第一行进行了长度判断 )。 打印日志的相关方法 上面的代码中有很多是有关打印日志的，该日志多用于调试。 其实这些方法最好单独整一个类出来存放，因为这方法并不是 BaseHTTPRequestHandler 的主要功能代码。 Warning 由于日志中会获取客户端的主机名等信息，可能会有 DNS 解析过慢的问题。 所以在正式使用时一定要关闭日志的输出功能，比如重载 log_message 方法。 1 2 def log_message ( self , format , * args ): pass responses 罗列了 RFC 2616 中定义的 HTTP 返回码及其说明。 其格式为 {HTTP 返回码 : ( 简短说明，详细说明 )}","tags":"Python","loc":"http://chenjiee815.github.io/basehttpserverbiao-zhun-ku-yuan-ma-xue-xi.html","title":"BaseHTTPServer标准库源码学习"},{"text":"Contents 简介 Server: 实现一个服务 MixIn: 让你的服务支持多线程 / 多进程 RequestHandler: 如何实现请求处理 未解决问题 _eintr_retry 慢系统调用 (slow system call) EINTR 错误的产生 Server BaseServer TCPServer allow_reuse_address socket 的 close&&shutdown close shutdown 总结 UDPServer get_request class UDPServer(TCPServer) MixIn ForkingMixIn os.waitpid(0, 0) os._exit ThreadingMixIn 其它 RequestHandler BaseRequestHandler StreamRequestHandler rbufsize&&wbufsize Nagle 算法 ECONNABORTED DatagramRequestHandler self.packet, self.socket = self.request 简介 本模块的代码基本分为以下三大块功能。 Server: 实现一个服务 Server 本身只负责搭建整个服务的框架。 至于服务本身如何处理客户端上来的请求，是通过 Server 绑定的 RequestHandler 来进行处理的。 本模块 Server 类的继承关系 +------------+ | BaseServer | +------------+ | v +-----------+ +------------------+ | TCPServer |------->| UnixStreamServer | +-----------+ +------------------+ | v +-----------+ +--------------------+ | UDPServer |------->| UnixDatagramServer | +-----------+ +--------------------+ MixIn: 让你的服务支持多线程 / 多进程 该模块的代码还用到了 Python 的高级编程技巧 Mixin。 如果你想让你的服务支持多线程 / 多进程，你可以使用如下代码： 1 2 3 4 5 class ThreadingTCPServer ( ThreadingMixIn , TCPServer ): pass class ThreadingUDPServer ( ThreadingMixIn , UDPServer ): pass 当然你真正使用时不需要写这些代码，它们已经在该模块内已经实现了。 Note ThreadingMixIn 会覆盖 TCPServer 、 UDPServer 某些特定的方法，以提供额外的多线程功能。 所以 ThreadingMixIn 必须要放在前面，这是由 Python 对于属性 / 方法的查找算法决定。 RequestHandler: 如何实现请求处理 本模块提供的 RequestHandler 基本有两种用法 。 继承 BaseRequestHandler 类，重载它的 handle() 方法， 直接使用本模块封装好的 StreamRequestHandler 和 DatagramRequestHandler , 并重载它的 handle() 方法。 未解决问题 目前无法处理带外 (out-of-band) 数据 Tip 我对此不是很了解，谁感兴趣可以自行 百度百科：带外数据 _eintr_retry 1 2 3 4 5 6 7 8 def _eintr_retry ( func , * args ): \"\"\" 忽略除 EINTR 错误外所有其它错误 \"\"\" while True : try : return func ( * args ) except ( OSError , select . error ) as e : if e . args [ 0 ] != errno . EINTR : raise 下面是搜索到的有关 EINTR 错误的一些说明。 慢系统调用 (slow system call) 此术语适用于那些可能永远阻塞的系统调用。 永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类。如：若没有客户连接到服务器上，那么服务器的 accept 调用就没有返回的保证。 EINTR 错误的产生 当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个 EINTR 错误。 例如：在 socket 服务器端，设置了信号捕获机制，有子进程，当在父进程阻塞于慢系统调用时由父进程捕获到了一个有效信号时，内核会致使 accept 返回一个 EINTR 错误 ( 被中断的系统调用 )。 当碰到 EINTR 错误的时候，可以采取有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。 例如：accept、read、write、select、和 open 之类的函数来说，是可以进行重启的。 不过对于套接字编程中的 connect 函数我们是不能重启的，若 connect 函数返回一个 EINTR 错误的时候，我们不能再次调用它，否则将立即返回一个错误。 针对 connect 不能重启的处理方法是，必须调用 select 来等待连接完成。 Server BaseServer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class BaseServer : timeout = None def __init__ ( self , server_address , RequestHandlerClass ): self . server_address = server_address # 服务绑定的地址 self . RequestHandlerClass = RequestHandlerClass # 处理请求的类 # 下面这两个属性主要用来给 self.shutdown 方法使用 self . __is_shut_down = threading . Event () # 服务结束通知 self . __shutdown_request = False # 服务已关闭的标志位 def server_activate ( self ): # 通过 `__init__` 调用，可被重载。 pass def serve_forever ( self , poll_interval = 0.5 ): \"\"\" 一直进行监听及处理请求操作，直到服务被关闭 self.timeout 对本方法不起作用，如果想使用 self.timeout，可以使用 handle_request \"\"\" self . __is_shut_down . clear () try : while not self . __shutdown_request : r , w , e = _eintr_retry ( select . select , [ self ], [], [], poll_interval ) if self in r : self . _handle_request_noblock () finally : self . __shutdown_request = False self . __is_shut_down . set () def shutdown ( self ): # 停止服务，该方法必须与 `serve_forever` 在不同的线程中调用，不然会造成死锁 self . __shutdown_request = True self . __is_shut_down . wait () def handle_request ( self ): # 处理请求，如果你不是使用 serve_forever 来启动服务的话， # 可以通过 handle_request 来定制自己处理服务的方式 timeout = self . socket . gettimeout () if timeout is None : timeout = self . timeout elif self . timeout is not None : timeout = min ( timeout , self . timeout ) fd_sets = _eintr_retry ( select . select , [ self ], [], [], timeout ) if not fd_sets [ 0 ]: self . handle_timeout () return self . _handle_request_noblock () def _handle_request_noblock ( self ): # 在调用本方法之前，已经确认有客户端连接上来， # 所以调用 self.get_request 方法时不会阻塞 try : request , client_address = self . get_request () except socket . error : return if self . verify_request ( request , client_address ): try : self . process_request ( request , client_address ) except : self . handle_error ( request , client_address ) self . shutdown_request ( request ) def handle_timeout ( self ): # 超时之后，还没有新的请求则会调用该方法。 pass def verify_request ( self , request , client_address ): # 对请求进行校验，如果校验成功，必须返回 True return True def process_request ( self , request , client_address ): # 处理请求 self . finish_request ( request , client_address ) self . shutdown_request ( request ) def server_close ( self ): # 用于服务停止后的后处理 pass def finish_request ( self , request , client_address ): self . RequestHandlerClass ( request , client_address , self ) def shutdown_request ( self , request ): self . close_request ( request ) def close_request ( self , request ): pass def handle_error ( self , request , client_address ): # 优雅地处理 error，可被重载。 # 默认的行为是打印出出错的异常信息，然后继续处理请求。 # 注意：print 输出的信息会输出到 stdout, 异常信息会输出到 stderr，蛋疼 print '-' * 40 print 'Exception happened during processing of request from' , print client_address import traceback traceback . print_exc () # 此处的信息会输出到 stderr print '-' * 40 TCPServer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class TCPServer ( BaseServer ): address_family = socket . AF_INET # TCP 对应的 socket 簇 socket_type = socket . SOCK_STREAM # TCP 对应的 socket 类型 request_queue_size = 5 # 等待连接队列的最大长度，术语 `backlog` allow_reuse_address = False def __init__ ( self , server_address , RequestHandlerClass , bind_and_activate = True ): BaseServer . __init__ ( self , server_address , RequestHandlerClass ) self . socket = socket . socket ( self . address_family , self . socket_type ) if bind_and_activate : # 是否在服务实例化是时就激活地址绑定及监听操作 self . server_bind () self . server_activate () def server_bind ( self ): \"\"\" 服务端 socket 地址绑定 \"\"\" if self . allow_reuse_address : self . socket . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) self . socket . bind ( self . server_address ) self . server_address = self . socket . getsockname () def server_activate ( self ): \"\"\" 服务端启用监听操作 \"\"\" self . socket . listen ( self . request_queue_size ) def server_close ( self ): self . socket . close () def fileno ( self ): \"\"\" 返回 socket 文件句柄数 给 `serve_forever` 中的 `select.select` 操作用 \"\"\" return self . socket . fileno () def get_request ( self ): \"\"\" 获取一个有请求需要处理的 socket\"\"\" return self . socket . accept () def shutdown_request ( self , request ): try : request . shutdown ( socket . SHUT_WR ) except socket . error : # 某些平台会抛出 `ENOTCONN` 异常 pass self . close_request ( request ) def close_request ( self , request ): request . close () allow_reuse_address 指示套接字是否应该重用地址。 在程序终止之后 , 如果需要在同一个端口立即重启服务器 , 那么该设置会很有用（其他情况下 , 你必须等待几分钟）。 socket 的 close&&shutdown close 1 2 3 #include<unistd.h> int close ( int fd ); 关闭本进程的 socketfd，但链接还是开着的，用这个 socketfd 的其它进程还能用这个链接，能读或写这个 socketfd。 shutdown 1 2 3 #include <sys/socket.h> int shutdown ( int sockfd , int how ); how 的方式有三种分别是 SHUT_RD（0）：关闭 sockfd 上的读功能，此选项将不允许 sockfd 进行读操作。 SHUT_WR（1）：关闭 sockfd 的写功能，此选项将不允许 sockfd 进行写操作。 SHUT_RDWR（2）：关闭 sockfd 的读写功能。 则破坏了 socket 连接，读的时候可能侦探到 EOF 结束符，写的时候可能会收到一个 SIGPIPE 信号，这个信号可能直到 socket buffer 被填充了才收到。 总结 shutdown 算是比较优雅（更细粒度）地关闭 socket 连接，但是不释放本地资源（socketfd）。 close 则比较简单粗暴一点，直接释放 socketfd。但它也不是立即释放 socketfd，socketfd 有一个引用计数的问题，当一个 socketfd 的引用计数为 0 时，系统才会进行释放。 UDPServer UDP 是面向无连接的 socket。 既然是无连接的，那就没有监控的操作，以及关闭连接的操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class UDPServer ( TCPServer ): allow_reuse_address = False socket_type = socket . SOCK_DGRAM # UDP 对应的 socket 类型 max_packet_size = 8192 # 每次接收数据的最大长度 def get_request ( self ): data , client_addr = self . socket . recvfrom ( self . max_packet_size ) return ( data , self . socket ), client_addr def server_activate ( self ): pass def shutdown_request ( self , request ): self . close_request ( request ) def close_request ( self , request ): pass get_request 该方法的返回值和 TCPServer 不一样。 它是在 Server 框架里面就获取到了数据，而不是在 RequestHandler 中来进行数据的获取。 具体原因下面的 DatagramRequestHandler 章节会有提到。 class UDPServer(TCPServer) 这种继承方式有点不合理，感觉是纯粹为了代码复用而进行的继承。 最好让 TCPServer 和 UDPServer 共同继承自同一个模板基类。 它们的相同代码全在模板类中，不同代码在各自的类中。 MixIn ForkingMixIn 使用多进程来处理请求，一个进程对应一个请求。 由于一个进程占用的系统资源比较多，且操作系统都会限制进程数，所以不能无限制的开启进程，代码中对应进程数进行了限制，不过这样也限制了在多进程模式下，并发处理请求的能力。 Note 该功能只支持 Unix 平台，在 Windows 上不可用，具体原因看下面的注释。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class ForkingMixIn : timeout = 300 active_children = None # 当前正在处理请求的子进程 PID 集合 max_children = 40 # 支持的最大并发请求数 def collect_children ( self ): \"\"\" 回收子进程 \"\"\" if self . active_children is None : return # 如果子进程数超过上限，则一直等待，直到子进程数低于上限 while len ( self . active_children ) >= self . max_children : # 阻塞模式：等待当前进程组的任何子进程的返回值， # 注意：不仅仅是通过 ForkingMixIn 生成的子进程。 try : pid , status = os . waitpid ( 0 , 0 ) except os . error : pid = None # 如果不是 ForkingMixIn 生成的子进程，则忽略掉 if pid not in self . active_children : continue self . active_children . remove ( pid ) # 下面代码主要是检查是否有已经退出的子进程，如果有则将之对应的保存的 pid 删除掉 # 作者在这里说，下面的代码中进行了太多次的系统调用， # 原本可以通过将所有子进程设置成一个进程组， # 然后只需要使用 os.waitpid(pgid) 获取该进程组内任意结束的子进程 ID， # 但是他没有办法获取到一个不冲突的进程组 ID。 # PS: 虽说对一个列表迭代时同时删除列表中的元素不是不可以， # 但是这样做太容易出错，一定要小心处理。 # 对一个字典边迭代边删除就会抛异常了，具体原因涉及到 Python 字典的实现原理，细节暂不表了。 for child in self . active_children : try : # 如果没有任何子进程退出则立即返回 (0, 0) # 有，则返回该子进程的 pid，及返回值 # 相当于非阻塞模式 pid , status = os . waitpid ( child , os . WNOHANG ) except os . error : pid = None if not pid : continue try : self . active_children . remove ( pid ) except ValueError , e : raise ValueError ( ' %s . x= %d and list= %r ' % ( e . message , pid , self . active_children )) def handle_timeout ( self ): self . collect_children () def process_request ( self , request , client_address ): self . collect_children () pid = os . fork () # fork 只在 Unix 平台上有效 if pid : # 父进程 if self . active_children is None : self . active_children = [] self . active_children . append ( pid ) self . close_request ( request ) # 父进程只负责生成子进程来处理请求，本身不会处理请求 return else : # 子进程 try : self . finish_request ( request , client_address ) self . shutdown_request ( request ) os . _exit ( 0 ) except : try : self . handle_error ( request , client_address ) self . shutdown_request ( request ) finally : os . _exit ( 1 ) # Python2.5 版本之前不支持 except/finally 同时使用 # 所以才有这种比较蛋疼的写法 os.waitpid(0, 0) 表示等待并获取当前进程组中的任何子进程的返回值。 关于该函数的具体说明参见 os.waitpid os._exit 它会将进程直接终止，之后的所有代码都不会继续执行。 该函数和 sys.exit 有点不一样， sys.exit 会抛出 SystemExit 异常，如果捕获该异常，Python 还是会继续执行捕获该异常的代码的。 具体可以参见： The difference between exit() and sys.exit() in python? ThreadingMixIn 使用线程来处理请求，一个请求对应一个线程。 线程相对进程来说比较轻量，所以代码里没有对应线程数进行控制，不过这里还是有问题的，如果短时间内有大量的并发请求，生成大量的线程，Python 会 Hold 不住，Python 的性能会急剧下降（大量的 CPU 时间用于线程切换了），到那时候基本就是拒绝服务了。 所以 ThreadingMinIn 多用于性能要求不高的环境，或者使用 gevent 来 monkey patch 一下，性能会有较大的提升。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ThreadingMixIn : # 可以设置该属性来决定当主线程退出时，处理请求的子线程是否也随之退出 daemon_threads = False def process_request_thread ( self , request , client_address ): try : self . finish_request ( request , client_address ) self . shutdown_request ( request ) except : self . handle_error ( request , client_address ) self . shutdown_request ( request ) # 此处不用 finally 来调用：self.shutdown_request(request) # 是因为 Python2.5 之前版本不支持 except && finally 同时使用。 def process_request ( self , request , client_address ): # 重载了 process_request 方法，生成一个线程来处理请求 t = threading . Thread ( target = self . process_request_thread , args = ( request , client_address )) t . daemon = self . daemon_threads t . start () 其它 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ForkingUDPServer ( ForkingMixIn , UDPServer ): pass class ForkingTCPServer ( ForkingMixIn , TCPServer ): pass class ThreadingUDPServer ( ThreadingMixIn , UDPServer ): pass class ThreadingTCPServer ( ThreadingMixIn , TCPServer ): pass if hasattr ( socket , 'AF_UNIX' ): # Windows 平台不支持 unix domain socket class UnixStreamServer ( TCPServer ): address_family = socket . AF_UNIX class UnixDatagramServer ( UDPServer ): address_family = socket . AF_UNIX class ThreadingUnixStreamServer ( ThreadingMixIn , UnixStreamServer ): pass class ThreadingUnixDatagramServer ( ThreadingMixIn , UnixDatagramServer ): pass 该模块提供了现成的支持多线程 / 多进程的服务类，但是当你使用基于 TCP/UDP 的上层协议的服务类时， 为了要支持多线程 / 多进程，你还是要自己手写的。 1 2 3 4 from SimpleXMLRPCServer import SimpleXMLRPCServer class ThreadXMLRPCServer ( ThreadingMixIn , SimpleXMLRPCServer ): pass RequestHandler BaseRequestHandler 定义了基本的请求处理框架。 StreamRequestHandler 和 DatagramRequestHandler 都将 socket 的数据读写操作抽象成了文件的读写。 BaseRequestHandler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BaseRequestHandler : def __init__ ( self , request , client_address , server ): self . request = request self . client_address = client_address self . server = server self . setup () try : self . handle () finally : self . finish () def setup ( self ): pass def handle ( self ): pass def finish ( self ): pass StreamRequestHandler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class StreamRequestHandler ( BaseRequestHandler ): rbufsize = - 1 # 默认有缓存 wbufsize = 0 # 默认无缓存 timeout = None # Nagle 算法开关，最好仅在 wbufsize != 0 时打开，用来避免传递大量小的数据包。 disable_nagle_algorithm = False def setup ( self ): self . connection = self . request if self . timeout is not None : self . connection . settimeout ( self . timeout ) if self . disable_nagle_algorithm : self . connection . setsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY , True ) self . rfile = self . connection . makefile ( 'rb' , self . rbufsize ) self . wfile = self . connection . makefile ( 'wb' , self . wbufsize ) def finish ( self ): if not self . wfile . closed : try : self . wfile . flush () except socket . error : # socket 结束时可能会有错误发生，比如 `ECONNABORTED` pass self . wfile . close () self . rfile . close () rbufsize&&wbufsize rbufsize: 如果读取大量数据时，没有缓存会导致处理速度很慢。 wbufsize: 在写入大量数据时，底层的 stdio 会进行优化。 Nagle 算法 TCP/IP 协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送 ACK 表示确认。为了尽可能的利用网络带宽，TCP 总是希望尽可能的发送足够大的数据。（一个连接会设置 MSS 参数，因此，TCP/IP 希望每次都能够以 MSS 尺寸的数据块来发送数据）。 Nagle 算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。 想具体了解该算法请参见 Nagle 算法 ECONNABORTED 该错误被描述为 \"software caused connection abort\"，即 \" 软件引起的连接中止 \"。 原因在于当服务和客户进程在完成用于 TCP 连接的 \" 三次握手 \" 后，客户 TCP 却发送了一个 RST （复位）分节，在服务进程看来，就在该连接已由 TCP 排队，等着服务进程调用 accept 的时候 RST 却到达了。POSIX 规定此时的 errno 值必须 ECONNABORTED。 源自 Berkeley 的实现完全在内核中处理中止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用 accept。 DatagramRequestHandler 1 2 3 4 5 6 7 8 9 10 11 12 13 class DatagramRequestHandler ( BaseRequestHandler ): def setup ( self ): try : from cStringIO import StringIO except ImportError : from StringIO import StringIO self . packet , self . socket = self . request self . rfile = StringIO ( self . packet ) self . wfile = StringIO () def finish ( self ): self . socket . sendto ( self . wfile . getvalue (), self . client_address ) self.packet, self.socket = self.request 这里的 self.request 对象是一个元组，第一个是从 self.socket 中获取的数据，第二个为 self.socket。 至于为什么不在 DatagramRequestHandler 中直接获取数据，作者在注释里作了如下说明 : # XXX Regrettably, I cannot get this working on Linux; # s.recvfrom() doesn't return a meaningful client address.","tags":"Python","loc":"http://chenjiee815.github.io/socketserverbiao-zhun-ku-yuan-ma-xue-xi.html","title":"SocketServer标准库源码学习"},{"text":"Contents distutils distutils2 setuptools distribute easy_install pip pypiserver devpi 目前 Python 官方有一个专门的小组来负责 Python 打包的相关事宜。 该小组的名称叫做 : Python Packaging Authority (PyPA) PyPA 小组的项目主页在 Github PyPA 和 Bitbucket PyPA 上都有。 Note 这两个项目主页是不一样的，分管不同的工具集 / 项目。 PyPA 小组还维护一份官方文档 Python Packaging User Guide ，如果读者有兴趣对 Python 的打包进行深入了解，可以参考该文档。 distutils 该跨平台的打包与发布工具是在 2000 年底时加入到 Python 标准库的，目前属于 Python 官方的打包工具。 但是由于它加入的时间太久远了，同时也未跟上时代的发展，所以目前它只适用于非常简单的应用场景。 distutils2 它本来应该成为 Python3 的标准库 packaging 。 Tip 在其它 Python 版本里叫做 distutils2 。 该项目在 2012 年已经停止了，官方文档建议使用 setuptools + pip，以下为原文： tl;dr: keep using setuptools and pip for now, don't use distutils2. 至于为什么会被停止，可以查看 Status of packaging in 3.3 setuptools setuptools 是对 distutils 的增强 , 尤其是引入了包依赖管理。 setuptools 可以为 Python 包创建 egg 文件。 包含包目录内的数据文件。 自动包含包目录内的所有的包，而不用在 setup.py 中列举。 自动包含包内和发布有关的所有相关文件，而不用创建一个 MANIFEST.in 文件。 自动生成经过包装的脚本或 Windows 执行文件。 支持 Pyrex，即在可以 setup.py 中列出 .pyx 文件，而最终用户无须安装 Pyrex。 支持上传到 PyPI。 可以部署开发模式，使项目在 sys.path 中。 用新命令或 setup() 参数扩展 distutils，为多个项目发布 / 重用扩展。 基本满足大型项目的安装和发布。 setuptools 还有很多强大且优秀的功能，具体可参见其官方文档 Setuptools Docmentation distribute 由于 setuptools 初期开发进度缓慢 , 不支持 Python3, 代码混乱 , 一帮程序员另起炉灶 , fork 并且重构 setuptools 代码 , 增加功能。 然后 2013 年 8 月，distribute 又合并回 setuptools 0.7，并且不再进行维护了。 以下为官方文档中的原话 : Distribute is a deprecated fork of the Setuptools project. Since the Setuptools 0.7 release, Setuptools and Distribute have merged and Distribute is no longer being maintained. All ongoing effort should reference the Setuptools project and the Setuptools documentation. easy_install setuptools 和 distribute 自带的安装脚本。 只支持从 PyPI 下载安装 Python 包。 pip pip 的目标非常明确：取代 easy_install。 支持安装、卸载包。 支持从任意能够通过 VCS 或浏览器访问到的地址安装 Python 包。 pip 的功能也是同样优秀且强大的，具体可参见其官方文档 PIP Documentation pypiserver 它是一个适配 PyPI 的最小集服务器。 如果你想要自己搭建一个简单的 PyPI 服务器，用它最适合不过了。 1 2 3 4 5 6 7 $ pip install pypiserver $ mkdir ~/packages $ # 将 Python 包复制到 ~/packages 目录中 $ pypi-server -p 8080 ~/packages 通过以上的步骤，就搭建了一个 PyPI 服务器了，从该服务器安装 Python 包也很简单。 1 $ pip install -i http://localhost:8080/simple/ 包的名称 想进一步了解可参见 pypiserver documentaton devpi devpi 相对于 pypiserver 来说，功能更丰富，可以说是 pypiserver 的超集。 当启动 devpi 服务后，你可以直接指定 pip 通过 devpi 服务来进行 Python 包的安装。 1 2 3 4 5 $ pip install -q -U devpi-server $ devpi-server --start $ pip install -i http://localhost:3141/root/pypi/ simplejson devpi 会自从其它 PyPI 服务器（默认为官方服务器）来下载 Python 包，并缓存下来。 当它处在离线状态时，它会直接将缓存中的 Python 包反馈给你。 当它牌在线状态时，它会自动在后台更新缓存的中的 Python 包，并将最新的 Python 包反馈给你。 当然上面只是对它作的一个简单的介绍，更多功能请参见其官方文档 devpi documentation","tags":"python","loc":"http://chenjiee815.github.io/pythonda-bao-jian-jie.html","title":"Python打包简介"},{"text":"Contents list.sort, dict.update 返回啥？ tuple 的创建，不是少个逗号么 装饰过后了，我的 func_name 呢？ bool(gevent.spawn(lambda: True)): True? or False? 自定义异常无法正常 Pickle 反序列化 json.loads(json.dumps({1: 2})) == {1: 2}? str.encode([encoding[, errors]]) 中的关键字参数 list.sort, dict.update 返回啥？ 1 2 3 4 5 6 7 def aa (): a = [ 2 , 8 , 3 , 1 , 6 , 4 ] return a . sort () def bb (): b = { 1 : 2 , 3 : 4 , 5 : 6 } return b . update ({ 7 : 8 }) 好吧，虽说我用 Python 也不少年头了，但是最近还是犯上面例子中的错误。 虽然我知道他们会修改值本身的内容，而我却想当然以为它们会将修改后的值返回出来，但现实是很残酷的，它们都返回 None。 1 2 3 4 5 In [ 10 ]: print [ 4 , 2 , 3 ] . sort () None In [ 11 ]: print { \"a\" : 1 , \"b\" : 2 } . update ({ \"c\" : 3 }) None tuple 的创建，不是少个逗号么 1 2 3 4 5 6 7 8 In [ 36 ]: a = (); type ( a ) Out [ 36 ]: tuple In [ 37 ]: a = ( 1 ); type ( a ) Out [ 37 ]: int In [ 38 ]: a = ( 1 ,); type ( a ) Out [ 38 ]: tuple 在 Python 中，括号的功能主要是来进行组合的，而不是用来创建元组的。比如： 1 2 In [ 47 ]: a = ( \"first;\" \"second;\" ); a Out [ 47 ]: 'first;second;' 装饰过后了，我的 func_name 呢？ Python 中不仅可以使用自带的 @staticmethod 等来进行装饰，还可以自己写装饰器来进行装饰。 但是装饰完的函数还是原来的函数么？ 1 2 3 4 5 6 7 8 9 10 11 def wrapper ( func ): def _wrapper ( * args , ** kwargs ): return func ( * args , ** kwargs ) return _wrapper def aa (): return \"aa\" @wrapper def bb (): return \"bb\" 1 2 3 4 5 In [ 11 ]: aa . func_name Out [ 11 ]: 'aa' In [ 12 ]: bb . func_name Out [ 12 ]: '_wrapper' 经过装饰的函数，它的 func_name 已经发生了变化，说明它已经不是原来的函数定义了。 那么如何解决经过装饰的函数还拥有原来的一此属性呢？ 使用 functools.wraps 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import functools def wrapper ( func ): @functools.wraps ( func ) def _wrapper ( * args , ** kwargs ): return func ( * args , ** kwargs ) return _wrapper def aa (): return \"aa\" @wrapper def bb (): return \"bb\" 1 2 3 4 5 In [ 11 ]: aa . func_name Out [ 11 ]: 'aa' In [ 12 ]: bb . func_name Out [ 12 ]: 'bb' Tip 如果某个函数之间已经装饰过了，然后改变装饰器，则原来的函数仍然是使用改变之前的装饰器。 bool(gevent.spawn(lambda: True)): True? or False? 1 2 3 4 5 6 def aa (): return \"aa\" aa_spawn = None aa_spawn = gevent . spawn ( aa ) print bool ( aa_spawn ) == True 上面的代码最后结果是 True 么？ 是 好，咱们接着看。 1 2 3 4 5 6 7 def aa (): return \"aa\" aa_spawn = None aa_spawn = gevent . spawn ( aa ) aa_spawn . join () print bool ( aa_spawn ) == True 上面的代码最后结果是 True 么？ 难道不是么，我 X，还真不是。 怎么回事啊？ 这个就要看 bool 函数的内部判断逻辑了。 以下情况会被认为是 False，其他的情况是 True。 None False zero of any numeric type, for example, 0, 0L, 0.0, 0j. any empty sequence, for example, '', (), []. any empty mapping, for example, {}. instances of user-defined classes, if the class defines a __nonzero__() or __len__() method, when that method returns the integer zero or bool value False. 这时候咱们再看一下 aa_spawn 这个对象。 1 2 3 4 5 6 7 8 9 10 In [ 25 ]: dir ( aa_spawn ) Out [ 25 ]: [ 'GreenletExit' , '__class__' , ... ... '__module__' , '__new__' , '__nonzero__' , '__reduce__' , ... ... ] 哦，我看到 __nonzero__ 这个属性了。当 gevent.greenlet 对象还没运行时，该属性为 True ，但当它执行完了，该属性就会变成 False 了。 SO，判断一个对象是否为真，千万要小心使用诸如以下形式的自动判断啊： 1 2 3 4 5 6 if some_instance : do_something () some_instance and do_something () some_instance or do_something () 自定义异常无法正常 Pickle 反序列化 我们先来定义一个自定义异常 MyError 1 2 3 4 5 6 7 8 class MyError ( Exception ): def __init__ ( self , desc ): super ( MyError , self ) . __init__ () self . __desc = desc def __str__ ( self ): return \"MyError: {}\" . format ( self . __desc ) 接下来咱们序列化一下： 1 2 3 4 5 6 In [ 10 ]: import pickle In [ 11 ]: p = pickle . loads ( e ) In [ 12 ]: p Out [ 12 ]: \"c__main__ \\n MyError \\n p0 \\n (tRp1 \\n (dp2 \\n S'_MyError__desc' \\n p3 \\n S'saifsdf' \\n p4 \\n sb.\" 貌似序列化成功了，接下咱们再反序列化一下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 In [ 16 ]: pickle . loads ( p ) --------------------------------------------------------------------------- TypeError Traceback ( most recent call last ) < ipython - input - 18 - 6 aaee2b1d950 > in < module > () ----> 1 pickle . loads ( p ) / usr / lib / python2 . 7 / pickle . pyc in loads ( str ) 1380 def loads ( str ): 1381 file = StringIO ( str ) -> 1382 return Unpickler ( file ) . load () 1383 1384 # Doctest / usr / lib / python2 . 7 / pickle . pyc in load ( self ) 856 while 1 : 857 key = read ( 1 ) --> 858 dispatch [ key ]( self ) 859 except _Stop , stopinst : 860 return stopinst . value / usr / lib / python2 . 7 / pickle . pyc in load_reduce ( self ) 1131 args = stack . pop () 1132 func = stack [ - 1 ] -> 1133 value = func ( * args ) 1134 stack [ - 1 ] = value 1135 dispatch [ REDUCE ] = load_reduce TypeError : __init__ () takes exactly 2 arguments ( 1 given ) 好家伙，出现这么信息，竟然异常了。 好吧，有问题，查看官方网站 pickle 文档 。 pickle 只能序列化和反序列化以下类型： None, True, and False integers, long integers, floating point numbers, complex numbers normal and Unicode strings tuples, lists, sets, and dictionaries containing only picklable objects functions defined at the top level of a module built-in functions defined at the top level of a module classes that are defined at the top level of a module instances of such classes whose __dict__ or the result of calling __getstate__() is picklable(see section The pickle protocol for details). 按照以上定义没有问题啊， MyError 符合其中第 7 条的要求。事实也是可以序列化，但不能反序列化。好吧，继续看官方文档。 Pickling and unpickling extension types object.__reduce__() When the Pickler encounters an object of a type it knows nothing about — such as an extension type — it looks in two places for a hint of how to pickle it. One alternative is for the object to implement a __reduce__() method. If provided, at pickling time __reduce__() will be called with no arguments, and it must return either a string or a tuple. 原来 pickle 对自定义异常 一无所知 。所以咱们需要在某个地方告诉它应该怎么序列化和反序列化。 1 2 3 4 5 6 7 8 9 10 11 class MyError ( Exception ): def __init__ ( self , desc ): super ( MyError , self ) . __init__ () self . __desc = desc def __str__ ( self ): return \"MyError: {}\" . format ( self . __desc ) def __reduce__ ( self ): return ( MyError , ( self . __desc ,)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [ 10 ]: import pickle In [ 20 ]: e = MyError ( \"error\" ) In [ 21 ]: p = pickle . dumps ( e ) In [ 24 ]: p Out [ 24 ]: \"c__main__ \\n MyError \\n p0 \\n (S'error' \\n p1 \\n tp2 \\n Rp3 \\n .\" In [ 28 ]: pickle . loads ( p ) Out [ 28 ]: __main__ . MyError () In [ 29 ]: c = pickle . loads ( p ) In [ 30 ]: str ( c ) Out [ 30 ]: 'MyError: error' json.loads(json.dumps({1: 2})) == {1: 2}? 1 2 3 4 5 6 In [ 4 ]: import json In [ 5 ]: a = { 1 : 2 } In [ 7 ]: json . loads ( json . dumps ( a )) == a Out [ 7 ]: False 奇怪，序列化 + 反序列化前后不应该一样么？ 好吧，我们看一下，JSON 序列化再反序列化的数据是什么样本？ 1 2 In [ 6 ]: json . loads ( json . dumps ( a )) Out [ 6 ]: { u'1' : 2 } 字典的 Key 值由原来的数值类型变成了字符串类型。 JSON 为什么会有这种奇怪的行为？ 我们来看一下 JSON 中文网 的 JSON 格式说明。 原来 JSON 语法规定：一个键值对的集合（Python 叫字典），其键必须为 string（字符串）。（JSON 作为一种数据交换格式，可能需要考虑兼容性， 不是所有语言都支持键为数值类型） 好吧，这种情况我只能 Orz... str.encode([encoding[, errors]]) 中的关键字参数 在 Python2.6 上面，它的执行结果如下： 1 2 3 4 5 6 7 8 9 10 11 12 In [ 10 ]: s = u\"abc\" In [ 11 ]: s . encode ( \"utf-8\" , errors = \"ignore\" ) --------------------------------------------------------------------------- TypeError Traceback ( most recent call last ) < ipython - input - 11 - a702e9e976da > in < module > () ----> 1 s . encode ( \"utf-8\" , errors = \"ignore\" ) TypeError : encode () takes no keyword arguments In [ 12 ]: s . encode ( \"utf-8\" , \"ignore\" ) Out [ 12 ]: 'abc' 在 Python2.7 上面，它的执行结果如下： 1 2 3 4 In [ 9 ]: s = u\"abc\" In [ 10 ]: s . encode ( \"utf-8\" , errors = \"ignore\" ) Out [ 10 ]: 'abc' Python2.7 才支持关键字参数。具体可参见 str.encode ，str.decode 也是一样的。 我在 Google 搜索了一下，看来被这个坑的，还不止我一个，哈哈。","tags":"python","loc":"http://chenjiee815.github.io/na-xie-nian-wo-men-cai-guo-de-gen-pythonyou-guan-de-keng-chi-xu-geng-xin.html","title":"那些年我们踩过的跟Python有关的坑（持续更新）"},{"text":"Contents 接口参数 通用参数 各式各样的参数 弃用参数 Note 此处只列出了 CPython 实现版本支持的命令行参数，其它实现版本请查看其官方文档。 Python 命令行调用的基本格式如下： 1 $ python [ -BdEiOQsRStuUvVWxX3? ] [ -c command | -m module-name | script | - ] [ args ] 接口参数 用来指定不同的方式调用 Python 代码。 -c <command> 直接将 Python 代码作为 <command> 来执行。 -m <module-name> 查找 sys.path 中指定的模块名并执行其 __main__ 模块中的代码。 Note 无法用来指定 Python 内置模块和其它语言编写的 Python 扩展模块。 - 从标准输入读入 Python 代码。 <script> 指定执行某个含有 Python 代码的文件或者包含 __main__.py 文件的目录 /Zip 包。 通用参数 -? -h --help 打印帮助信息 -V --version 打印版本信息 各式各样的参数 -B 在导入源码模块时不生成 .pyc 或 .pyo 文件。 -d 打开调试信息输出。 -E 忽略所有的 Python 环境变量。 -i 强制 Python 以交互式模式启动，即使以 -c 或者 <script> 模式启动。 -O 打开最基本的编译优化。-OO: 进一步优化，忽略 docstrings 。 -Q <arg> 控制 Python 的除法行为。<arg> 为下面四个值之一： old, 默认值，int/int == int, long/long == log new, int/int == float, long/long == flat warn, 和 old 一样，但是有 warning 提示。 warnall, 对所有的除法行为都有 warning 提示。 1 2 3 4 5 6 7 8 9 $ python -Q new Python 2.7.5+ (default, Feb 27 2014, 19:39:55) [GCC 4.8.1] on linux2 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> 1 / 1 1.0 >>> 2334534543534534234234234234 / 134323435345456456576575654534 0.01737994965309306 >>> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ python -Q warnall Python 2.7.5+ (default, Feb 27 2014, 19:39:55) [GCC 4.8.1] on linux2 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> 1. 1 File \"<stdin>\" , line 1 1. 1 &#94; SyntaxError : invalid syntax >>> 1 / 1 __main__:1: DeprecationWarning: classic int division 1 >>> 1.0 / 1 __main__:1: DeprecationWarning: classic float division 1.0 -r 使用随机值在生成不可以变对象的 Hash。 -s 不会将用户的 site-packages 添加到 sys.path 中。 -S 忽略导入 site 模块和操作 sys.path 所依赖的模块。多用于受限的环境。 -t 如果 Python 代码中混用了 TAB 和空格来进行缩进，则进行 warning 提示。 -tt: 进行 error 提示。 -u 强制使 stdin/stdout/stderr 不进行缓存操作。 -v 显示调试信息。-vv 显示更多的调试信息。 -W arg 告警控制。Python 默认的告警提示输出到 stderr，其一般格式为： file:line : category: message arg 的值为以下值其中之一： ignore, 忽略所有告警提示 default, 每一行源码打印一个告警 all, 每次出现告警都打印 module, 每种告警在某模块中第一次出现时打印 once, 每种告警仅打印一次 error, 抛出异常，而不是打印出 warning 提示 Tip 也可以通过 warings 模块来进行告警控制。 -x 忽略源码的第一行。 Note 一般第一行为 #!/user/bin/env python， 多用于 DOS 系统。 -3 当在 Python2 中使用 Python3 中移除或者显著改变的特性时，进行 DeprecationWarning 提示。 弃用参数 -J 用来调用 Jython -U 将所有字符串都当作 unicode 字符串来处理。但不建议这么用。 最好在代码中使用 from __future__ import unicode_literals -X 调用其它的 Python 实现版本。","tags":"python","loc":"http://chenjiee815.github.io/pythonming-ling-xing-can-shu.html","title":"Python命令行参数"},{"text":"Contents 普通环境变量 PYTHONHOME PYTHONPATH PYTHONSTARTUP PYTHONY2K PYTHONOPTIMIZE PYTHONDEBUG PYTHONINSPECT PYTHONUNBUFFERED PYTHONVERBOSE PYTHONCASEOK PYTHONDONTWRITEBYTECODE PYTHONHASHSEED PYTHONIOENCODING PYTHONNOUSERSITE PYTHONUSERBASE PYTHONEXECUTABLE PYTHONWARNINGS 调试模式下的环境变量 PYTHONTHREADDEBUG PYTHONDUMPREFS PYTHONMALLOCSTATS Python 即可以通过命令行参数，也可以通过环境变量来进行定制。 命令行参数的优先级比较环境变量高。 当使用 -E 参数时，所有的环境变量都会忽略掉。 如果某个环境变量和命令行参数冲突，以命令行参数为准。 Note 此处只列出了 CPython 实现版本支持的环境变量，其它实现版本请查看其官方文档。 普通环境变量 PYTHONHOME 定制 Python 标准库的路径。 在默认情况下，Python 会查找 prefix/lib/pythonversion 和 exec_prefix/lib/pythonversion 。 prefix 和 exec_prefix 由你的安装环境决定。在 Unix 系统上一般情况下为 /usr/local 。 如果 PYTHONHOME 被设置为单个目录，那么 prefix 和 exec_prefix 都会被设定为该目录。 如果分别设定这两个值，可以使用 prefix:exec_prefix 格式来设定 PYTHONHOME 。 Tip 如果想定制一个受限的 Python 环境，可以将某些标准库文件链接到某个特定目录，然后将该目录作为受限 Python 环境的 PYTHONHOME 。 PYTHONPATH 默认的 Python 模块搜索路径。 它的格式和系统的 PATH 是一样，可以指定多个路径，每个路径可以包含纯 Python 实现的 zip 包，但不支持其它语言实现的 zip 包。 PYTHONHOME 指定的路径总是会自动添加到 PYTHONPATH 中。 PYTHONSTARTUP 如果该值为一个可读的文件，在 Python 命令行模式下，该文件中的 Python 代码会在交互式界面出来之前执行一遍。 Tip 主要可用来对自己的 Python 的交互式环境进行一下定制什么的。 比如设置一下 sys.ps1 和 sys.ps2 来定制自己的命令行提示符。 或者添加如下代码： 1 2 3 4 import rlcompleter import readline readline . parse_and_bind ( \"tab: complete\" ) 可以让你的命令行支持 TAB 键功能（PS： 用 IPython 更爽一些 ）。 PYTHONY2K 默认情况下 time 模块中如果有函数需要指定年参数时，可以为 4 位，也可以为 2 位。 如果为 2 位，Python 会自动按照一定的规则进行转换。具体可以查看 time 模块官方文档 。 如果该值被设定了， time.accept2dyear 值就会变成 0，默认为 1。 这样会导致 time 模块中如果有函数需要指定年参数时，必须要求为 4 位。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 In [ 2 ]: time . mktime (( 12 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 )) --------------------------------------------------------------------------- ValueError Traceback ( most recent call last ) < ipython - input - 2 - 7e161 cf670eb > in < module > () ----> 1 time . mktime (( 12 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 )) ValueError : year >= 1900 required In [ 3 ]: time . accept2dyear Out [ 3 ]: 0 In [ 4 ]: time . accept2dyear = 1 In [ 5 ]: time . mktime (( 12 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 )) Out [ 5 ]: 1325350861.0 PYTHONOPTIMIZE 用于 Python 性能优化。 如果该环境变量被设定为一个非空字符串，就相当于 -O 命令行参数。 如果该环境变量被设定为一个数字 N，就相当于 -OO （O 的个数为 N）命令行参数。 PYTHONDEBUG 用于 Python 调试。 如果该环境变量被设定为一个非空字符串，就相当于 -d 命令行参数。 如果该环境变量被设定为一个数字 N, 就相当于 -dd (d 的个数为 N) 命令行参数。 PYTHONINSPECT 如果该环境变量被设定为一个非空字符串，就相当于 -i 命令行参数。 PYTHONUNBUFFERED 如果该环境变量被设定为一个非空字符串，就相当于 -u 命令行参数。 PYTHONVERBOSE 如果该环境变量被设定为一个非空字符串，就相当于 -v 命令行参数。 如果该环境变量被设定为一个数字 N, 就相当于 -vv (v 的个数为 N) 命令行参数。 PYTHONCASEOK 如果该环境变量被设定了，Python 会在 import 模块时忽略模块名的大小写。 Tip 此值只在 Windows, OS X, OS/2, and RiscOS 上有效。 PYTHONDONTWRITEBYTECODE 如果该环境变量被设定了，Python 不会在导入源码模块时生成 .pyc 或 .pyo 文件。 相当于 -B 命令行参数。 PYTHONHASHSEED 如果该环境变量被设定为 random ，相当于 -R 命令行参数。 Python 会用一个随机的种子来生成 str/bytes/datetime 对象的 hash 值。 如果该环境变量被设定为一个数字，它就被当作一个固定的种子来生成 str/bytes/datetime 对象的 hash 值。 Note 该环境变量的目的是允许生成重复的 Hash， 这样可以用来进行 Python 解释器的自测， 或者允许 Python 进程的子进程能够分享同样的 hash 值。 Tip 如果为数字，该数字范围为 [0,4294967295] PYTHONIOENCODING 设定 stdin/stdout/stderr 的默认编码格式。 其格式为： encodingname:errorhandler :errorhandler 是可选的，它的意思类似于 str.encode() 中的 errors 参数。 PYTHONNOUSERSITE 如果该环境变量被设定了，Python 不会将用户的 site-packages 添加到 sys.path 中。 PYTHONUSERBASE 用于设定用户主目录，根据用户主目录可推知用户的 site-packages 目录，以及使用 python setup.py install --user 时的安装目录。 PYTHONEXECUTABLE 如果该环境变量被设定了， sys.argv[0] 就会为该环境变量的值。 Tip 该环境变量只在 Mac OS X 上有效。 PYTHONWARNINGS 如果该环境变量被设定为一个非空字符串，就相当于 -W 命令行参数。 如果该环境变量被设定为一个数字 N, 就相当于 -WW (W 的个数为 N) 命令行参数。 调试模式下的环境变量 以下的环境变量只有在 DEBUG 编译版本的 Python 下才可起作用 （Debug 编译版本：在编译 Python 时，使用 --with-pydebug 参数）。 PYTHONTHREADDEBUG 如果该值被设定了，Python 将会打印出线程调试信息。 该值的名称在 Python2.6 之前为 THREADDEBUG 。 1 2 3 4 >>> a = 1 PyThread_acquire_lock(0x8467e00, 1) called PyThread_acquire_lock(0x8467e00, 1) -> 1 PyThread_release_lock(0x8467e00) called 上面就是设定该值后一个简单的赋值操作引起的线程操作信息。 PyThread_acquire_lock 是获取 GIL 操作。 PyThread_release_lock 是释放 GIL 操作。 PYTHONDUMPREFS 当该值被设定了，Python 会在解释器退出时打印出当前仍然存活的对象以及其引用计数。 我试一下， Python2.7.8 的输出格式为： 内存地址 [ 引用计数 ] 对象类型 PYTHONMALLOCSTATS 当该值被设定了，Python 将会打印每个新的 object arena 在生成时的内存分配统计，同时在退出解释器时也会打印出内存分配统计。 Tip object arena 不知道啥意思，自己试了，网上查了也不知道是啥。","tags":"python","loc":"http://chenjiee815.github.io/pythonhuan-jing-bian-liang.html","title":"Python环境变量"},{"text":"Contents next unicode iter memoryview NotImplemented 与 NotImplementedError NotImplemented NotImplementedError 真值判断 () 的用法 1.bit_length() 为啥会报错？ 获取当前模块对象 startswith&&endswith 这里记录的是我用 Python 几年以来，觉得大家可能会忽略的的小知识点（好吧，也有可能只是我自己忽略的小知识点）。 next next 是 Python 提供的一个 Built-in 函数。 提到 next，大家可能都会想到 Python 中的迭代协议中就有要求实现一个 next 方法。 那这个函数的功能也是作用于一个迭代器的。 1 next ( iterator [, default ]) 看到它的函数签名了么，有一个 default 可选参数，这个就是我想要讲的重点。 next 在检索一个迭代器（不是一个可迭代的对象）时，会调用它的 next() 方法， 但当迭代器迭代结束时，如果提供了 default 参数，next 函数会返回 default, 如果没有，则直接抛出 StopIteration 异常。 Note 注意我上面所强调的 迭代器 和 可迭代对象 的区分。 它对应的 Python 代码实现如下（实际上以 C 语言实现）： 1 2 3 4 5 6 7 8 9 onlyone = Object () def next ( iterator , default = onlyone ): try : return iterator . next () except StopIteration : if default != onlyone : return default else : raise StopIteration 我想要的就是永远不要一个迭代器抛出 StopIteration 异常。 比如下面这种使用场景（来自 string 标准库源码学习）： 1 2 3 4 5 6 7 8 9 10 11 _ASCII_COUNT = 256 _IDMAP = [ chr ( n ) for n in xrange ( _ASCII_COUNT )] def maketrans ( fromstr , tostr ): if len ( fromstr ) != len ( tostr ): raise ValueError , \"maketrans arguments must have same length\" frm_to = zip ( fromstr , tostr ) # 如果字符 C 在 fromstr 中，则替换为 tostr 中对应 index 的字符 # 否则返回字符 C 本身 sub_c = lambda c : next (( t for f , t in frm_to if f == c ), c ) return '' . join (( sub_c ( c ) for c in _IDMAP )) 我就是想要 (t for f, t in frm_to if f == c) 这个生成器（迭代器之一），在 f == c 时立即给我返回值，如果没有则直接返回 c 。 这种情况，正常的 for 格式代码很容易实现： 1 2 3 4 5 6 def sub_c ( c ): for f , t in frm_to : if f == c : return t else : return c 但有些人就是有点小强迫症（比如我）：一行可实现的代码，干嘛写那么啰嗦。 unicode 嗯，这也是一个 Python 的内置函数。函数签名如下： 1 2 unicode ( object = '' ) unicode ( object [, encoding [, errors ]]) 我想要讲还是 unicode 的可选参数 errors 。 errors 这个可选参数有三个值 strict 、 ignore 、 replace 当我们用 unicode 函数将一个对象转换成 unicode 字符串时，如果遇到无法解析的字符，unicode 就会根据 errors 的值来决定如何处理该异常。 strict 默认的行为，直接抛出 ValueError ingore 忽略无法解析的字符，并继续解析 replace 用 U+FFFD 来代替该字符，并继续解析 Tip 一个字符串的 decode 方法和 encode 方法也支持 errors 参数。 iter 还是 Python 的内置函数，直接看它的签名。 1 2 iter ( collection ) -> iterator iter ( callable , sentinel ) -> iterator 第一种用法大家应该都了解的，这里我想说一下第二种用法。 iter 函数会不停地调用第一个参数 callable，直到该 callable 的返回值等于 sentinel（哨兵），它就会抛出 StopIteration 异常。 该用法很类似于 itertools.takewhile 。 memoryview 这个类是在 Python2.7 中才加入的。 这个类可以用来访问一个支持 buffer 协议的对象的内部数据，而不需要拷贝这些数据。可以用在对内存比较敏感的地方。 目前 Python 内置的支持 buffer 协议的有 str 和 bytearry。 比如： 1 2 3 4 5 6 str_a = \"abcdefg\" mem_a = memoryview ( str_a ) tag = \"bcdefg\" print str_a [ 1 :] == tag # 第 1 种情况 print mem_a [ 1 :] == tag # 第 2 种情况 第 1 种情况 Python 会使用切片操作生成一个字符串 \"bcdefg\" ，然后再跟 tag 进行比较。 第 2 种情况 Python 只会生成一个新的 memoryview 对象再然后再跟 tag 进行比较。该新的 memoryview 对象本质是对 str_a 的 bcdefg 段的引用，并不生成新的字符串。 NotImplemented 与 NotImplementedError NotImplemented 为一个内置的常量。 常用于 \" 富比较 \" 的特殊方法（ __eq__ 、 __lt__ 等其它方法）的返回值，用于说明该方法未实现。 NotImplementedError 为一个内置异常，是从 RuntimeError 继承的。 多用于用户自定义的抽象方法中，用户可以在自定义的抽象方法中抛出该异常，要求继承该方法所在类的子类实现该方法。 真值判断 在 Python 中使用 bool 函数、if、while 等对某个对象进行真值判断时，有一定的算法。 以下情况则为 False None False 所有为 0 的数值，比如：0, 0L, 0.0, 0j 任何空的序列，比如： '', (), [] 任何空的映射，比如 {} 用户定义的类的实例：如果该类定义了 ** __nonzero__ ** 或者 ** __len__ ** 方法，且返回值为数值 0 或者 False 其它所有情况都为 True 其实真值判断在 Python 入门时，大家都有遇到过，基本对于前 6 种会被判定为 False，大家也都清楚。 但是最后一种会被判断为 False，忽略的人可能会比较多。 () 的用法 在 Python 中，很多人还了解到元组的生成语法后，就会以为 () 是元组专享的。 其实在 Python 中， () 真实的意思应该是组合，一般情况下有它无它都可以。 比如： 1 2 3 4 5 6 7 8 In [ 13 ]: ( \"abcd\" \"ABC\" ) Out [ 13 ]: 'abcdABC' In [ 18 ]: ( 1 ) Out [ 18 ]: 1 In [ 19 ]: ( \"adfi\" ) Out [ 19 ]: 'adfi' 1 2 3 4 5 6 7 8 In [ 20 ]: \"asdfi\" \"asdif\" Out [ 20 ]: 'asdfiasdif' In [ 21 ]: 1 Out [ 21 ]: 1 In [ 23 ]: \"adfi\" Out [ 23 ]: 'adfi' 如果在 () 的内部至少有一个 , 才会解释成元组，或者啥都没有，就是一个空元组。 大家想深入了解的话，可以看 Python 官方文档 Parenthesized forms 。 1.bit_length() 为啥会报错？ 1 2 3 4 5 6 7 8 9 10 11 In [ 25 ]: 1. bit_length () File \"<ipython-input-25-069f7d2f7d97>\" , line 1 1. bit_length () &#94; SyntaxError : invalid syntax In [ 27 ]: 1. . is_integer () Out [ 27 ]: True In [ 28 ]: 1.0 . is_integer () Out [ 28 ]: True Python 里面不是是一切皆对象么，为啥我大浮点数可以调用方法，整数就不可以，还报语法错？ 其实这个由于 Python 的语法解析器导致的。 当它解释到 [number][dot] 这种形式时，它会将之当作一个浮点数，你一个浮点后面直接加方法名，中间没有 . 当然就直接报语法错了。 1..is_integer() 这样的话，它就不会报错了，因为 1. 它会解释成浮点数， .is_integer() 就是正常的方法调用了。 那么在 Python 中整数就没办法直接调用方法了么？ 那倒不是，方法还挺多。 1 2 In [ 29 ]: 1 . __add__ ( 2 ) # 空格可以任意添加多个 Out [ 29 ]: 3 1 2 In [ 30 ]: ( 1 ) . __add__ ( 2 ) Out [ 30 ]: 3 再来个疯狂一点的： 1 2 In [ 35 ]: 1 . __add__ ( 2 ) Out [ 35 ]: 3 StackOverFlow 上面有一个问题解释得比较详细： why-does-1-add-2-not-work-out 。 获取当前模块对象 获取当前模块的名称很容易。 1 2 In [ 58 ]: __name__ Out [ 58 ]: '__main__' 但有时我们需要获取当前的模块对象，并且对它做一些有趣的事。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [ 59 ]: import sys In [ 60 ]: current_module = sys . modules [ __name__ ] In [ 61 ]: test_var --------------------------------------------------------------------------- NameError Traceback ( most recent call last ) < ipython - input - 61 - 2538835 f11fb > in < module > () ----> 1 test_var NameError : name 'test_var' is not defined In [ 62 ]: current_module . test_var = \"hack var\" In [ 63 ]: test_var Out [ 63 ]: 'hack var' startswith&&endswith startswith 和 endswith 的用法相信大家都知道。 1 2 3 4 5 6 7 In [ 1 ]: l = \"abcdefg\" In [ 2 ]: l . startswith ( \"ab\" ) Out [ 2 ]: True In [ 3 ]: l . endswith ( \"fg\" ) Out [ 3 ]: True 但是有时候想判断多个 startswith 或者 endswith ，我们一般会写成： 1 2 In [ 4 ]: l . startswith ( \"ab\" ) or l . startswith ( \"bc\" ) Out [ 4 ]: True 如果是三个或者三个以上的话，就要写个循环或者其相等体来判断。 1 2 In [ 2 ]: any ( l . startswith ( key ) for key in ( \"ab\" , \"cd\" , \"ef\" )) Out [ 2 ]: True 那，有没有比较方便的判断方法呢？ 咱们看一下 startswith 和 endswith 的函数说明。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 In [ 5 ]: l . startswith ? Type : builtin_function_or_method String form : < built - in method startswith of str object at 0x8aec300 > Docstring : S . startswith ( prefix [, start [, end ]]) -> bool Return True if S starts with the specified prefix , False otherwise . With optional start , test S beginning at that position . With optional end , stop comparing S at that position . prefix can also be a tuple of strings to try . In [ 6 ]: l . endswith ? Type : builtin_function_or_method String form : < built - in method endswith of str object at 0x8aec300 > Docstring : S . endswith ( suffix [, start [, end ]]) -> bool Return True if S ends with the specified suffix , False otherwise . With optional start , test S beginning at that position . With optional end , stop comparing S at that position . suffix can also be a tuple of strings to try . 哈哈，看到最后一行，发现它们的参数还可以是一个元组。 prefix can also be a tuple of strings to try. 所以，想判断多个开头或者结尾的话，传入一个元组即可。 1 2 In [ 7 ]: l . startswith (( \"ab\" , \"bc\" , \"cd\" )) Out [ 7 ]: True","tags":"python","loc":"http://chenjiee815.github.io/pythonxiao-tie-shi-chi-xu-geng-xin.html","title":"Python小贴士（持续更新）"},{"text":"Contents 本书适用的读者 本书未涉及的方面 感谢 本书阅读指南 一门面向对象编程语言能够让程序员构造可复用的程序组件。其它程序员通过使用这些组件，能够快速地搭建新的大型程序和框架。在理想的状态下，程序员不需要修改任何已经存在的代码，只需要将它们简单地组装在一起然后添加一些新的代码即可。当然这些可复用的组件并不是天上掉下来的馅饼，它是有代价的。它需要一门经过良好设计的面向对象编程语言和严格的编程规范。 Java 就是一门这样的语言。这本书会介绍它的面向对象元素：类、属性、方法、继承和接口。这些核心元素都有着简单的语法模型，能够帮助程序员表达它们。并且，Java 还实现了内存自动管理，这更是让程序员们从思考机器的实现细节中解放出来，从而能够更专注于程序设计。 这本书的另外一个目的是向读者介绍 设计模式 。设计模式是能够加强代码复用的编程规范的关键所在。设计模式能够帮助程序员很好地组织面向对象组件，这样程序员就能够按照自己所希望的那样，实现整个计算流程了。更重要的是，设计模式有助于沟通程序组件的重要属性（这句不知道怎么意译，只能直译）。如果一个组件按照精确的公式化的模式实践（它的文档也一样），那么其他程序员就能够很容易地理解它的结构并且在自己的程序进行复用，甚至不需要了解该组件的源代码。 本书适用的读者 这本书主要的受众是那些愿意学习面向对象的本质以及设计模式的人，尤其是程序员、设计师和学生等等。读者需要有一些基本的编程经验。如果读者理解函数式编程的基本原理，那么他们将会从本书获得最大收益。了解函数式设计的最好办法是学一门使用 Scheme（或者 ML）语言进行教学的入门级计算机科学课程，但这并不是必需的。 本书未涉及的方面 Java 在它的面向对象核心之上，提供了很多有用的特性及库。当然，这些额外的 Java 元素对于专业编程来说很重要，但对于本书的重要目标： 面向对象编程及设计模式的使用 来说却没有什么关系。正因为这个原因，本书不是一本完全的 Java 入门书籍。不过，掌握了本书内容的读者在学习了本书 Commencement 章节补充那些书以后，会很快成长为一名专业的 Java 程序员。 有关设计模式的书籍发展得非常快。所以对一本入门级的书来说，能够清楚涉及到的设计模式不是很多。但是我们用到的模式的简洁以及强大功能会鼓舞读者继续学习书后所提及的额外的有关设计模式的资料。 感谢 基本是感谢一堆人，以及每个人对本书做了哪些贡献，暂不翻译。 本书阅读指南 不要简单粗暴地过一遍本书。至少用心地读上 7 次。在读书时记得做标记或者写笔记，在本书的犄角旮旯会有诸多有用的提示。完整得过完每一个例子，而不是简单拿眼睛浏览一下。牢记一句箴言：先动脑，再动手。 本书形式是有关有趣的 Java 编程的对话。在你理解了书中的例子之后就动手实践它们，通过修改这些程序和例子来看看它们倒底是如何工作的。目前不幸的是大部分的 Java 实现都没有交互式命令行或者解释器。这就需要你这边做一些必要的重复性工作。接下来的章节会告诉你一些如何体验 Java 的提示。 我们不会在本书里对设计模式给出任何正式的定义。我们相信读者你有这个能力能够给出你自己对设计模式的定义，这样你才能更好地理解并掌握它们，而不是通过我们直接灌输给你。但是你要确认你自己知道并理解了在本书大部分章节里给出的部分建议。 我们在书中使用一些 标记规定 来在不同层次帮助你理解程序。主要的规定就是通过字体来标识不同类型的单词。（该段下面基本就是告诉你各种类型的单词使用什么字体，这个也不翻译了，到时候一看例子就知道了）。 本书的例子中出现食物名有两个原因。首先，食物比起那些抽象的概念来说更容易可视化（但是你饿的时候读本书就不是一个好主意了）。我们希望我们选择食物名能够有助读者理解本书中的例子和主题。其次，我们希望在读书时能够小分一下心。我们知道当你试图理解这些主题时多少有点沮丧，但是一丢丢分心多少能够帮助你远离沮丧的情绪。 你要准备开始阅读本书喽。祝你好运！我们希望你能够享受阅读本书。","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-xu-yan.html","title":"A Little Java, A Few Patterns: 序言"},{"text":"之前的章节每次都是生成新的实例，然后再对该实例进行操作。 这一章节主要讲到如果修改实例中的属性，然后再进行操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 interface PiemanI { int addTop ( Object t ); int remTop ( Object t ); int substTop ( Object n , Object o ); int occTop ( Object o ); } class PiemanM implements PiemanI { PieD p = new Bot (); public int addTop ( Object t ) { p = new Top ( t , p ); return occTop ( t ); } public int remTop ( Object t ) { p = ( PieD ) p . accept ( new RemV ( t )); return occTop ( t ); } public int substTop ( Object n , Object o ) { p = ( PieD ) p . accept ( new SubstV ( n o )); return occTop ( n ); } public int occTop ( Object o ) { return (( Integer ) p . accept ( new OccursV ( o ))). intValue (); } } interface PieVisitorI { Object forBot (); Object forTop ( Object t , PieD r ); } abstract class PieD { abstract Object accept ( PieVisitorI ask ); } class Bot extends PieD { Object accept ( PieVisitorI ask ) { return ask . forBot (); } } class Top extends PieD { Object t ; PieD r ; Top ( Object _t , Object _r ) { t = _t ; r = _r ; } Object accept ( PieVisitorI ask ) { return ask . forTop ( t , r ); } } class OccursV implements PieVisitorI { Object a ; OccursV ( Object _a ) { a = _a ; } public Object forBot () { return new Integer ( 0 ); } public Object forTop ( Object t , PieD r ) { if ( t . equals ( a )) return new Integer ((( Integer )( r . accept ( this ))). intValue () + 1 ); else return r . accept ( this ); } } class SubstV implements PieVisitorI { Object n ; Object o ; SubstV ( Object _n , Object _o ) { n = _n ; o = _o ; } public Object forBot () { return new Bot (); } public Object forTop ( Object t , PieD r ) { if ( o . equals ( t )) return new Top ( n , ( PieD ) r . accept ( this )); else return new Top ( t , ( PieD ) r . accept ( this )); } } class RemV implements PieVisitorI { Object o ; RemV ( Object _o ) { o = _o ; } public Object forBot () { return new Bot (); } public Object forTop ( Object t , PieD r ) { if ( o . equals ( t )) return r . accept ( this ); else return new Top ( t , ( PieD ) r . accept ( this )); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 interface PieVisitorI { Object forBot ( Bot that ); Object forTop ( Top that ); } abstract class PieD { abstract Object accept ( PieVisitorI ask ); } class Bot extends PieD { Object accept ( PieVisitorI ask ) { return ask . forBot ( this ); } } class Top extends PieD { Object t ; PieD r ; Top ( Object _t , Object _r ) { t = _t ; r = _r ; } Object accept ( PieVisitorI ask ) { return ask . forTop ( this ); } } class OccursV implements PieVisitorI { Object a ; OccursV ( Object _a ) { a = _a ; } public Object forBot ( Bot that ) { return new Integer ( 0 ); } public Object forTop ( Top that ) { if ( that . t . equals ( a )) return new Integer ((( Integer )( that . r . accept ( this ))). intValue () + 1 ); else return that . r . accept ( this ); } } class SubstV implements PieVisitorI { Object n ; Object o ; SubstV ( Object _n , Object _o ) { n = _n ; o = _o ; } public Object forBot ( Bot that ) { return new Bot (); } public Object forTop ( Top that ) { if ( o . equals ( that . t )) return new Top ( n , ( PieD )( that . r ). accept ( this )); else return new Top ( that . t , ( PieD )( that . r ). accept ( this )); } } class RemV implements PieVisitorI { Object o ; RemV ( Object _o ) { o = _o ; } public Object forBot ( Bot that ) { return new Bot (); } public Object forTop ( Top that ) { if ( o . equals ( that . t )) return that . r . accept ( this ); else return new Top ( that . t , ( PieD )( that . r ). accept ( this )); } } 接下来，咱们通过彻底地修改实例的属性，而不是重新生成新的实例，来实现一个访问者。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class SubstV implements PieVisitorI { Object n ; Object o ; SubstV ( Object _n , Object _o ) { n = _n ; o = _o ; } public Object forBot ( Bot that ) { return that ; } public Object forTop ( Top that ) { if ( o . equals ( that . t )) that . t = n ; that . r . accept ( this ); return that ; else that . r . accept ( this ); return that ; } } 第十条建议 当必须修改一个对象时，使用一个类来隐藏修改操作，否则它就会对你的整个流程造成影响。 咱们再一个例子，加深一下理解。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 abstract class PointD { int x ; int y ; PointD ( int _x , int _y ){ x = _x ; y = _y ; } boolean closerTo0 ( PointD p ) { return distanceTo0 () <= p . distanceTo0 (); } PointD minus ( PointD p ) { return CartesianPt ( x - p . x , y - p . y ); } int moveBy ( int tx , int ty ) { x = x + tx ; y = y + ty ; return distanceTo0 (); } abstract int distanceTo0 (); } class CartesianPt extends PointD { // 笛卡尔坐标 CartesianPt ( int _x , int _y ){ super ( _x , _y ); } int distanceTo0 (){ return ( int ) Math . sqrt ( x * x + y * y ); } } class ManhattanPt extends PointD { // 曼哈顿坐标 ManhattanPt ( int _x , int _y ){ super ( _x , _y ); } int distanceTo0 (){ return x + y ; } } class ShadowedManhattanPt extends ManhattanPt { // 曼哈顿坐标 int tx ; int ty ; ManhattanPt ( int _x , int _y , int _tx , int _ty ){ super ( _x , _y ); tx = _tx ; ty = _ty ; } int distanceTo0 (){ return super . distanceTo0 () + tx + ty ; } }","tags":"java","loc":"http://chenjiee815.github.io/the-state-of-things-to-come.html","title":"The State of Things to Come"},{"text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ShadowedCartesianPt extend CartesianPt { int tx ; int ty ; ShadowedCartesianPt ( int _x , int _y , int _tx , int _ty ) { super ( _x , _y ); tx = _tx ; ty = _ty ; } int distanceTo0 () { return super . distanceTo0 () + ( int ) Math . sqrt ( tx * tx + ty * ty ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 interface ShapeVisitorI { boolean forCircle ( int r ); boolean forSquare ( int s ); boolean forTrans ( PointD q , ShapeD s ); } abstract class ShapeD { abstract boolean accept ( ShapeVisitorI ask ); } class Circle extend ShapeD { // 圆心在坐标原点的圆 int r ; Circle ( int _r ) { r = _r ; } boolean accept ( ShapeVisitorI ask ) { return ask . forCircle ( r ); } } class Square extend ShapeD { // 左上角在坐标原点的正方形 int r ; Square ( int _r ) { r = _r ; } boolean accept ( ShapeVisitorI ask ) { return ask . forSquare ( r ); } } class Trans extend ShapeD { // 在指定位置的图形， PointD q ; ShapeD s ; Trans ( PointD _q , ShapeD _s ) { q = _q ; s = _s ; } boolean accept ( ShapeVisitorI ask ) { return ask . forTrans ( q , s ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 检查某个点是否在图形内部 class HasPtV implements ShapeVisitorI { PointD p ; HasPtV ( PointD _p ) { p = _p ; } public boolean forCircle ( int r ) { return p . distanceTo0 () <= r ; } public boolean forSquare ( int s ) { return p . x <= s && p . y <= s ; } public boolean forTrans ( PointD q , ShapeD s ) { return s . accept ( new HasPtV ( p . minus ( q ))); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Union extends ShapeD { ShapeD s ; ShapeD t ; Union ( ShapeD _s , ShapeD _t ) { s = _s ; t = _t ; } boolean accept ( ShapeVisitorI ask ) { (( UnionVisitorI ) ask ). forUnion ( s , t ); } } interface UnionVisitorI extends ShapeVisitorI { boolean forUnion ( ShapeD s , ShapeD t ); } class UnionHasPtV extends HasPtV implements ShapeVisitorI { UnionHasPtV ( PointD _p ) { super ( _p ); } public boolean forUnion ( ShapeD s , ShapeD t ) { return s . accept ( this ) || t . accept ( this ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class HasPtV implements ShapeVisitorI { PointD p ; HasPtV ( PointD _p ) { p = _p ; } ShapeVisitorI newHasPt ( PointD p ) { return new HasPtV ( p ); } public boolean forCircle ( int r ) { return p . distanceTo0 () <= r ; } public boolean forSquare ( int s ) { return p . x <= s && p . y <= s ; } public boolean forTrans ( PointD q , ShapeD s ) { return s . accept ( newHasPtV ( p . minus ( q ))); } } class UnionHasPtV extends HasPtV implements UnionVisitorI { UnionHasPtV ( PointD _p ) { super ( _p ); } ShapeVisitorI newHasPt ( PointD p ) { return new UnionHasPtV ( p ); } public boolean forUnion ( ShapeD s , ShapeD t ) { return s . accept ( this ) || t . accept ( this ); } } 第九条建议 如果一个类必须被扩展， 为了前瞻性，使用一个类似于构造方法的方法，这样访问者类被扩展时该类能够被重载。","tags":"java","loc":"http://chenjiee815.github.io/good-visitor.html","title":"Good Visitor"},{"text":"这一章节主要讲到了继承，从章节题目也可以看出来 : 父子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 interface ExprVisitorI { Object forPlus ( ExprD l , ExprD r ); // 相加 Object forDiff ( ExprD l , ExprD r ); // 相减 Object forProd ( ExprD l , ExprD r ); // 相乘 Object forConst ( Object c ); // 常量 } abstract class ExprD { abstract Object accept ( ExprVisitorI ask ); } class Plus extends ExprD { ExprD l ; ExprD r ; Plus ( ExprD _l , ExprD _r ) { l = _l ; r = _r ; } Object accept ( ExprVisitorI ask ){ return ask . forPlus ( l , r ); } } class Diff extends ExprD { ExprD l ; ExprD r ; Diff ( ExprD _l , ExprD _r ) { l = _l ; r = _r ; } Object accept ( ExprVisitorI ask ){ return ask . forDiff ( l , r ); } } class Prod extends ExprD { ExprD l ; ExprD r ; Prod ( ExprD _l , ExprD _r ) { l = _l ; r = _r ; } Object accept ( ExprVisitorI ask ){ return ask . forProd ( l , r ); } } class Const extends ExprD { Object c ; Const ( Object _c ){ c = _c ; } Object accept ( ExprVisitorI ask ){ return ask . forConst ( c ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class IntEvalV implements ExprVisitorI { public Object forPlus ( ExprD l , ExprD r ){ return plus ( l . accept ( this ), r . accept ( this )); } public Object forDiff ( ExprD l , ExprD r ){ return diff ( l . accept ( this ), r . accept ( this )); } public Object forProd ( ExprD l , ExprD r ){ return prod ( l . accept ( this ), r . accept ( this )); } public Object forConst ( Object c ){ return c ; } Object plus ( Object l , Object r ){ return new Integer ((( Integer ) l ). intValue () + (( Integer ) r ). intValue ()); } Object diff ( Object l , Object r ){ return new Integer ((( Integer ) l ). intValue () - (( Integer ) r ). intValue ()); } Object prod ( Object l , Object r ){ return new Integer ((( Integer ) l ). intValue () * (( Integer ) r ). intValue ()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 abstract class SetD { SetD add ( Integer i ){ if ( mem ( i )) return this ; else return new Add ( i , this ); } abstract boolean mem ( Integer i ); abstract SetD plus ( SetD s ); abstract SetD diff ( SetD s ); abstract SetD prod ( SetD s ); } class Empty extends SetD { boolean mem ( Integer i ){ return false ; } SetD plus ( SetD s ){ return s ; } SetD diff ( SetD s ){ return new Empty (); } SetD prod ( SetD s ){ return new Empty (); } } class Add extends SetD { Integer i ; SetD s ; Add ( Integer _i , SetD _s ){ i = _i ; s = _s ; } boolean mem ( Integer n ){ if ( i . equals ( n )) return true ; else return s . mem ( n ); } SetD plus ( SetD t ){ return s . plus ( t . add ( i )); } SetD diff ( SetD t ){ if ( t . mem ( i )) return s . diff ( t ); else return s . diff ( t ). add ( i ); } SetD prod ( SetD t ){ if ( t . mem ( i )) return s . prod ( t ). add ( i ); else return s . prod ( t ); } } class SetEvalV extends IntEvalV { Object plus ( Object l , Object r ){ return (( SetD ) l ). plus (( SetD ) r ); } Object diff ( Object l , Object r ){ return (( SetD ) l ). diff (( SetD ) r ); } Object prod ( Object l , Object r ){ return (( SetD ) l ). prod (( SetD ) r ); } } SetEvalV 直接继承 IntEvalV 有点不合理，好，我们改一下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 abstract class EvalD implements ExprVisitorI { public Object forPlus ( ExprD l , ExprD r ){ return plus ( l . accept ( this ), r . accept ( this )); } public Object forDiff ( ExprD l , ExprD r ){ return diff ( l . accept ( this ), r . accept ( this )); } public Object forProd ( ExprD l , ExprD r ){ return prod ( l . accept ( this ), r . accept ( this )); } public Object forConst ( Object c ){ return c ; } abstract Object plus ( Object l , Object r ); abstract Object diff ( Object l , Object r ); abstract Object prod ( Object l , Object r ); } class IntEvalV extends EvalD { Object plus ( Object l , Object r ){ return new Integer ((( Integer ) l ). intValue () + (( Integer ) r ). intValue ()); } Object diff ( Object l , Object r ){ return new Integer ((( Integer ) l ). intValue () - (( Integer ) r ). intValue ()); } Object prod ( Object l , Object r ){ return new Integer ((( Integer ) l ). intValue () * (( Integer ) r ). intValue ()); } } class SetEvalV extends EvalD { Object plus ( Object l , Object r ){ return (( SetD ) l ). plus (( SetD ) r ); } Object diff ( Object l , Object r ){ return (( SetD ) l ). diff (( SetD ) r ); } Object prod ( Object l , Object r ){ return (( SetD ) l ). prod (( SetD ) r ); } } 还记得第 6 章的 SubstV 和 LtdSubstV 么？ 它们有很多相似的地方，能否合并起来？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 abstract class SubstD implements PieVisitorI { Object n ; Object o ; SubstD ( Object _n , Object _o ) { n = _n ; o = _o ; } public PieD forBot () { return new Bot (); } public abstract PieD forTop ( Object t , PieD r ); } class SubstV extends SubstD { SbustV ( Object _n , Object _o ) { super ( _n , _o ); } public PieD forTop ( Object t , PieD r ) { if ( o . equals ( t )) return new Top ( n , r . accept ( this )); else return new Top ( t , r . accept ( this )); } } class LtdSubstV extends SubstD { int c ; LtdSubstV ( int _c , Object _n , Object _o ) { super ( _n , _o ); c = _c ; } public PieD forTop ( Object t , PieD r ) { if ( c == 0 ) return new Top ( t , r ); else if ( o . equals ( t )) return new Top ( n , r . accept ( LtdSubstV ( c - 1 , n , o ))); else return new Top ( t , r . accept ( this )); } } 第八条建议 当继承某个类时，使用重载来扩展它的功能。 根据以上建议， LtdSubstV 可以直接在 SbustV 类上进行继承和扩展。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class SbustV implements PieVisitorI { Object n ; Object o ; SubstV ( Object _n , Object _o ) { n = _n ; o = _o ; } public PieD forBot () { return new Bot (); } public PieD fotTop ( Object t , PieD r ) { if ( o . equals ( t )) return new Top ( n , r . accept ( this )); else return new Top ( t , r . accept ( this )); } } class LtdSubstV extends SubstV { int c ; Object n ; Object o ; LtdSubstV ( int _c , Object _n , Object _o ) { super ( _n , _o ); c = _c ; } public PieD forTop ( Object t , PieD r ) { if ( c == 0 ) return new Top ( t , r ); else if ( o . equals ( t )) return new Top ( n , r . accept ( LtdSubstV ( c - 1 , n , o ))); else return new Top ( t , r . accept ( this )); } } 不过这样一来反而违反了 里氏替换原则 ，不知道作者为什么这样写？ 还是我自己太教条了，或者没有理解 里氏替换原则 。","tags":"java","loc":"http://chenjiee815.github.io/like-father-like-son.html","title":"Like Father, Like Son"},{"text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 abstract class FruitD {} // 水果 class Peach extends FruitD { // 桃 public boolean equals ( Object o ) { return ( o instanceof Peach ); } } class Apple extends FruitD { // 苹果 public boolean equals ( Object o ) { return ( o instanceof Apple ); } } class Pear extends FruitD { // 梨 public boolean equals ( Object o ) { return ( o instanceof Pear ); } } class Lemon extends FruitD { // 柠檬 public boolean equals ( Object o ) { return ( o instanceof Lemon ); } } class Fig extends FruitD { // 无花果 public boolean equals ( Object o ) { return ( o instanceof Fig ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 abstract class TreeD { abstract boolean accept ( bTreeVisitorI ask ); abstract int accept ( iTreeVisitorI ask ); abstract TreeD accept ( tTreeVisitorI ask ); } class Bud extends TreeD { boolean accept ( bTreeVisitorI ask ) { return ask . forBud (); } int accept ( iTreeVisitorI ask ) { return ask . forBud (); } TreeD accept ( tTreeVisitorI ask ) { return ask . forBud (); } } class Flat extends TreeD { FruitD f ; TreeD t ; Flat ( FruitD _f , TreeD _t ) { f = _f ; t = _t ; } boolean accept ( bTreeVisitorI ask ) { return ask . forFlat ( f , t ); } int accept ( iTreeVisitorI ask ) { return ask . forFlat ( f , t ); } TreeD accept ( tTreeVisitorI ask ) { return ask . forFlat ( f , t ); } } class Split extends TreeD { TreeD l ; TreeD r ; Split ( Treed _l , TreeD _r ) { l = _l ; r = _r ; } boolean accept ( bTreeVisitorI ask ) { return ask . forSplit ( l , r ); } int accept ( iTreeVisitorI ask ) { return ask . forSplit ( l , r ); } TreeD accept ( tTreeVisitorI ask ) { return ask . forFlat ( l , r ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 interface bTreeVisitorI { boolean forBud (); boolean forFlat ( FruitD f , TreeD t ); boolean forSplit ( TreeD l , TreeD r ); } class bIsFlatV implements bTreeVisitorI { public boolean forBud () { return true ; } public boolean forFlat ( FruitD f , TreeD t ) { return t . accept ( this ); } public boolean forSplit ( TreeD l , TreeD r ) { return false ; } } class bIsSplitV implements bTreeVisitorI { public boolean forBud () { return true ; } public boolean forFlat ( FruitD f , TreeD t ) { return false ; } public boolean forSplit ( TreeD l , TreeD r ) { return l . accept ( this ) && r . accept ( this ); } } class bHasFruitV implements bTreeVisitorI { public boolean forBud () { return false ; } public boolean forFlat ( FruitD f , TreeD t ) { return true ; } public boolean forSplit ( TreeD l , TreeD r ) { return l . accept ( this ) || r . accept ( this ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 interface iTreeVisitorI { int forBud (); int forFlat ( FruitD f , TreeD t ); int forSplit ( TreeD l , TreeD r ); } class iHeightV implements iTreeVisitorI { public int forBud () { return 0 ; } public int forFlat ( FruitD f , TreeD t ) { return t . accept ( this ) + 1 ; } public int forSplit ( TreeD l , TreeD r ) { return ( l . accept ( this ) | _ | r . accept ( this )) + 1 ; } } class iOccursV implements iTreeVisitorI { FruitD a ; iOccursV ( FruitD _a ) { a = _a ; } public int forBud () { return 0 ; } public int forFlat ( FruitD f , TreeD t ) { if ( f . equals ( a )) return t . accept ( this ) + 1 ; else return t . accept ( this ); } public int forSplit ( TreeD l , TreeD r ) { return l . accept ( this ) + r . accept ( this ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 interface tTreeVisitorI { TreeD forBud (); TreeD forFlat ( FruitD f , TreeD t ); TreeD forSplit ( TreeD l , TreeD r ); } class tSubstV implements tTreeVisitorI { FruitD n ; FruitD o ; tSubstV ( FruitD _n , FruitD _o ) { n = _n ; o = _o ; } public TreeD forBud () { return new Bud (); } public TreeD forFlat ( FruitD f , TreeD t ) { if ( o . equals ( f )) return new Flat ( n , t . accept ( this )); else return new Flat ( f , t . accept ( this )); } public TreeD forSplit ( TreeD l , TreeD r ) { return new Split ( l . accept ( this ), r . accept ( this )); } } 上面的三个接口是不是有点繁琐？那么将它合并起来。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 interface TreeVisitorI { Object forBud (); Object forFlat ( FruitD f , TreeD t ); Object forSplit ( TreeD l , TreeD r ); } abstract class TreeD { abstract Object accept ( TreeVisitorI ask ); } class Bud extends TreeD { Object accept ( TreeVisitorI ask ) { return ask . forBud (); } } class Flat extends TreeD { FruitD f ; TreeD t ; Flat ( FruitD _f , TreeD _t ) { f = _f ; t = _t ; } Object accept ( TreeVisitorI ask ) { return ask . forFlat ( f , t ); } } class Split extends TreeD { TreeD l ; TreeD r ; Split ( Treed _l , TreeD _r ) { l = _l ; r = _r ; } Object accept ( TreeVisitorI ask ) { return ask . forSplit ( l , r ); } } class IsFlatV implements TreeVisitorI { public Object forBud () { return new Boolean ( true ); } public Object forFlat ( FruitD f , TreeD t ) { return t . accept ( this ); } public Object forSplit ( TreeD l , TreeD r ) { return new Boolean ( false ); } } class bIsSplitV implements bTreeVisitorI { public boolean forBud () { return new Boolean ( true ); } public boolean forFlat ( FruitD f , TreeD t ) { return new Boolean ( false ); } public boolean forSplit ( TreeD l , TreeD r ) { if ((( Boolean )( l . accept ( this ))). booleanValue ()) return r . accept ( this ); else : return new Boolean ( false ); } } 第七条建议 当为多个不同的类型设计访问者协议时，使用 Object 来创建一个统一的协议。 最后再来罗嗦到不行的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class OccursV implements TreeVisitorI { FruitD a ; iOccursV ( FruitD _a ) { a = _a ; } public Object forBud () { return new Integer ( 0 ); } public Object forFlat ( FruitD f , TreeD t ) { if ( f . equals ( a )) return new Integer ((( Integer )( t . accept ( this ))). intValue () + 1 ); else return t . accept ( this ); } public int forSplit ( TreeD l , TreeD r ) { return new Integer ((( Integer )( l . accept ( this ))). intValue () + (( Integer )( r . accept ( this ))). intValue ()); } }","tags":"java","loc":"http://chenjiee815.github.io/oh-my.html","title":"Oh My!"},{"text":"哈哈， 之前 5 章看起来还真是 Boring ，这一章的名称中虽然有 Boring 但是内容却是很有趣的。 这里的 Protocols 我觉得应该指的是 Interface 接着上一章节的最后代码继续讲解。 这次将 remFn substFn 放入到参数的位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 abstract class PieD { abstract PieD rem ( RemV remFn , Object o ); abstract PieD subst ( SubstV substFn , Object n , Object o ); } class Top extends PieD { Object t ; PieD r ; Top ( Object _t , PieD _r ) { t = _t ; r = _r ; } PieD rem ( RemV remFn , Object o ) { return remFn . forTop ( t , r , o ); } PieD subst ( SubstV substFn , Object n , Object o ) { return sbustFn . forTop ( t , r , n , o ); } } class Bot extends PieD { Object t ; PieD r ; Bot ( Object _t , PieD _r ) { t = _t ; r = _r ; } PieD rem ( RemV remFn , Object o ) { return remFn . forBot ( t , r , o ); } PieD subst ( SubstV substFn , Object n , Object o ) { return sbustFn . forBot ( t , r , n , o ); } } 同步修改对应的访问者类。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class RemV { PieD forBot ( Object o ){ return new Bot (); } PieD forTop ( Object t , PieD r , Object o ){ if ( o . equals ( t )) return r . rem ( this , o ); else return new Top ( t , r . rem ( this , o )); } } class SubstV { PieD forBot ( Object n , Object o ){ return new Bot (); } PieD forTop ( Object t , PieD r , Object n , Object o ){ if ( o . equals ( t )) return new Top ( n , r . subst ( tis , n , o )); else return new Top ( t , r . subst ( this , n , o )); } } 再修改访问者类，将更多的参数传入到访问者类中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class RemV { Object o ; RemV ( Object _o ) { o = _o ; } PieD forBot ( Object o ){ return new Bot (); } PieD forTop ( Object t , PieD r ){ if ( o . equals ( t )) return r . rem ( this ); else return new Top ( t , r . rem ( this )); } } class SubstV { Object n ; Object o ; SubstV ( Object _n , Object _o ){ n = _n ; o = _o ; } PieD forBot ( Object n , Object o ){ return new Bot (); } PieD forTop ( Object t , PieD r ){ if ( o . equals ( t )) return new Top ( n , r . subst ( this )); else return new Top ( t , r . subst ( this )); } } 上面的形式就很像函数式编程里面的 闭包 概念了。 好了，根据上面修改后的 SubstV ，重新修改一下 PieD 及其 Bot 和 Top 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 abstract class PieD { abstract PieD rem ( RemV remFn ); abstract PieD subst ( SubstV substFn ); } class Top extends PieD { Object t ; PieD r ; Top ( Object _t , PieD _r ) { t = _t ; r = _r ; } PieD rem ( RemV remFn ) { return remFn . forTop ( t , r ); } PieD subst ( SubstV substFn ) { return sbustFn . forTop ( t , r ); } } class Bot extends PieD { Object t ; PieD r ; Bot ( Object _t , PieD _r ) { t = _t ; r = _r ; } PieD rem ( RemV remFn ) { return remFn . forBot (); } PieD subst ( SubstV substFn ) { return sbustFn . forBot (); } } 我们可以给 RemV 和 SubstV 这两个类也抽象出一个类型出来。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 abstract class PieVisitorD { abstract PieD forBot (); abstract PieD forTop ( Object t , PieD r ); } interface PieVisitorI { PieD forBot (); PieD forTop ( Object t , PieD r ); } class RemV implements PieVisitorI { Object o ; RemV ( Object _o ) { o = _o ; } public PieD forBot () { return new Bot (); } public PieD forTop ( Object t , PieD r ) { if ( o . equals ( t )) return r . accept ( this ); else return new Top ( t , r . accept ( this )); } } class SbustV implements PieVisitorI { Object n ; Object o ; SubstV ( Object _n , Object _o ) { n = _n ; o = _o ; } public PieD forBot () { return new Bot (); } public PieD fotTop ( Object t , PieD r ) { if ( o . equals ( t )) return new Top ( n , r . accept ( this )); else return new Top ( t , r . accept ( this )); } } 同步修改 PieD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 abstract class PieD { abstract PieD accept ( PieVisitorI ask ); } class Bot extends PieD { PieD accept ( PieVisitorI ask ) { return ask . forBot (); } } class Top extends PieD { Object t ; PieD r ; Top ( Object _t , PieD _r ) { t = _t ; r = _r ; } PieD accept ( PieVisitorI ask ) { return ask . forTop ( t , r ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class LtdSubstV implements PieVisitorI { int c ; Object n ; Object o ; LtdSubstV ( int _c , Object _n , Object _o ) { c = _c ; n = _n ; o = _o ; } public PieD forBot () { return new Bot (); } public PieD forTop ( Object t , PieD r ) { if ( c == 0 ) return new Top ( t , r ); else if ( o . equals ( t )) return new Top ( n , r . accept ( LtdSubstV ( c - 1 , n , o ))); else return new Top ( t , r . accept ( this )); } } 第六条建议 当一个自引用的访问者类的参数发生改变时，别忘记重新创建一个新的访问者类实例。","tags":"java","loc":"http://chenjiee815.github.io/boring-protocols.html","title":"Boring Protocols"},{"text":"PieD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 abstract class PieD { // 馅饼，派 RemAV raFn = new RemAV (); RemFishV rfFn = new RemFishV (); abstract PieD remA (); abstract PieD remFish ( FishD f ); } class Bot extends PieD { // 底料 PieD remA () { return raFn . forBot (); } Pied remFish ( FishD f ) { return rfFn . forBot ( f ); } } class Top extends PieD { // 顶料 Object t ; PieD r ; Top ( Object _t , PieD _r ) { t = _t , r = _r , } PieD remA () { return raFn . forTop ( t , r ); } PieD remFish ( FishD f ) { return rfFn . forTop ( t , r , f ); } } FishD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 abstract class FishD {} class Anchovy extends FishD { // 凤尾鱼 public boolean equals ( Object o ) { return ( o instanceof Anchovy ); } } class Salmon extends FishD { // 鲑鱼 public boolean equals ( Object o ) { return ( o instanceof Salmon ); } } class Tuna extends FishD { // 金枪鱼 public boolean equals ( Object o ) { return ( o instanceof Tuna ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 删除凤尾鱼的方法 class RemAV { PieD forBot () { return new Bot (); } PieD forTop ( Object t , PieD r ) { if ( new Anchovy (). equals ( t )) return r . remA (); else return new Top ( t , r . remA ()); } } // 删除指定鱼的方法，相当在 `RemAV` 的概念上再抽象一层 class RemFishV { PieD forBot ( FishD f ) { return new Bot (); } PieD forTop ( Object t , PieD r , FishD f ) { if ( f . equals ( t )) return r . remFish ( f ); else return new Top ( t , r . remFish ( f )); } } // 删除指定整数的方法 class RemIntV { PieD forBot ( Integer i ) { return new Bot (); } PieD forTop ( Object t , PieD r , Integer i ) { if ( i . equals ( t )) return r . remInt ( i ); else return new Top ( t , r . remInt ( i )); } } RemFishV 和 RemIntV 的整个逻辑很类似么，那么将它们重新抽象一下？ 1 2 3 4 5 6 7 8 9 10 11 class RemV { PieD forBot ( Object o ) { return new Bot (); } PieD forTop ( Object t , PieD r , Object o ) { if ( o . equals ( t )) return r . rem ( o ); else return new Top ( t , r . rem ( o )); } } PieD 及它的变种类型 Bot Top 也要简单变化一下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 abstract class PieD { RemV remFn = new RemV (); abstract PieD rem ( Object o ); } class Bot extends PieD { PieD rem ( Object o ){ return remFn . forBot ( o ); } } class Top extends PieD { Object t ; PieD r ; Top ( Object _t , PieD _r ){ t = _t ; r = _r ; } PieD rem ( Object o ){ return remFn . forTop ( t , r , o ); } } 现在的 Bot Top 在调用 rem 时，即可以传入 FishD 也可以传入 Integer 了。 NumD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 abstract class NumD {} class OneMoreThan extends NumD { NumD predecessor ; OneMoreThan ( NumD _p ) { predecessor = _p ; } public boolean equals ( Object o ) { if ( o instanceof OneMoreThan ) return predecessor . equals ( (( OneMoreThan ) o ). predecessor ), else return false ; } } class Zero extends NumD { public boolean equals ( Object o ) { return ( o instanceof Zero ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SubstFishV { PieD forBot ( FishD n , FishD o ) { return new Bot (); } PieD forTop ( Object t , PieD r , FishD n , FishD o ) { if ( o . equals ( t )) return new Top ( n , r . substFish ( n , o )); else return new Top ( t , r . substFish ( n , 0 )); } } class SubstIntV { PieD forBot ( Integer n , Integer o ) { return new Bot (); } PieD forTop ( Object t , PieD r , Integer n , Integer o ) { if ( o . equals ( t )) return new Top ( n , r . substInt ( n , o )); else return new Top ( t , r . substInt ( n , 0 )); } } class SubstV { PieD forBot ( Object n , Object o ) { return new Bot (); } PieD forTop ( Object t , PieD r , Object n , Object o ) { if ( o . equals ( t )) return new Top ( n , r . subst ( n , o )); else return new Top ( t , r . subst ( n , 0 )); } } SubstV 和 RemV 的做法是一样。 再整理一下 PieD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 abstract class PieD { RemV remFn = new RemV (); SubsbV substFn = new SubstV (); abstract PieD rem ( Object o ); abstract PieD subst ( Object n , Object o ); } class Bot extends PieD { PieD rem ( Object o ){ return remFn . forBot ( o ); } PieD subst ( Object n , Object o ){ return substFn . forBot ( n , o ) } } class Top extends PieD { Object t ; PieD r ; Top ( Object _t , PieD _r ){ t = _t ; r = _r ; } PieD rem ( Object o ){ return remFn . forTop ( t , r , o ); } PieD subst ( Object n , Object o ){ return substFn . forTop ( n , o ) } }","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-objects-are-people-too.html","title":"A Little Java, A Few Patterns: Objects Are People, Too"},{"text":"Contents 简介 Event scheduler 简介 sched 提供了一个具有事件调度机制的类 scheduler 。 不过该模块在文件的开头简介里就说明了： 该类的每个实例内部会维护一个队列。 但是该类并不是线程安全的。 如果想要线程安全，你必须自己根据 scheduler 来定制一个， 或者在多线程环境里，使用单例模式来解决线程安全问题。 官方文档里建议使用 threading.Timer 来延时执行某个方法，可以达到类似于 sched 的效果，同时也是线程安全的。 从上面的介绍就可以看出， scheduler 不支持多线程，所以它内部的阻塞以及事件回调函数的执行应该都是用同步的方式来做的，且其中一个步骤执行时抛出异常，都会导致事件调试失败，这个算是它的一个不小的缺点吧，当然对于要求不高的任务，够用啦。 Event 既然是有事件调度，那么就有一个事件对象。 在 sched 模块中是以命名元组来实现的。 该事件有四个属性： time: 该事件的调度时间，当 timefunc 的返回值 >=time 时，该事件可以进行调度 priority: 该事件的优先级，数值越小，优先级越高（Unix） action: 该事件的动作，即回调函数 argument: 回调函数的参数，元组形式，不支持关键字参数 1 Event = namedtuple ( 'Event' , 'time, priority, action, argument' ) scheduler 该类有两个参数： timefunc timefunc 函数要求不需要参数，并且返回一个数字，来表示时间概念 delayfunc delayfunc 函数要求有一个参数，参数类型与 timefunc 函数的返回值匹配。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class scheduler : def __init__ ( self , timefunc , delayfunc ): self . _queue = [] # 内部队列其实是用 list 来实现 self . timefunc = timefunc self . delayfunc = delayfunc def enterabs ( self , time , priority , action , argument ): \"\"\" 插入一个事件，使用绝对时间 四个参数正好是用来生成一个事件用的 本方法会返回一个 ID，可以用来删除对应的事件 \"\"\" event = Event ( time , priority , action , argument ) heapq . heappush ( self . _queue , event ) # 这个 ID 其实就一个事件对象，不是说一提到 ID 就是一个唯一数字 return event def enter ( self , delay , priority , action , argument ): \"\"\" 插入一个事件，使用相对时间， 相对于 `timefunc` 返回的时间 \"\"\" time = self . timefunc () + delay return self . enterabs ( time , priority , action , argument ) def cancel ( self , event ): \"\"\" 删除一个事件 这个事件可以是 `enterabs` 或者 `enter` 方法的返回值 如果该事件不在内部队列里面，会抛出 `ValueError` 异常 \"\"\" self . _queue . remove ( event ) heapq . heapify ( self . _queue ) def empty ( self ): \"\"\" 检查内部队列是否为空 \"\"\" return not self . _queue def run ( self ): \"\"\" 开始事件调度，直接所有事件调度完成 如果 timefunc/deltafunc/ 事件的回调函数抛出异常了，事件调试也会中止， 不过幸运的是，你可以再次调用 `run` 来重新调试剩余事件。 \"\"\" # 将二次调用的方法 / 属性都统一到本地变量 # 一方面是加快调用速度，另一面也是为了线程安全考虑 # 为本地变量的话，直接一个字节码 `LOST_FAST` 搞定了 # Python 执行线程切换时以字节码为单位的 q = self . _queue delayfunc = self . delayfunc timefunc = self . timefunc pop = heapq . heappop while q : time , priority , action , argument = checked_event = q [ 0 ] now = timefunc () if now < time : delayfunc ( time - now ) else : event = pop ( q ) # 从 q[0] 取出事件和，pop 取出事件之间会执行多条字节码 # 在多线程环境里，很有可能在一个线程里取得了 q[0] # 而在另外一个线程里又添加了新的事件，pop 出来就可能是新的事件 # 所以这里要验证一下两者是否是同一个对象 if event is checked_event : action ( * argument ) # 主动让出执行权给其它线程 # 如果不加这个，且队列中所有事件都符合调度要求了， # 此时就会一直进行事件调度， # 话是这样说，但是 Python 内部的线程是抢占式， # 不会担心会出现上面所说的问题， # 所以作者在注释才会说明这句代码是一个有争论的 hack 代码 # 如果是用 gevent 的话这句代码就很有必要的， # 因为 gevent 是非抢占式的，要主要出让才行 delayfunc ( 0 ) else : # 如果验证失败，则放回队列内部，等待下次机会 heapq . heappush ( q , event ) @property def queue ( self ): \"\"\" 用来保存内部待执行的事件 \"\"\" # 这里使用堆排，而不使用 `sorted` 来对内部队列排序 # 是因为当两个事件的优先级一亲，堆排还会按两个事件的插入顺序来排序 events = self . _queue [:] return map ( heapq . heappop , [ events ] * len ( events ))","tags":"Python","loc":"http://chenjiee815.github.io/schedbiao-zhun-ku-yuan-ma-xue-xi.html","title":"sched标准库源码学习"},{"text":"Contents 简介 bisect&&bisect_right bisect_left insort&&insort_right insort_left 简介 这个库还是比较简单的。 基本的要点有两个： 它内部的所有操作都使用 二分查找法 它操作的所有序列都要求为升序，且操作最好为线性表（即数组，如果使用 list，性能不佳） 它提供的函数分为两类： bisect bisect_left bisect_right 查找某元素在序列中的插入位置 如果某元素在序列中已存在， bisect_left 则返回该元素左边的位置， bisect_right 返回该元素右边的位置 1 bisect = bisect_right # 向后兼容 insort insort_left insort_right 将某元素插入到序列中 如果某元素在序列中已存在 , insort_left 插入到该元素的左边， insort_right 插入到该元素的右边 1 insort = insort_right # 向后兼容 当然，如果直接使用 Python 来实现这些功能，性能是不怎么样的，所以在源码中，一开始给出了 Python 版本的定义，但是在文件最后，还是会尝试导入 C 语言版本。 1 2 3 4 try : from _bisect import * except ImportError : pass bisect&&bisect_right bisect_right 的签名还是很简单的： a 为操作的序列 x 为某元素 lo hi 用来指定 a 中的开始查找和结束查找位置，默认是指整个 a 序列 原代码实现（Python 版本）： 1 2 3 4 5 6 7 8 9 10 def bisect_right ( a , x , lo = 0 , hi = None ): if lo < 0 : raise ValueError ( 'lo must be non-negative' ) if hi is None : hi = len ( a ) while lo < hi : mid = ( lo + hi ) // 2 # 使用 floor 除法，保证 a[mid] 不会抛出 IndexError if x < a [ mid ]: hi = mid else : lo = mid + 1 return lo 上面的源代码没啥好解释的，知道 二分查找 是啥，基本就能懂了。 但是我还是想用递归思想重写一遍。 因为二分查找的算法定义是什么样子，它对应的代码就是什么样子，能够和定义一一对应，一眼就能看明白。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def help_mybisect_right ( a , x , lo , hi ): if lo > hi : return lo mid_index = ( lo + hi ) // 2 mid = a [ mid_index ] if x == mid : return mid_index + 1 elif x < mid : return help_mybisect_right ( a , x , lo , mid_index - 1 ) else : return help_mybisect_right ( a , x , mid_index + 1 , hi ) def mybisect_right ( a , x , lo = 0 , hi = None ): if lo < 0 : raise ValueError ( 'lo must be non-negative' ) if hi is None : hi = len ( a ) - 1 return help_mybisect_right ( a , x , lo , hi ) 嗯，咱们比较一下两者的性能。 1 2 3 4 5 6 7 8 9 In [ 164 ]: import array In [ 165 ]: a = array . array ( \"i\" , xrange ( 1000 )) In [ 178 ]: % timeit - n10000 - r100 bisect_right ( a , 7 ) 10000 loops , best of 100 : 1.45 µ s per loop In [ 179 ]: % timeit - n10000 - r100 mybisect_right ( a , 7 ) 10000 loops , best of 100 : 2.86 µ s per loop 性能相差两倍左右 ... ...，SO，我还挺希望 Python 的解释器有尾递归优化的，甚至尾调用优化。 bisect_left 原代码实现（Python 版本）： 1 2 3 4 5 6 7 8 9 10 def bisect_left ( a , x , lo = 0 , hi = None ): if lo < 0 : raise ValueError ( 'lo must be non-negative' ) if hi is None : hi = len ( a ) while lo < hi : mid = ( lo + hi ) // 2 if a [ mid ] < x : lo = mid + 1 else : hi = mid return lo 使用递归来实现一下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def help_mybisect_left ( a , x , lo , hi ): if lo > hi : return lo mid_index = ( lo + hi ) // 2 mid = a [ mid_index ] if x == mid : return mid_index elif x < mid : return help_mybisect_left ( a , x , lo , mid_index - 1 ) else : return help_mybisect_left ( a , x , mid_index + 1 , hi ) def mybisect_left ( a , x , lo = 0 , hi = None ): if lo < 0 : raise ValueError ( 'lo must be non-negative' ) if hi is None : hi = len ( a ) return help_mybisect_left ( a , x , lo , hi ) help_mybisect_left help_mybisect_right 大体差不多么，将公共部分抽出来，用连续的概念，再添加一个参数 continue_func 。用来处理 help_mybisect 的结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def help_mybisect ( a , x , lo , hi , continue_func ): if lo > hi : return lo mid_index = ( lo + hi ) // 2 mid = a [ mid_index ] if x == mid : return continue_func ( mid_index ) elif x < mid : return help_mybisect_left ( a , x , lo , mid_index - 1 ) else : return help_mybisect_left ( a , x , mid_index + 1 , hi ) help_mybisect_left = lambda a , x , lo , hi : help_mybisect ( a , x , lo , hi , lambda num : num ) help_mybisect_right = lambda a , x , lo , hi : help_mybisect ( a , x , lo , hi , lambda num : num + 1 ) insort&&insort_right 这个函数的代码基本上就是先用 bisect_right 查找出需要插入的位置，然后调用 a.insert 即可。 insort_left 这个函数的代码基本上就是先用 bisect_left 查找出需要插入的位置，然后调用 a.insert 即可。","tags":"Python","loc":"http://chenjiee815.github.io/bisectbiao-zhun-ku-yuan-ma-xue-xi.html","title":"bisect标准库源码学习"},{"text":"Contents 简介 Queue PriorityQueue LifoQueue 简介 在源码文件的首行就说明了该 Queue 是一个支持多生产者、多消费者的队列。 \"\"\"A multi-producer, multi-consumer queue.\"\"\" 既然提到有多个生产者、多个消费者了，说明该 Queue 是支持线程安全的，并且内部的实现应该是在一个正常的队列数据结构基础加上了锁操作（这是我看到这句话所想到的，后面看代码也基本是按照这个思路来的）。 Queue 先入先出队列 支持创建一个有 maxsize 大小的队列，如果 maxsize <= 0，则该队列大小无限大（视可用内存而定）。 默认创建大小无限的队列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class Queue : def __init__ ( self , maxsize = 0 ): self . maxsize = maxsize self . _init ( maxsize ) # 该队列中的核心互斥锁，任何操作都需要进行加锁解锁操作 self . mutex = _threading . Lock () # 用于通知一个元素被放到队列里了 self . not_empty = _threading . Condition ( self . mutex ) # 用于通知一个元素从队列里移出了 self . not_full = _threading . Condition ( self . mutex ) # 用于通知队列中的所有任务都取出来并且完成了 self . all_tasks_done = _threading . Condition ( self . mutex ) # 未完成的任务数 ( 该任务或者在队列里，或者被取出队列 ) self . unfinished_tasks = 0 def task_done ( self ): \"\"\" 通常在消费者线程中取出任务并执行完成后 通知主线程我的任务完成了 \"\"\" # 获取所有任务完成的条件变量 self . all_tasks_done . acquire () try : unfinished = self . unfinished_tasks - 1 if unfinished <= 0 : # 每个任务完成后只能调用该方法一次 if unfinished < 0 : raise ValueError ( 'task_done() called too many times' ) # 通知所有任务已完成 self . all_tasks_done . notify_all () self . unfinished_tasks = unfinished finally : self . all_tasks_done . release () def join ( self ): \"\"\" 通常在主线程里调用该方法，等待所有的消费者线程完成所有任务 \"\"\" # 获取所有任务完成的条件变量 self . all_tasks_done . acquire () try : # 如果还有任务未完成， # 则一直等待所有任务完成的条件成立 while self . unfinished_tasks : self . all_tasks_done . wait () finally : self . all_tasks_done . release () def qsize ( self ): self . mutex . acquire () n = self . _qsize () self . mutex . release () return n def empty ( self ): self . mutex . acquire () n = not self . _qsize () self . mutex . release () return n def full ( self ): self . mutex . acquire () # 不是简单的非空逻辑，还要判断无限大小的情况 n = 0 < self . maxsize == self . _qsize () self . mutex . release () return n def put ( self , item , block = True , timeout = None ): # 取得队列空闲的条件变量 self . not_full . acquire () try : if self . maxsize > 0 : if not block : if self . _qsize () == self . maxsize : raise Full elif timeout is None : while self . _qsize () == self . maxsize : # 如果队列一直为满， # 则等待队列空闲这个条件满足 self . not_full . wait () elif timeout < 0 : raise ValueError ( \"'timeout' must be a non-negative number\" ) else : endtime = _time () + timeout while self . _qsize () == self . maxsize : remaining = endtime - _time () if remaining <= 0.0 : raise Full # 有限的时间等待队列空闲这个条件满足 self . not_full . wait ( remaining ) self . _put ( item ) # 放入一元素，就相当于放入一个非完成的任务 self . unfinished_tasks += 1 # 通知当前队列非空 self . not_empty . notify () finally : self . not_full . release () def put_nowait ( self , item ): \"\"\" 将一个元素放置到队列里，非阻塞版本 如果队列满则抛出 `Full` 异常 \"\"\" return self . put ( item , False ) def get ( self , block = True , timeout = None ): # 取得队列非空的条件变量 self . not_empty . acquire () try : if not block : if not self . _qsize (): raise Empty elif timeout is None : while not self . _qsize (): # 如果当前队列一直为空， # 则等待队列非空这个条件成立 self . not_empty . wait () elif timeout < 0 : raise ValueError ( \"'timeout' must be a non-negative number\" ) else : endtime = _time () + timeout while not self . _qsize (): remaining = endtime - _time () if remaining <= 0.0 : raise Empty # 在有限的时间内等待队列非空这个条件成立 self . not_empty . wait ( remaining ) item = self . _get () # 通知队列有空闲空间 self . not_full . notify () return item finally : self . not_empty . release () def get_nowait ( self ): \"\"\" 从队列中取出一个元素，非阻塞版本 如果队列为空，则抛出 `Empty` 异常 \"\"\" return self . get ( False ) # 下面几个方法可以进行重载来实现新的队列类型。 # 比如下面的 `PriorityQueue` 和 `LifoQueue` 就重载了这些方法。 def _init ( self , maxsize ): self . queue = deque () def _qsize ( self , len = len ): return len ( self . queue ) def _put ( self , item ): self . queue . append ( item ) def _get ( self ): return self . queue . popleft () PriorityQueue 优先级队列 内部队列实现为一个 [] ，且优先级的排序使用的是堆排 heapq 。 传入的每个元素都为一个元组 ( 优先级序号， 数据 ) 。 优先级序号越小，其优先级越高。 1 2 3 4 5 6 7 8 9 10 11 12 13 class PriorityQueue ( Queue ): def _init ( self , maxsize ): self . queue = [] def _qsize ( self , len = len ): return len ( self . queue ) def _put ( self , item , heappush = heapq . heappush ): heappush ( self . queue , item ) def _get ( self , heappop = heapq . heappop ): return heappop ( self . queue ) LifoQueue 后入先出队列 内部的队列实现为一个 [] 。 1 2 3 4 5 6 7 8 9 10 11 12 13 class LifoQueue ( Queue ): def _init ( self , maxsize ): self . queue = [] def _qsize ( self , len = len ): return len ( self . queue ) def _put ( self , item ): self . queue . append ( item ) def _get ( self ): return self . queue . pop ()","tags":"Python","loc":"http://chenjiee815.github.io/queuebiao-zhun-ku-yuan-ma-xue-xi.html","title":"Queue标准库源码学习"},{"text":"Contents ShishD 第四条建议 PizzaD 这一章节就针对上一章节暴露的问题，提出的了解决方法： 访问者模式 ShishD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 访问者 class OnlyOnionsV { boolean forSkewer () { return true ; } boolean forOnion ( ShishD s ) { return s . onlyOnions (); } boolean forLamb ( ShishD s ) { return false ; } boolean forTomato ( ShishD s ) { return false ; } } class IsVegetarianV { boolean forSkewer () { return ture ; } boolean forOnion ( ShishD s ) { return s . IsVegetarian (); } boolean forLamb ( ShishD s ) { return false ; } boolean forTomato ( ShishD s ) { return s . IsVegetarian (); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 使用访问者模式的 ShishD // 这里可以对比一下第二章节的 ShishD 代码 abstract class ShishD { // 羊肉 OnlyOnionsV ooFn = new OnlyOnionsV (); IsVegetarianV ivFn = new IsVegetarianV (); abstract boolean onlyOnions (); abstract boolean IsVegetarian (); } class Skewer extends ShishD { // 串 boolean onlyOnions () { return ooFn . forSkewer (); } boolean IsVegetarian () { return ivFn . forSkewer (); } } class Onion extends ShishD { // 洋葱 ShishD s ; Onion ( ShishD _s ) { s = _s ; } boolean onlyOnions () { return ooFn . forOnion ( s ); } boolean IsVegetarian () { return ivFn . forOnion ( s ); } } class Lamb extends ShishD { // 羔羊肉 ShishD s ; Lamb ( ShishD _s ) { s = _s ; } boolean onlyLambs () { return ooFn . forLamb ( s ); } boolean IsVegetarian () { return ivFn . forLamb ( s ); } } class Tomato extends ShishD { // 西红柿 ShishD s ; Tomato ( ShishD _s ) { s = _s ; } boolean onlyTomatos () { return ooFn . forTomato ( s ); } boolean IsVegetarian () { return ivFn . forTomato ( s ); } } 第四条建议 当需要给多个来自于同一个自引用的数据类型的变体类型编写方法时，使用访问者模式，这样所有的方法就会集中一个类中。 PizzaD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 abstract class PizzaD { // 披萨饼 RemAV remFn = new RemAV (); TopAwCV topFn = new TopAwCV (); SubAbCV subFn = new SubAbCV (); abstract PizzaD remA (); abstract PizzaD topAwC (); abstract PizzaD subAbC (); } class Crust extends PizzaD { // 面包皮 PizzaD remA () { return remFn . forCrust (); } PizzaD topAwC () { return topFn . forCrust (); } PizzaD subAbC () { return subFn . forCrust (); } } class Cheese extends PizzaD { // 奶酪 PizzaD p ; Cheese ( PizzaD _p ) { p = _p ; } PizzaD remA () { return remFn . forCheese ( p ); } PizzaD topAwC () { return topFn . forCheese ( p ); } PizzaD subAbC () { return subFn . forCheese ( p ); } } Classr Olive extends PizzaD { // 橄榄 PizzaD p ; Olive ( PizzaD _p ) { p = _p ; } PizzaD remA () { return remFn . forOlive ( p ); } PizzaD topAwC () { return topFn . forOlive ( p ); } PizzaD subAbC () { return subFn . forOlive ( p ); } } class Anchovy extends PizzaD { // 凤尾鱼 PizzaD p ; Anchovy ( PizzaD _p ) { p = _p ; } PizzaD remA () { return remFn . forAnchovy ( p ); } PizzaD topAwC () { return topFn . forAnchovy ( p ); } PizzaD subAbC () { return subFn . forAnchovy ( p ); } } class Sausage extends PizzaD { // 香肠 PizzaD p ; Sausage ( PizzaD _p ) { p = _p ; } PizzaD remA () { return remFn . forSausage ( p ); } PizzaD topAwC () { return topFn . forSausage ( p ); } PizzaD subAbC () { return subFn . forSausage ( p ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class RemAV { PizzaD forCrust () { return new Crust (); } PizzaD forCheese ( PizzaD p ) { return new Cheese ( p . remA ()); } PizzaD forOlive ( PizzaD p ) { return new Olive ( p . remA ()); } PizzaD forAnchovy ( PizzaD p ) { return p . remA (); } PizzaD forSausage ( PizzaD p ) { return new Sausage ( p . remA ()); } } class TopAwCV { PizzaD forCrust () { return new Crust (); } PizzaD forCheese ( PizzaD p ) { return new Cheese ( p . topAwC ()); } PizzaD forOlive ( PizzaD p ) { return new Olive ( p . topAwC ()); } PizzaD forAnchovy ( PizzaD p ) { return new Cheese ( new Anchovy ( p . topAwC ())); } PizzaD forSausage ( PizzaD p ) { return new Sausage ( p . topAwC ()); } } class SubAbCV { PizzaD forCrust () { return new Crust (); } PizzaD forCheese ( PizzaD p ) { return new Cheese ( p . subAbC ()); } PizzaD forOlive ( PizzaD p ) { return new Olive ( p . subAbC ()); } PizzaD forAnchovy ( PizzaD p ) { return new Cheese ( p . subAbC ()); } PizzaD forSausage ( PizzaD p ) { return new Sausage ( p . subAbC ()); } }","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-come-to-our-carousel.html","title":"A Little Java, A Few Patterns: Come to Our Carousel"},{"text":"Contents 简介 OrderedDict namedtuple Counter _abcoll.py 简介 collections 库包含两个文件 collections.py 和 _abcoll.py 。 至于为什么要拆分成两个文件， collections 库在文件一开始就在注释里写到： For bootstrapping reasons, the collection ABCs are defined in _abcoll.py. They should however be considered an integral part of collections.py. 我刚开始找不出它这个 bootstrapping reasons, 后来 google 了一下，发现这个 bootstrapping reasons 的解释。 不过这个链接里说 collections 会引用 os ， 而 os 又会引用 _abcoll ，如果 collections 和 _abcoll 的代码在一起，会造成循环引用。 但是我代码看了头天也没发现 collections.py 文件中有 import os 的地方。 好吧，这个问题咱先不追究了，还是分析主要代码要紧。 Tip deque, defaultdict 这两个类是用 C 实现的，暂且不表。 OrderedDict OrderedDict ，一看名字就知道，它会记住每个 Key 的插入顺序。当然，它还是一个 dict ，所以从 dict 继承也是理所当然的。 它只从 dict 类继承了 __getitem__ 、 __len__ 、 __contains__ 和 get 。其它的操作都是顺序敏感的，所以需要重载。 它的时间复杂度还是和 dict 是一样的。 具体实现思路是 : 用双端循环链表来保存 Key 值 , 其中每个节点为 [PREV, NEXT, KEY], 该链表初始化时有一个哨兵节点 , 该节点永远不会被删除 ( 这样算法实现起来简单一点 ). 使用 self.__map 来保存 Key 值和对应的双端循环链表中的节点的映射关系 . 使用继承的 dict 功能来保存 Key 和对应 Value 的映射关系 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class OrderedDict ( dict ): def __init__ ( self , * args , ** kwds ): \"\"\" 这里虽然提供了 `kwds` ，但是不建议传入多个命名参数 因为这些参数的顺序是随意的，不是按照你传入的顺序来的 \"\"\" if len ( args ) > 1 : raise TypeError ( 'expected at most 1 arguments, got %d ' % len ( args )) try : self . __root except AttributeError : # 哨兵元素 self . __root = root = [] # 双端循环链表 root [:] = [ root , root , None ] self . __map = {} self . __update ( * args , ** kwds ) def __setitem__ ( self , key , value , dict_setitem = dict . __setitem__ ): 'od.__setitem__(i, y) <==> od[i]=y' if key not in self : # 向链表中插入新的 Key 节点 # self.__map 中添加 Key 和 Key 节点的映射关系 root = self . __root last = root [ 0 ] last [ 1 ] = root [ 0 ] = self . __map [ key ] = [ last , root , key ] # 使用继承的 dict 功能来保存 Key 和对应 Value 的映射关系 return dict_setitem ( self , key , value ) def __delitem__ ( self , key , dict_delitem = dict . __delitem__ ): 'od.__delitem__(y) <==> del od[y]' dict_delitem ( self , key ) # 先从映射关系中根据 Key 找到 Key 节点 , 然后再删除双端循环列表对应的 Key 节点 link_prev , link_next , _ = self . __map . pop ( key ) link_prev [ 1 ] = link_next # update link_prev[NEXT] link_next [ 0 ] = link_prev # update link_next[PREV] def __iter__ ( self ): 'od.__iter__() <==> iter(od)' # Traverse the linked list in order. root = self . __root curr = root [ 1 ] # start at the first node while curr is not root : yield curr [ 2 ] # yield the curr[KEY] curr = curr [ 1 ] # move to next node def __reversed__ ( self ): 'od.__reversed__() <==> reversed(od)' # Traverse the linked list in reverse order. root = self . __root curr = root [ 0 ] # start at the last node while curr is not root : yield curr [ 2 ] # yield the curr[KEY] curr = curr [ 0 ] # move to previous node def clear ( self ): 'od.clear() -> None. Remove all items from od.' root = self . __root root [:] = [ root , root , None ] self . __map . clear () dict . clear ( self ) # 以下的操作方法 , 都不依赖于对链表和 self.__map 的操作了 # 可以说上面那些方法是底层 API, 下面的是高层 API # 这些方法的代码也不全部列出来的，都比较简单 ... ... update = MutableMapping . update # 再命名一个 `__update` 是专门给 __init__ 用的 # 不然，用户继承该类并重载了 __update，就对该类产生了破坏 __update = update # 该 Object 实例在 Python 中是独一无二的 __marker = object () ... ... def __reduce__ ( self ): 可以让 Pickle 进行序列化和反序列化 items = [[ k , self [ k ]] for k in self ] inst_dict = vars ( self ) . copy () for k in vars ( OrderedDict ()): inst_dict . pop ( k , None ) if inst_dict : return ( self . __class__ , ( items ,), inst_dict ) return self . __class__ , ( items ,) ... ... 其实完全可以将双端循环链表这个概念单独抽来出来做为一个类。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class DoubleLink ( object ): \"\"\" 双端循环链表 \"\"\" def __init__ ( self ): super ( DoubleLink , self ) . __init__ () self . __root = root = [] root [:] = [ root , root , None ] self . __map = {} def add ( self , key ): # 每次都是在哨兵节点的前面插入一个新的节点 # 每次插入的节点逻辑上为最后一个节点 root = self . __root last = root [ 0 ] last [ 1 ] = root [ 0 ] = self . __map [ key ] = [ last , root , key ] def delete ( self , value ): prev , next , _ = self . __map . pop ( key ) prev [ 1 ] = next next [ 0 ] = prev def __iter__ ( self ): root = self . __root # 哨兵节点不用参与遍历 curr = root [ 1 ] # start at the first node while curr is not root : yield curr [ 2 ] # yield the curr[KEY] curr = curr [ 1 ] # move to next node def __reversed__ ( self ): root = self . __root # 哨兵节点不用参与遍历 curr = root [ 0 ] # start at the last node while curr is not root : yield curr [ 2 ] # yield the curr[KEY] curr = curr [ 0 ] # move to previous node def clear ( self ): root = self . __root # 这一行 , 猛一看还以为写错了 # 后来仔细想了一下 , [root, root, None] 中的 root 其实是一个引用 ( 引用本身不保存任何值 , 相当于指针 ) # 当赋值给 root[:] 时 , 直接清除了 root 中原来保存的值 # 直接变成 [root 引用 , root 引用 , None] root [:] = [ root , root , None ] self . __map . clear () 这样，OrderedDict 实现起来就好看多了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class OrderedDict ( dict ): def __init__ ( self , * args , ** kwds ): if len ( args ) > 1 : raise TypeError ( 'expected at most 1 arguments, got %d ' % len ( args )) self . __dl = DoubleLink () self . __update ( * args , ** kwds ) def __setitem__ ( self , key , value , dict_setitem = dict . __setitem__ ): if key not in self : self . __dl . add ( key ) return dict_setitem ( self , key , value ) def __delitem__ ( self , key , dict_delitem = dict . __delitem__ ): 'od.__delitem__(y) <==> del od[y]' dict_delitem ( self , key ) self . __dl . delete ( key ) __iter__ = self . __dl . __iter__ __reversed__ = self . __dl . __reversed__ def clear ( self ): self . __dl . clear () dict . clear ( self ) ... ... namedtuple 之前在用 namedtuple 时就奇怪 , 这个家伙不是一个类么 , 怎么没有首字母大写 . 后来看了一下代码 , 原来实现成函数了 . 官方文档对其介绍直接了当 : factory function for creating tuple subclasses with named fields `namedtuple` 是创建附带命名字段的 tuple 子类的工厂方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 _class_template = ''' \\ class {typename}(tuple): # 这里的 tuple 很奇怪，为什么不用 _tuple '{typename}({arg_list})' # 避免自动从 tuple 继承 __dict__， 减少内存消耗 __slots__ = () _fields = {field_names!r} def __new__(_cls, {arg_list}): 'Create new instance of {typename}({arg_list})' return _tuple.__new__(_cls, ({arg_list})) @classmethod def _make(cls, iterable, new=tuple.__new__, len=len): # 这里的 tuple 也是 'Make a new {typename} object from a sequence or iterable' result = new(cls, iterable) if len(result) != {num_fields:d}: raise TypeError('Expected {num_fields:d} arguments, got %d ' % le n(result)) return result def __repr__(self): 'Return a nicely formatted representation string' return '{typename}({repr_fmt})' % s elf def _asdict(self): 'Return a new OrderedDict which maps field names to their values' return OrderedDict(zip(self._fields, self)) def _replace(_self, **kwds): 'Return a new {typename} object replacing specified fields with new values' result = _self._make(map(kwds.pop, {field_names!r}, _self)) if kwds: raise ValueError('Got unexpected field names: %r ' % kwds.keys()) return result def __getnewargs__(self): 'Return self as a plain tuple. Used by copy and pickle.' return tuple(self) __dict__ = _property(_asdict) def __getstate__(self): 'Exclude the OrderedDict from pickling' pass {field_defs} ''' _repr_template = '{name}= %r ' _field_template = ''' \\ {name} = _property(_itemgetter({index:d}), doc='Alias for field number {index:d}') ''' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def namedtuple ( typename , field_names , verbose = False , rename = False ): # filed_names 支持两种形式： # 1. 以，号或者空白字符分割的字符串 , \"x, y, z\", \"x y z\" ... ... # 2. 生成器 if isinstance ( field_names , basestring ): field_names = field_names . replace ( ',' , ' ' ) . split () field_names = map ( str , field_names ) # 有些字段重名 /Python 关键字 / 命名不规范等等，需要重新命名 # 打开 rename 参数，就会对这些情况进行重新命名 # 多用于自动生成 namedtuple 的情况，比如自从从数据库中获取数据 if rename : seen = set () for index , name in enumerate ( field_names ): if ( not all ( c . isalnum () or c == '_' for c in name ) or _iskeyword ( name ) or not name or name [ 0 ] . isdigit () or name . startswith ( '_' ) or name in seen ): field_names [ index ] = '_ %d ' % index seen . add ( name ) # 还是对字段名进行合法性校验 for name in [ typename ] + field_names : if not all ( c . isalnum () or c == '_' for c in name ): raise ValueError ( 'Type names and field names can only contain ' 'alphanumeric characters and underscores: %r ' % name ) if _iskeyword ( name ): raise ValueError ( 'Type names and field names cannot be a ' 'keyword: %r ' % name ) if name [ 0 ] . isdigit (): raise ValueError ( 'Type names and field names cannot start with ' 'a number: %r ' % name ) seen = set () for name in field_names : if name . startswith ( '_' ) and not rename : raise ValueError ( 'Field names cannot start with an underscore: ' ' %r ' % name ) if name in seen : raise ValueError ( 'Encountered duplicate field name: %r ' % name ) seen . add ( name ) # 生成类的定义 class_definition = _class_template . format ( typename = typename , field_names = tuple ( field_names ), num_fields = len ( field_names ), arg_list = repr ( tuple ( field_names )) . replace ( \"'\" , \"\" )[ 1 : - 1 ], repr_fmt = ', ' . join ( _repr_template . format ( name = name ) for name in field_names ), field_defs = ' \\n ' . join ( _field_template . format ( index = index , name = name ) for index , name in enumerate ( field_names )) ) if verbose : # 用于调试 print class_definition # Execute the template string in a temporary namespace and support # tracing utilities by setting a value for frame.f_globals['__name__'] # 在一个新的命名空间里创建 namedtuple，应该是为了安全考虑 namespace = dict ( _itemgetter = _itemgetter , __name__ = 'namedtuple_ %s ' % typename , # 指定 namedtuple.__module__ 的值 OrderedDict = OrderedDict , _property = property , _tuple = tuple , ) try : exec class_definition in namespace except SyntaxError as e : raise SyntaxError ( e . message + ': \\n ' + class_definition ) result = namespace [ typename ] # _sys._getframe(1): 获取创建 namedtuple 的栈帧 # 并将该栈帧的名称赋值指给该 namedtuple 的 __module__， # 让 pickle 模块在序列化时能找到该 namedtuple 所在的模块 # Jython 未定义 sys._getframe， # IronPython 虽然定义了 sys._getframe 但是参数只能为 0（即当前栈帧） try : result . __module__ = _sys . _getframe ( 1 ) . f_globals . get ( '__name__' , '__main__' ) except ( AttributeError , ValueError ): pass return result 如果有谁奇怪 namedtuple 的实现方式的话，可以看一下官方 issue 列表： collections.namedtuple uses exec to create new classes 里面可能有你想要的答案，反正我看了还是不理解这种奇怪的实现方式。 当然除了上面的官方 issue 列表链接中，有人贴出来了 diff 来展示不用 exec 的实现方式。 这有这个 地址 ，也实现了另外一种不用 exec 来实现 namedtuple 的方式。 Counter 在其它语言中叫做 MultiSet（C++）或者 Bag（Lua），翻译为多重集合。 相当于集合的扩展版本，集合是不允许内部有相同元素的，但是多重集合允许。 当然 Python 的这个 Counter，在功能上来说，比一般的多重集合还更为强大一点，它是兼有多重集合和字典的特性。 基本了解到 Counter 是什么，下面的代码其实就不用怎么看了，没有什么比较复杂的代码，所以有些我直接省略掉了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Counter ( dict ): def __init__ ( self , iterable = None , ** kwds ): super ( Counter , self ) . __init__ () self . update ( iterable , ** kwds ) def __missing__ ( self , key ): \"\"\" 如果 Counter()[key] 中的 key 不存在，则返回 0\"\"\" return 0 def most_common ( self , n = None ): \"\"\" 列出最多的键值对，n 参数指定列出最多的前几个键值对 \"\"\" if n is None : return sorted ( self . iteritems (), key = _itemgetter ( 1 ), reverse = True ) return _heapq . nlargest ( n , self . iteritems (), key = _itemgetter ( 1 )) def elements ( self ): \"\"\" 列出多重集合中的所有元素，重复的元素会输出多个 \"\"\" return _chain . from_iterable ( _starmap ( _repeat , self . iteritems ())) @classmethod def fromkeys ( cls , iterable , v = None ): # 由于从 dict 继承过来，但是 Counter 又不支持该操作，就直接重载抛出异常 raise NotImplementedError ( 'Counter.fromkeys() is undefined. Use Counter(iterable) instead.' ) def update ( self , iterable = None , ** kwds ): \"\"\" 类似于 dict.update，没什么好讲的 \"\"\" ... ... def subtract ( self , iterable = None , ** kwds ): \"\"\" 也类似于 dcit.update, 不过操作的逻辑是相反的 \"\"\" ... ... def copy ( self ): \"\"\" 复制出自己一份，也是 dict 本身就有的方法，重载一下 \"\"\" 'Return a shallow copy.' return self . __class__ ( self ) def __reduce__ ( self ): \"\"\" 能够让 pickle 进行序列化和反序列化 \"\"\" return self . __class__ , ( dict ( self ),) def __delitem__ ( self , elem ): if elem in self : # 如果 Key 值不存在，不需要抛出异常 super ( Counter , self ) . __delitem__ ( elem ) def __repr__ ( self ): ... ... # 重载 Counter 的运行操作，支持相加、相减、交集、并集 # 代码就不列出来了 ... ... _abcoll.py 该模块里面代码都是比较简单的。 一种用来提供 isinstance 判断某种类属于哪种类型。 本质上就是判断某个类有没有特定的方法， 但是使用 isinstance 来判断，比较优雅且明了。 另外一种是用来提供 mixin 功能的。 有关该模块的详细方法可阅读 collections 官方文档","tags":"Python","loc":"http://chenjiee815.github.io/collectionsbiao-zhun-ku-yuan-ma-xue-xi.html","title":"collections标准库源码学习"},{"text":"学习编程不仅是学习一门编程语言的语法和方法，更需要学习如何 程序设计 。任何一本好的讲编程的书籍都需要教会人们程序设计。 在学校里教授的那些程序设计之类的课程，总会和一系列实际使用到的语言绑定在一起。 Felleisoen 和 Friedman 这两位大师将函数式编程很自然地引导到众所周知的面向对象编程。他们将两种编程范式无缝地结合在一起，并且展示它们是如何很好地一起工作地。他们写的这本书就证明了函数式编程与面向对象编程并不冲突，反而能够很好的支持面向对象编程。 我并不惊讶于他们的成功（将两种编程范完美无缺地结合在一起）。因为我已经在好多年前从 Smalltalk 语言中了解到这一概念了。但不幸的是，这么多年过去了，它仍然是面向对象设计中的众多秘密之一。我很高兴 Felleisoen 和 Friedman 最终揭开了它的面目。如是你是一名 C++ 程序员，正在学习 Java，并且对从未了解过函数式设计，那这本书对你来说就尤其有用。如果你了解过函数式设计，那么这本书会用一优雅的方式向你介绍 Java 中基于模式的编程。如果你不了解， Felleisoen 和 Friedman 将会教会你一个强大的新的思维方法。 享受一下披萨吧。","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-qian-yan.html","title":"A Little Java, A Few Patterns: 前言"},{"text":"下面就是一些有关 Java 体验的提示： 在一个文件中给出类的完整层次。 对于每个命名不以上标 D、V、I、M 结尾的类，添加 toString 方法，并遵守以下规则： 如果一个类没有属性 1 2 3 public String toString () { return \"new \" + getClass (). getName () + \"()\" ; } 如果一个类只有一个属性，比如叫 x 1 2 3 public String toString () { return \"new \" + getClass (). getName () + \"(\" + x + \")\" ; } 如果一个类有两个属性，比如叫 x 和 y 1 2 3 public String toString () { return \"new \" + getClass (). getName () + \"(\" + x + \", \" + y + \")\" ; } 在文件的底部添加如下类： 1 2 3 4 5 6 class Main { public static void main ( String args []) { DataType_or_Interface y = new ______ ; System . out . println ( ... ... ); } } DataType_or_Interface y = new ______; 是用来创建你想尝试的对象。 System.out.println( ... ... ); 是用来填写你想尝试的表达式。 比如，你想尝试第 2 章定义的 ManhattanPt 的 distanceTo0 方法，你就可以添加如下代码到你文件的最后： 1 2 3 4 5 6 public class Main { public static void main ( String args []) { PointD y = new ManhattanPt ( 2 , 8 ); System . out . println ( y . distanceTo0 ()); } } 如果你想尝试多条表达式，就修改 y ，就像第 10 章里， y._ _ _ _ _ _; y._ _ _ _ _ _; y._ _ _ _ _ _ 替换成 y._ _ _ _ _ _ + \"\\n\" + y._ _ _ _ _ _ + \"\\n\" + y._ _ _ _ _ _ 如果你想尝试第 10 章中定义的 PiemanM 的多个方法，那么你就将以下代码写在文件的最后面： 1 2 3 4 5 6 7 8 9 10 class Main { public static void main ( String args []) { PiemanI y = new PiemanM (); System . out . println ( y . addTop ( new Anchovy ()) + \"\\n\" + y . addTop ( new Anchovy ()) + \"\\n\" + y . substTop ( new Tuna (), new Anchovy ()) ); } } 最后，编译文件并且执行 Main 类。 Tip 按照上面的要求，保存的代码的文件名同时也要为 Main.java 。( 因为 Java 会根据文件名来查找其文件内同名的类，再执行该类的 main 方法 ) 然后使用 javac Main.java 来进行编译生成 Main.class 中间码文件。 最后， java Main 来执行程序。 建议大家上网搜索一下 Java helloworld 看一下相关教程就可以了。暂时不用深入学习 Java 。","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-javaxiao-yong.html","title":"A Little Java, A Few Patterns： Java小用"},{"text":"Contents PizzaD 第三条建议 PizzaD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 abstract class PizzaD { // 比萨饼 abstract PizzaD remA (); // 去除比萨饼中的凤尾鱼顶料 ( 因为太咸了 ) abstract PizzaD topAwC (); // 在凤尾鱼顶料上加上奶酪顶料 ( 这样会盖住凤尾鱼的咸味 ) abstract PizzaD subAbC (); // 将所有的凤尾鱼顶料换成奶酪顶料 } class Crust extends PizzaD { // 面包皮 PizzaD subAbC (){ return new Crust (); } PizzaD topAwC (){ return new Crust (); } PizzaD subAbC (){ return new Crust (); } } // 下面是各种顶料 class Cheese extends PizzaD { // 奶酪 PizzaD p ; Cheese ( PizzaD _p ) { p = _p ; } PizzaD remA (){ return new Cheese ( p . remA ()); } PizzaD topAwC (){ return new Cheese ( p . topAwC ()); } PizzaD subAbC (){ return new Cheese ( p . subAbC ()); } } class Olive extends PizzaD { // 橄榄 PizzaD p ; Olive ( PizzaD _p ) { p = _p ; } PizzaD remA (){ return new Olive ( p . remA ()); } PizzaD topAwC (){ return new Olive ( p . topAwC ()); } PizzaD subAbC (){ return new Olive ( p . subAbC ()); } } class Anchovy extends PizzaD { // 凤尾鱼 PizzaD p ; Anchovy ( PizzaD _p ) { p = _p ; } PizzaD remA (){ return p . remA (); } PizzaD topAwC (){ return new Cheese ( new Anchovy ( p . topAwC ())); } PizzaD subAbC (){ return new Cheese ( p . subAbC ()); } } class Sausage extends PizzaD { // 香肠 PizzaD p ; Sausage ( PizzaD _p ) { p = _p ; } PizzaD remA (){ return new Sausage ( p . remA ()); } PizzaD topAwC (){ return new Sausage ( p . topAwC ()); } PizzaD subAbC (){ return new Sausage ( p . subAbC ()); } } 如果想要在比萨饼上面添加额外的顶料怎么办？ 很简单，再从 PizzaD 扩展出一个新的变体类型就可以了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Spinach extends PizzaD { // 菠菜 PizzaD p ; Spinach ( PizzaD _p ) { p = _p ; } PizzaD remA (){ return new Spinach ( p . remA ()); } PizzaD topAwC (){ return new Spinach ( p . topAwC ()); } PizzaD subAbC (){ return new Spinach ( p . subAbC ()); } } 但是每添加一个新的变体类型都要加上三个方法，好累的说。 有什么比较好的办法解决这个问题呢？ 下一章节给你答案。 第三条建议 当你写一个返回数据类型的方法时，使用 new 来创建值。","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-whats-new.html","title":"A Little Java, A Few Patterns: What's New?"},{"text":"Contents PointD ShishD 第二条建议 KebabD PointD 上一章讲解了如何在 Java 中的定义类型，这一章主要讲如何向这些类型添加方法。 PointD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 abstract class PointD { abstract int distanceTo0 (); } class CartesianPt extends PointD { // 笛卡尔坐标 int x ; int y ; CartesianPt ( int _x , int _y ){ x = _x ; y = _y ; } int distanceTo0 (){ return ( int ) Math . sqrt ( x * x + y * y ); } } class ManhattanPt extends PointD { // 曼哈顿坐标 int x ; int y ; ManhattanPt ( int _x , int _y ){ x = _x ; y = _y ; } int distanceTo0 (){ return x + y ; } } 当具体类从抽象类继承时，需要同时具体出抽象类中的抽象方法。 ShishD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 下面的例子中各类的一层层的套在一起，你可以理解成一个烤串 abstract class ShishD { // 羊肉 abstract boolean onlyOnions (); // 烤串上是不是只有洋葱 abstract boolean isVegetarian (); // 烤串上是不是全是蔬菜 } class Skewer extends ShishD { // 串 boolean onlyOnions (){ return true ; } boolean isVegetarian (){ return true ; } } class Onion extends ShishD { // 洋葱 ShishD s ; Onion ( ShishD _s ) { s = _s ; } boolean onlyOnions (){ return s . onlyOnions (); } boolean isVegetarian (){ return s . isVegetarian (); } } class Lamb extends ShishD { // 羔羊肉 ShishD s ; Lamb ( ShishD _s ) { s = _s ; } boolean onlyOnions (){ return false ; } boolean isVegetarian (){ return false ; } } class Tomato extends ShishD { // 西红柿 ShishD s ; Tomato ( ShishD _s ) { s = _s ; } boolean onlyOnions (){ return false ; } boolean isVegetarian (){ return s . isVegetarian (); } } 第二条建议 当在数据类型中添加了一个方法，就需要在它所有的变体类型中添加对应的方法。 如果一个变体类型的一个属性和它同属于一个数据类型，该方法在进行运算时就会调用该属性对应的方法。 KebabD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 abstract class KebabD { // 烤肉 abstract boolean isVeggie (); // 是否是纯蔬菜为辅料的烤肉 abstract Object whatHolder (); // 烤肉的摆放工具是什么 } class Holder extends KebabD { // 烤肉摆放工具（意译） Object o ; Holder ( Object _o ) { o = _o ; } boolean isVeggie (){ return true ; } Object whatHolder (){ return o ; } } class Shallot extends KebabD { // 葱 KebabD k ; Shallot ( KebabD _k ) { k = _k ; } boolean isVeggie (){ return k . isVeggie (); } Object whatHolder (){ return k . whatHolder (); } } class Shrimp extends KebabD { // 小虾 KebabD k ; Shrimp ( KebabD _k ) { k = _k ; } boolean isVeggie (){ return false ; } Object whatHolder (){ return k . whatHolder (); } } class Radish extends KebabD { // 萝卜 KebabD k ; Radish ( KebabD _k ) { k = _k ; } boolean isVeggie (){ return k . isVeggie (); } Object whatHolder (){ return k . whatHolder (); } } class Pepper extends KebabD { // 胡椒粉 KebabD k ; Pepper ( KebabD _k ) { k = _k ; } boolean isVeggie (){ return k . isVeggie (); } Object whatHolder (){ return k . whatHolder (); } } class Zucchini extends KebabD { // 西葫芦 KebabD k ; Zucchini ( KebabD _k ) { k = _k ; } boolean isVeggie (){ return k . isVeggie (); } Object whatHolder (){ return k . whatHolder (); } } 定义一下烤肉摆放的工具。 大致分成两种 : 一种是将烤肉串起来的工具 1 2 3 4 5 6 7 abstract class RodD {} // 杆，用于将烤肉串起来 class Dagger extends RodD {} // 匕首 class Sabre extends RodD {} // 军刀 class Sword extends RodD {} // 剑 一种将烤肉平铺的工具。 1 2 3 4 5 6 7 8 9 10 11 abstract class PlateD {} // 盘子 class Gold extends PlateD {} // 金盘子 class Silver extends PlateD {} // 银盘子 class Brass extends PlateD {} // 黄铜盘子 class Copper extends PlateD {} // 镀铜盘子 class Wood extends PlateD {} // 木盘子 PointD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 abstract class PointD { abstract int distanceTo0 (); } class CartesianPt extends PointD { // 笛卡尔坐标 int x ; int y ; CartesianPt ( int _x , int _y ){ x = _x ; y = _y ; } int distanceTo0 (){ return ( int ) Math . sqrt ( x * x + y * y ); } boolean closerTo0 ( CartesianPt p ){ return distanceTo0 () <= p . distanceTo0 (); } } class ManhattanPt extends PointD { // 曼哈顿坐标 int x ; int y ; ManhattanPt ( int _x , int _y ){ x = _x ; y = _y ; } int distanceTo0 (){ return x + y ; } boolean closerTo0 ( ManhattanPt p ){ return distanceTo0 () <= p . distanceTo0 (); } } 抽取变体类型中公共的部分到抽象类型中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 abstract class PointD { int x ; int y ; PointD ( int _x , int _y ){ x = _x ; y = _y ; } abstract int distanceTo0 (); boolean closerTo0 ( PointD p ){ return distanceTo0 () <= p . distanceTo0 (); } } class CartesianPt extends PointD { // 笛卡尔坐标 CartesianPt ( int _x , int _y ){ super ( _x , _y ); } int distanceTo0 (){ return ( int ) Math . sqrt ( x * x + y * y ); } } class ManhattanPt extends PointD { // 曼哈顿坐标 ManhattanPt ( int _x , int _y ){ super ( _x , _y ); } int distanceTo0 (){ return x + y ; } }","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-methods-to-our-madness.html","title":"A Little Java, A Few Patterns: Methods to Our Madness"},{"text":"Contents SeasoningD PointD NumD 第一条建议 LayerD 这一章节，作者主要想通过一系列的对话，让你了解到 Java 中基本类型是什么东东（只介绍了 int, boolean 类型）。以及如何使用 Java 自定义类型。 类型是什么？ 类型是一类值的集合的命名 SeasoningD 1 2 3 4 5 6 7 8 9 abstract class SeasoningD {} // 调味品 class Salt extends SeasoningD {} // 盐 class Pepper extends SeasoningD {} // 胡椒粉 class Thyme extends SeasoningD {} // 百里香 class Sage extends SeasoningD {} // 鼠尾草 上面的代码就定义了 SeasoningD 类型，以其它的四个变体类型。 虽然四个变体类型没有定义 构造函数 ，但是 Java 会自动添加一个默认的构造函数。 PointD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 abstract class PointD {} class CartesianPt extends PointD { // 笛卡尔 int x ; int y ; CartesianPt ( int _x , int _y ){ x = _x ; y = _y ; } } class ManhattanPt extends PointD { // 曼哈顿 int x ; int y ; ManhattanPt ( int _x , int _y ){ x = _x ; y = _y ; } } PointD 的两个变体类型就手动添加了构造函数，因为它们需要有额外的属性传入构造函数。 当使用 new 关键字时， Java 会通过调用类的构造函数来生成其对应的实例。 对抽象类直接使用 new 关键字是不行的，因为抽象类是一个未完全定义的类，无法实例化。 NumD 1 2 3 4 5 6 7 8 9 10 abstract class NumD {} class Zero extends NumD {} class OneMoreThan extends NumD { NumD predecessor ; OneMoreThan ( NumD _d ){ predecessor = _d ; } } abstract 、 class 、 extends 各代表什么？ abstract 引入了数据类型 class 引入了变体类型 extends 将以上两者联系起来 第一条建议 当你想要明确一类数据时，使用 abstract class XXX {} 来定义数据类型 使用 class XXX extends XXX {} 来定义其变体类型 LayerD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 abstract class LayerD {} class Base extends LayerD { Object o ; Base ( Object _o ){ o = _o ; } } class Slice extends LayerD { LayerD l ; Slice ( LayerD _l ){ l = _l ; } }","tags":"java","loc":"http://chenjiee815.github.io/a-little-java-a-few-patterns-modern-toys.html","title":"A Little Java, A Few Patterns: Modern Toys"},{"text":"文字版本 生命是一段漫长的旅程 想了，就去做。 输了，从头再来。 摔了，爬起来继续。 赢了，还要继续往前走。 死了，没留下任何遗憾。 我的理解 人总是充满各种各样的欲望，欲望促使人们做着能够满足这些欲望的事。当做完一件事，暂时满足了欲望，没有了遗憾。 但是不久，人又会有新的欲望产生，人又要为新欲望而循环反覆做着一样或者不一样的事。但是人的欲望没有止境，做的事就不会有止境。 所以，没有遗憾也只是暂时的，在你临死时你觉得没有遗憾，那只是你运气好而已。你只是上一个欲望得到了满足，而新的欲望没有开始而已。 啥时候 放下 你才是真的没有遗憾。 代码版本 Python 版本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 import random import time class Person ( object ): UNKNOWN = \"UNKNOWN\" THOUGHT = \"THOUGHT\" LOST = \"LOST\" WON = \"WON\" DIED = \"DIED\" FELL = \"FELL\" def __init__ ( self , lose_interval = 0.03 , win_interval = 0.03 , fall_interval = 0.01 ): super ( Person , self ) . __init__ () self . thing = None self . __status = self . UNKNOWN self . __lose_interval = lose_interval self . __win_interval = win_interval self . __fall_interval = fall_interval def __repr__ ( self ): return \"Person: {0}\" . format ( self . __status ) def __str__ ( self ): return repr ( self ) def get_status ( self ): return self . thing . status if self . thing else Thing . UNKNOWN def thought ( self ): self . __status = self . THOUGHT self . thing = Thing () self . thing . start_do () def lost ( self ): self . __status = self . LOST if self . thing : self . thing . stop_do () time . sleep ( self . __lose_interval ) self . thing = Thing () self . thing . start_do () def won ( self ): self . __status = self . WON if self . thing : self . thing . end_do () time . sleep ( self . __win_interval ) def died ( self ): self . __status = self . DIED self . thing and self . thing . stop_do () def fell ( self ): self . __status = self . FELL if self . thing : self . thing . stop_do () time . sleep ( self . __fall_interval ) self . thing . restart_do () class Thing ( object ): UNKNOWN = 'UNKNOWN' REGRETS = 'REGRETS' NO_REGRETS = 'NO REGRETS' def __init__ ( self ): super ( Thing , self ) . __init__ () self . status = self . UNKNOWN def start_do ( self ): self . status = self . REGRETS def stop_do ( self ): if self . status == self . UNKNOWN : self . status = self . REGRETS def end_do ( self ): self . status = self . NO_REGRETS def restart_do ( self ): self . status = self . REGRETS class Life ( object ): MIN_TIMES = 0 MAX_TIMES = 120 def __init__ ( self ): super ( Life , self ) . __init__ () self . __person = Person () self . __times = float ( random . randint ( self . MIN_TIMES , self . MAX_TIMES )) * random . random () self . __progress = ( self . __person . thought , self . __person . lost , self . __person . fell , self . __person . won , ) def __is_end ( self ): return self . __times <= 0.0 def __elapse ( self , default = None ): interval = default if default is not None else random . random () if self . __times >= 0.0 : self . __times -= interval def start ( self ): if self . __is_end (): self . __person . died () return while 1 : for going in self . __progress : going () self . __elapse () if self . __is_end (): self . __person . died () return def get_status ( self ): return self . __person . get_status () def main (): life = Life () life . start () print life . get_status () if __name__ == '__main__' : main ()","tags":"life","loc":"http://chenjiee815.github.io/sheng-ming-shi-yi-duan-man-chang-de-lu-tu.html","title":"生命是一段漫长的旅途"},{"text":"Contents 简历 选择标准 品行 性格 能力 技术题目 笔试 结果反馈 反思自己 我从去年下半年开始 , 就陆续参与公司招聘 Python 工程师 的相关工作 . 当然 , 我毕竟不是专业的 HR, 所以更多地是参与技术面试 . 以前是被别人面试 , 现在是面试别人 , 所以也算是多了一种视角看待自己的职业生涯 . 简历 简历上的每一个字都很重要 !!! 因为面试官在面试之前 , 对面试者的了解仅限于那份简历 , 所以他会细抠简历上每一个字来找出和面试者可交流的点 , 我现在就是这样做的 , 相信其他面试官也是如此 . 简历要真实得体现自己的水平 , 因为一旦你在简历上体现出对某种技能很有自信 , 我会抓住这一点不放 , 在正式面试时会刨根问底 . 简历看多了 , 我就会注意到有些人会将自己弱点在简历上故意不提及 , 因为这一项是简历应该有的 , 但是你没写 , 我就会有疑问了 . 比如 : 有一份简历 , 他的工作经历极简 , 但项目经历一大堆 , 后来问了才知道 , 跳槽比较频繁 , 怪不得没写 . 所以大家要珍惜自己每次的跳槽机会 , 跳太多的话 , 面试官看你简历时 , 首先就会觉得你有点浮躁 , 对企业忠诚度不错 . 我的感觉就是 , 这个人招进来做一段时间就走 , 会导致团队不稳定 . 选择标准 说到选择标准 , 这个可能见仁见智了 . 这里我就说一下我在这方面的体会吧 . 我面试时就注意考察以下几点 : 品行 性格 能力 品行 一个人的品行是一个人的根本所在 . 在职业生涯中一个人的品行就体现在 职业道德 . 职业道德的定义我这边就不说了 , 百度 /Google 什么的一大堆 . 我就举一个真实的例子 : 前一段时间 , 我们公司收到一份应聘简历 . 对方经验足够 , 能力从简历上的反馈也很不错 , 然后也反馈了一个 github 帐号 , 我就上面看了一下他的代码 , 刚开始看时还觉得这个人水平不错 , 但是和他的简历一对比 , 发现一个严重的问题 : 他的 github 上每个项目都对应都他在之前公司工作的每个项目 , 也就是说他 github 上的代码都是他给以前公司写的代码 , 然后他还在简历上说明 : 我的个人项目地址 : https://github... ... 看到这个我就倒吸一个凉气 , 有点不敢相信 , 这个也太明显了 , 我也不清楚对方是怎么想的 , 任何一家仔细看他简历的技术人员都会发现这个问题的 . 这种人完全是 ** 职业道德 ** 的缺失 . 性格 现在的工作 , 基本都不是靠一个人就能够完成的 , 所以很多公司招聘时会特别强调 团队合作能力 . 其实我觉得只要在面试时 , 面试者给人的感觉正常就可以了 ,( 好吧 , 小公司没有大公司有一套心理测试来作分析 , 只能面对面交流 ). 比如我遇到的比较不正常的几位 : 有一位一直笑 , 还各种笑 , 无论问什么问题都在笑 , 重点是还答非所问 , 光靠笑把问题敷衍过去 . 有一位一脸无所谓 , 问啥都漫不经心 . 有一位觉得自己很 NB, 感觉自己以前做的东西很高深 , 一般人搞不来 ( 好吧 , 我以前也有过这种心态 ). 能力 这个点相信大家都同意吧 , 毕竟每家公司在招聘信息中提及的重点 , 大多还是有关能力的 . 其实能力这个点分为两块 : 已掌握的技术能力 快速学习技术的能力 我对应届生以及工作一两年的人着重看第二个能力 , 看他是否有这个潜力 . 考察的点一般有 : 是否有钻研 / 极客精神 , 爱折腾各类计算机相关的技能 是否在自己学习 / 生活时有用计算机技能解决问题 是否参与开源项目 是否经常参与 Stack Overflow SegmentFault 知乎 或其它问答网站的问答 . 对工作经验丰富的人 , 当然着重看第一个能力了 . 这种人简历上的内容相对也是比较丰富的 , 可问的点很多 , 我一般是直接从简历上入手的 . 技术题目 技术面试 , 面试官少不了会问一些或深或浅的技术题目 . 刚开始时 , 我是直接从网上搜索一些常见的技术题目 , 但在实际操作中 , 发现并不理想 . 因为那些题目都太偏理论化了 , 所以我就将自己和同事所遇到的一些问题总结出来 , 并分成了高中低三档的技术题目 . 我在面试时一般会从低档的题目问 , 看面试者的反应 . 对方不屑回答 , 那就跟他解释下 , 我这有三档题目 , 综合考察 . 对方答非所问 , 再问 1~2 次 , 如果还是答非所问 , 直接问下一同档题目 . 对方答得很流利 , 减少低档的问题数 , 增加中 / 高档的问题数 . 对方没答到点子上 , 启发他一下 , 模拟正常和同事交流的场景 . 当然 , 这些题目我暂时不会在博客里全部贴出来 , 万一面试者看到了 , 直接就影响我对他的评审结果了 ( 貌似我的博客也没几个人来 ... ...). 这些技术题目当然更多的是偏向实战经验了 , 我的想法的是 : 既然我们之前遇到了这些问题 , 那么我现在把问题抛给你 , 你是如何解决的 . 笔试 通常情况下 , 如果我们无法从面试者的 github 项目或者他的其它代码中获取到他的编程水平的 , 我们都会给对方发一份笔试题目 , 让他完成并反馈 . 那在接收到他的反馈以后 , 我一般会花上一小段时间来调试他的代码 , 并立即将调试的结果反馈给他 , 希望他能够立即改正 , 并将新版本的代码反馈给我 . 有时候 , 我会故意将我发现的问题分开发送 . 比如第一次我反馈下我发现的某一两个问题 , 等着对方反馈 . 对方反馈完了后 , 我再反馈其它的某一两个问题 , 这样重复两三次 , 看看对方的反应如何 . 因为我毕竟不是在吹毛求疵 , 而是指出对方代码中实实在在的 BUG, 就看对方的反应了 . 其实以上的场景 , 就是真实地模拟正式工作中和同事沟通的场景了 , 所以面试者不要以为笔试只是考的那个题目 , 只要和面试官有任何交流 , 那就是面试 . 结果反馈 一般来说 , 面试最终结果的反馈是由 HR 来做的 . 但我偶尔也客串一下 ( 好吧 , 你说小公司不正规也行 ). 对于有工作经验的面试者我一般只会发正式的拒绝邮件 . 对于应届生 , 如果不是因为技术问题拒绝的 , 一般我会特别附带一下 , 委婉地提及到我们觉得他哪方面能力欠缺的地方 , 希望他能够改正 , 以让他不要在面试其它家公司时不要被同样的原因拒绝 . 反思自己 好了 , 上面都是讲得面试别人的一些心得与体会 . \" 俗话 \" 说得好 : 力的作用是相互的 . 我在面试别人的同时 , 也算是别人面试的过程 . 我在面试完成之后 , 总结面试者的评审结果时 , 也会对照自己 , 给自己也来一份总结 . 比如 : 面试者有什么缺点 , 我自己有没有 , 能不能改正 , 能改则改之 . 面试者有什么优点 , 我有没有 , 能否学习 , 能学则学之 . 面试者什么举动什么语言 , 犯到了自己 , 那么自己以后要避免犯到别人 . 我有什么举动什么语言犯到了面试者 , 那么自己以后也要注意 .","tags":"职业生涯","loc":"http://chenjiee815.github.io/mian-shi-guan-gan-wu.html","title":"面试官感悟"},{"text":"Contents 简介 _complain_ifclosed StringIO 简介 StringIO 有一个 C 语言实现的版本 cStringIO 。 C 语言版本更快，但不是能创建子类，因为 C 语言版本实现为一个方法了。 StringIO 主要是用来模拟一个 file 对象的行为的。 代码注释里说 Using a real file is often faster (but less convenient). 之前我还困惑 StringIO 不是相当于一个内存对象么，真实的文件对象需要操作磁盘啊，怎么反而更快？ 后来我在 Stack Overflow 上问一下，原来是指代码执行的速度， Python 的内置文件对象是用 C 语言实现的。而 StringIO 是用 Python 代码实现的，当然慢了。 代码注释里还说 Seeking far beyond EOF and then writing will insert real null bytes that occupy space in the buffer. 这个好理解，我直接上代码就清楚了。 1 2 3 4 5 6 7 8 9 10 In [ 130 ]: from StringIO import StringIO In [ 131 ]: s = StringIO ( \"abc\" ) In [ 132 ]: s . seek ( 10 ) In [ 133 ]: s . write ( \"end\" ) In [ 134 ]: s . getvalue () Out [ 134 ]: 'abc \\x00\\x00\\x00\\x00\\x00\\x00\\x00 end' _complain_ifclosed 1 2 3 def _complain_ifclosed ( closed ): if closed : raise ValueError , \"I/O operation on closed file\" 这个方法是 StringIO 的辅助方法，用来检查当前操作的 StringIO 是否已经关闭，如果关闭，则直接抛出异常。 在接下来的代码中，你会看到在多个方法里面手工调用该函数。 其实，这里可以考虑先定义一个元类，针对那些需要调用该函数的方法，先在元类里面就统一调用一下，那么 StringIO 就不用关心当前的状态是否为开还是关了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class ClosedStatusChecker ( type ): def __init__ ( cls , name , bases , dct ): super ( ClosedStatusChecker , cls ) . __init__ ( name , bases , dct ) need_check_funcs = dct . pop ( \"need_check_funcs\" , None ) if need_check_funcs : def check_func ( fname ): def _check_func ( self , * args , ** kwargs ): if self . closed : raise ValueError ( \"I/O operation on closed file\" ) return dct [ fname ]( self , * args , ** kwargs ) return _check_func for fname in need_check_funcs : setattr ( cls , fname , check_func ( fname )) class StringIO : __metaclass__ = ClosedStatusChecker need_check_funcs = ( \"next\" , \"isatty\" , ... ... ) def __init__ ( self , buf = '' ): if not isinstance ( buf , basestring ): buf = str ( buf ) self . buf = buf self . len = len ( buf ) self . buflist = [] self . pos = 0 self . closed = False self . softspace = 0 def next ( self ): r = self . readline () if not r : raise StopIteration return r def isatty ( self ): return False ... ... StringIO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 class StringIO : \"\"\"class StringIO([buffer]) 使用 StringIO 时要注意：不能混用 Unicode 字符串和 8 字节字符串。 虽然 StringIO 对它们都支持，但是是同时只能支持一种。 \"\"\" def __init__ ( self , buf = '' ): # 如果传入的不是一个字符串，直接简单粗暴地将之转换成字符串 # 刚开始看到这个 buffer，还以为可以传入一个生成字符串的生成器什么的 if not isinstance ( buf , basestring ): buf = str ( buf ) self . buf = buf self . len = len ( buf ) # 这个列表主要是写入数据的时候，先保存在该列表里 # 到真实用时，再转换成 self.buf # 算是减少两个字符串相加的操作，也就是减少内存分配 self . buflist = [] self . pos = 0 self . closed = False self . softspace = 0 def __iter__ ( self ): # 这个不用解释了，迭代器协议要求的接口 return self def next ( self ): # 这个也是迭代器协议要求的接口， _complain_ifclosed ( self . closed ) r = self . readline () if not r : raise StopIteration return r def close ( self ): \"\"\"Free the memory buffer. \"\"\" if not self . closed : self . closed = True del self . buf , self . pos def isatty ( self ): \"\"\"Returns False because StringIO objects are not connected to a tty-like device. \"\"\" _complain_ifclosed ( self . closed ) return False def seek ( self , pos , mode = 0 ): \"\"\"Set the file's current position. The mode argument is optional and defaults to 0 (absolute file positioning); other values are 1 (seek relative to the current position) and 2 (seek relative to the file's end). There is no return value. \"\"\" _complain_ifclosed ( self . closed ) if self . buflist : self . buf += '' . join ( self . buflist ) self . buflist = [] if mode == 1 : pos += self . pos elif mode == 2 : pos += self . len self . pos = max ( 0 , pos ) def tell ( self ): \"\"\"Return the file's current position.\"\"\" _complain_ifclosed ( self . closed ) return self . pos def read ( self , n = - 1 ): \"\"\"Read at most size bytes from the file (less if the read hits EOF before obtaining size bytes). If the size argument is negative or omitted, read all data until EOF is reached. The bytes are returned as a string object. An empty string is returned when EOF is encountered immediately. \"\"\" _complain_ifclosed ( self . closed ) if self . buflist : self . buf += '' . join ( self . buflist ) self . buflist = [] if n is None or n < 0 : newpos = self . len else : newpos = min ( self . pos + n , self . len ) r = self . buf [ self . pos : newpos ] self . pos = newpos return r def readline ( self , length = None ): r\"\"\"Read one entire line from the file. A trailing newline character is kept in the string (but may be absent when a file ends with an incomplete line). If the size argument is present and non-negative, it is a maximum byte count (including the trailing newline) and an incomplete line may be returned. An empty string is returned only when EOF is encountered immediately. Note: Unlike stdio's fgets(), the returned string contains null characters ('\\0') if they occurred in the input. \"\"\" _complain_ifclosed ( self . closed ) if self . buflist : self . buf += '' . join ( self . buflist ) self . buflist = [] i = self . buf . find ( ' \\n ' , self . pos ) if i < 0 : newpos = self . len else : newpos = i + 1 if length is not None and length >= 0 : if self . pos + length < newpos : newpos = self . pos + length r = self . buf [ self . pos : newpos ] self . pos = newpos return r def readlines ( self , sizehint = 0 ): \"\"\"Read until EOF using readline() and return a list containing the lines thus read. If the optional sizehint argument is present, instead of reading up to EOF, whole lines totalling approximately sizehint bytes (or more to accommodate a final whole line). \"\"\" total = 0 lines = [] line = self . readline () while line : lines . append ( line ) total += len ( line ) if 0 < sizehint <= total : break line = self . readline () return lines def truncate ( self , size = None ): \"\"\"Truncate the file's size. If the optional size argument is present, the file is truncated to (at most) that size. The size defaults to the current position. The current file position is not changed unless the position is beyond the new file size. If the specified size exceeds the file's current size, the file remains unchanged. \"\"\" _complain_ifclosed ( self . closed ) if size is None : size = self . pos elif size < 0 : raise IOError ( EINVAL , \"Negative size not allowed\" ) elif size < self . pos : self . pos = size self . buf = self . getvalue ()[: size ] self . len = size def write ( self , s ): \"\"\"Write a string to the file. There is no return value. \"\"\" _complain_ifclosed ( self . closed ) if not s : return # Force s to be a string or unicode if not isinstance ( s , basestring ): s = str ( s ) spos = self . pos slen = self . len if spos == slen : self . buflist . append ( s ) self . len = self . pos = spos + len ( s ) return # 这一行代码就解释为什么我上面写的的第一段代码 # 会产生那样的结果 if spos > slen : self . buflist . append ( ' \\0 ' * ( spos - slen )) slen = spos newpos = spos + len ( s ) if spos < slen : if self . buflist : self . buf += '' . join ( self . buflist ) self . buflist = [ self . buf [: spos ], s , self . buf [ newpos :]] self . buf = '' if newpos > slen : slen = newpos else : self . buflist . append ( s ) slen = newpos self . len = slen self . pos = newpos def writelines ( self , iterable ): \"\"\"Write a sequence of strings to the file. The sequence can be any iterable object producing strings, typically a list of strings. There is no return value. (The name is intended to match readlines(); writelines() does not add line separators.) \"\"\" write = self . write for line in iterable : write ( line ) def flush ( self ): \"\"\"Flush the internal buffer \"\"\" # StringIO 压根不用操作磁盘，所以没有 flush 操作 _complain_ifclosed ( self . closed ) def getvalue ( self ): \"\"\" Retrieve the entire contents of the \"file\" at any time before the StringIO object's close() method is called. The StringIO object can accept either Unicode or 8-bit strings, but mixing the two may take some care. If both are used, 8-bit strings that cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause a UnicodeError to be raised when getvalue() is called. \"\"\" _complain_ifclosed ( self . closed ) if self . buflist : self . buf += '' . join ( self . buflist ) self . buflist = [] return self . buf","tags":"Python","loc":"http://chenjiee815.github.io/stringiobiao-zhun-ku-yuan-ma-xue-xi.html","title":"StringIO标准库源码学习"},{"text":"Contents 简介 translate fnmatch&&fnmatchcase filter 总结 简介 fnmatch 库的还是很简单的，代码加注释才 100 行多一点。 它主要做的工作就是比较一个给定的文件名和给定的模式字符串，判断两者是否相等。 然后围绕这个功能，提供一系列的相关函数。 filter 输入 一个文件名列表和一个指定模式（仅支持 Shell 通配符） 输出 一个符合指定模式的文件名列表 fnmatch 输入 一个文件名和一个指定模式（仅支持 Shell 通配符） 输出 该文件名是否匹配指定模式 说明 具体行为和平台相关，比如某些平台忽略大小写等等 fnmatchcase 输入 一个文件名和一个指定模式（仅支持 Shell 通配符） 输出 该文件名是否匹配指定模式 说明 大小写敏感 translate 输入 Shell 通配符格式的模式字符串 输出 正则格式的模式字符串 translate 至于如何判断两者相等，它的做法是： 使用 正则表达式 既然要使用 正则表达式 ，那么就要考虑如何将通配符表达式替换成正则表达式。 这个功能就是由 translate 函数来实现的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def ntranslate ( pat ): \"\"\"Translate a shell PATTERN to a regular expression. There is no way to quote meta-characters. \"\"\" i , n = 0 , len ( pat ) res = '' while i < n : c = pat [ i ] i = i + 1 if c == '*' : res = res + '.*' elif c == '?' : res = res + '.' elif c == '[' : j = i if j < n and pat [ j ] == '!' : j = j + 1 if j < n and pat [ j ] == ']' : j = j + 1 while j < n and pat [ j ] != ']' : j = j + 1 if j >= n : res = res + ' \\\\ [' else : stuff = pat [ i : j ] . replace ( ' \\\\ ' , ' \\\\\\\\ ' ) i = j + 1 if stuff [ 0 ] == '!' : stuff = '&#94;' + stuff [ 1 :] elif stuff [ 0 ] == '&#94;' : stuff = ' \\\\ ' + stuff res = ' %s [ %s ]' % ( res , stuff ) else : res = res + re . escape ( c ) return res + '\\Z(?ms)' 上面的代码明显是命令式编程的思路。那我想换一种思路，用函数式编程来重写这个函数。 我们首先会考虑这个 translate 函数的基本功能是什么？ 将通配符表达式转换成正则表达式。 那么它们俩的区别是什么？ 通配符表达式的 * 在正则表达式中为 .* 通配符表达式的 ? 在正则表达式中为 . 通配符表达式的 [XXX] 在正则表达式中为 [XXX] 通配符表达式的 [!XXX] 、 [&#94;XXX] 在正则表达式中为 [&#94;XXX] 通配符表达式的其它字符， 在正则表达式中都需要 re.escape 进行转义 好的，上面分析的几种情况，都可以通过首个字符来判断其接下来的处理属于哪一类，但是 [XXX] 这种类型，还要包括后面的好几个字符，所以处理完这种类型需要知道剩下的未处理字符串。 大家都统一一下接口就提取出如下几个辅助函数： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 trans_default = lambda c , left_pat : ( re . escape ( c ), left_pat ) trans_asterisk = lambda c , left_pat : ( '.*' , left_pat ) trans_questionmark = lambda c , left_pat : ( '.' , left_pat ) def trans_choice ( c , left_pat ): # 这个函数最初也是用递归实现，然后再转换成 while 循环 if not left_pat : return ( ' \\\\ ' + c , '' ) res = c while left_pat : c , left_pat = left_pat [ 0 ], left_pat [ 1 :] if c in ( '!' , '&#94;' ): res += ' \\\\ &#94;' elif c == ' \\\\ ' : res += ' \\\\\\\\ ' elif c == ']' : res += ']' break else : res += c return ( res , left_pat ) if ']' in res else ( ' \\\\ ' + res , left_pat ) 我们再将上面的思路转换为递归代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 TRANS_MAP = { \"*\" : trans_asterisk , \"?\" : trans_questionmark , \"[\" : trans_choice , } def _translate ( pat ): if not pat : return '' c , left_pat = pat [ 0 ], pat [ 1 :] trans_func = TRANS_MAP . get ( c , trans_default ) res_part , left_pat = trans_func ( c , left_pat ) return res_part + _translate ( left_pat ) def translate ( pat ): res = _translate ( pat ) return res + '\\Z(?ms)' 递归的效率是比较低的，但是我们可以转换成尾递归形式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 TRANS_MAP = { \"*\" : trans_asterisk , \"?\" : trans_questionmark , \"[\" : trans_choice , } def _translate ( pat , res ): if not pat : return res c , left_pat = pat [ 0 ], pat [ 1 :] handle_func = TRANS_MAP . get ( c , trans_default ) res_part , left_pat = handle_func ( c , left_pat ) return _translate ( left_pat , res + res_part ) def translate ( pat ): res = _translate ( pat , '' ) return res + '\\Z(?ms)' 好了，如果 Python 的解释器支持尾递归，到上面一步就可以了。 因为支持尾递归就代表解释器会自动将尾递归转换成迭代的形式。 但是我们必须手工做这一步，不过这也只是手到摛来的事了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TRANS_MAP = { \"*\" : trans_asterisk , \"?\" : trans_questionmark , \"[\" : trans_choice , } def translate ( pat ): if not pat : return '' def _yield_res (): left_pat = pat while 1 : c , left_pat = left_pat [ 0 ], left_pat [ 1 :] handle_func = TRANS_MAP . get ( c , trans_default ) res_part , left_pat = handle_func ( c , left_pat ) yield res_part if not left_pat : break return '' . join ( _yield_res ()) + '\\Z(?ms)' fnmatch&&fnmatchcase fnmatch 本质上其实就是调用 fnmatchcase 来实现的。只不过在调用之前使用了 os.path.normcase 方法来消除平台差异而已。 1 2 3 4 5 6 7 8 9 10 11 12 13 def fnmatchcase ( name , pat ): \"\"\"Test whether FILENAME matches PATTERN, including case. This is a version of fnmatch() which doesn't case-normalize its arguments. \"\"\" if not pat in _cache : res = translate ( pat ) if len ( _cache ) >= _MAXCACHE : _cache . clear () _cache [ pat ] = re . compile ( res ) return _cache [ pat ] . match ( name ) is not None 看了代码就知道它的实现太简单了，将参数中的模式字符串调用 translate 函数转换成正则字符串，然后直接使用正则表达式对象的 match 方法就完事了。反而是使用了 Cache 这个非主要功能，占用了比较多的代码。 接下来咱们重新整理一下代码。 Cache 操作直接和函数的主要逻辑混在一起 既然使用到 Cache，那么操作 Cache 的具体代码就要封装起来了啊。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class LimitedCache ( object ): def __init__ ( self , size = 100 ): super ( LimitedCache , self ) . __init__ () self . __max_size = size self . __cache = {} def clear ( self ): self . __cache . clear () def is_full ( self ): cache_size = len ( self . __cache ) return cache_size >= self . __max_size def get ( self , key ): value = self . __cache . get ( key , None ) self . is_full () and self . clear () return value def put ( self , key , value ): self . __cache [ key ] = value CACHE = LimitedCache ( size = 100 ) def fnmatchcase ( name , pat ): def _cache_pat ( pat ): re_pat = translate ( pat ) re_obj = re . compile ( re_pat ) CACHE . put ( ret_obj ) return re_obj re_obj = CACHE . get ( pat ) or _cache_pat ( pat ) return re_obj . match ( name ) is not None 这样看 fnmatchcase 函数是不是比较原来的版本简单明了许多。 Cache 功能好像也不是 fnmatchcase 的主要功能吧。 既然不是主要功能，那么我们就不能和实现主要功能的代码混在一块。 那怎么实现？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class LimitedCache ( object ): def __init__ ( self , size = 100 ): super ( LimitedCache , self ) . __init__ () self . __max_size = size self . __cache = {} def clear ( self ): self . __cache . clear () def is_full ( self ): cache_size = len ( self . __cache ) return cache_size >= self . __max_size def get ( self , key ): value = self . __cache . get ( key , None ) self . is_full () and self . clear () return value def put ( self , key , value ): self . __cache [ key ] = value CACHE = LimitedCache ( size = 100 ) def cache_pat ( func ): def _cache_pat ( pat ): re_pat = translate ( pat ) re_obj = re . compile ( re_pat ) CACHE . put ( re_obj ) return re_obj return lambda name , pat : func ( name , CACHE . get ( pat ) or _cache_pat ( pat )) fnmatchcase = cache_pat ( lambda name , re_obj : re_obj . match ( name ) is not None ) # 版本 2 # def fnmatchcase(name, pat): # def _fnmatchcase(name, re_obj): # return re_obj.match(name) is not None # return cache_pat(_fnmatchcase)(name, pat) # # 版本 3（问题：修改了 fnmatchcase 的参数） # @cache_pat # def fnmatchcase(name, re_obj): # return re_obj.match(name) is not None 嗯，这样就差不多了。 filter filter 也比较简单， 其实就是对一系列的文件名进行 fnmatchcase 判断，只保留匹配正确的文件名而已。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def filter ( names , pat ): \"\"\"Return the subset of the list NAMES that match PAT\"\"\" import os , posixpath result = [] pat = os . path . normcase ( pat ) if not pat in _cache : res = translate ( pat ) if len ( _cache ) >= _MAXCACHE : _cache . clear () _cache [ pat ] = re . compile ( res ) match = _cache [ pat ] . match if os . path is posixpath : # normcase on posix is NOP. Optimize it away from the loop. for name in names : if match ( name ): result . append ( name ) else : for name in names : if match ( os . path . normcase ( name )): result . append ( name ) return result filter 内部的主要逻辑和 fnmatchcase 差不多么，为什么不复用？ 1 2 3 4 5 6 7 8 9 def fnfilter ( names , pat ): return [ n for n in names if fnmatch ( n )] # 版本 2 # return filter(fnmatch, names) def fnfiltercase ( names , pat ): return [ n for n in names if fnmatchcase ( n )] # 版本 2 # return filter(fnmatchcase, names) 怎么样，比原来的代码清晰太多了吧。 总结 你是依据什么原则来吐槽的？ 一个函数只做一件事。 Cache 值为什么设为 100？ 之间我看过相关文章说，Python 源码里的某些具体数值是经过大量实践统计出来，我估计这个数值可能也是统计出来的，当然也可能是写个模块的作者个人喜好吧。 PS：要是我写，我就写 128，哈哈。 能写 Python 标准库的作者水平应该不错，为什么你会挑出这么多毛病？ 一般写标准库需要考虑： 库之间的尽量不要有依赖 效率要尽量高 版本兼容性 ... ... LimitedCache 一方面是为了封装高内聚的操作，一方面也是为了重用。但这两方面在标准库代码中都不是首要的，你封装了一层，那肯定要多调一层代码，效率就降低了，库之间尽量不要有依赖，那重用这一块就更不用提了。 filter 如果是我那种实现的话，就要每次从 Cache 中取一次 pat。而原来的代码只要在循环开始之前取一次即可。不过话又说回来了，我再提供一个不用 Cache 的 fnmatchcase 版本不就行了。 PS：这些都是我自己想的，当然有可能作者觉得这几个功能太简单，没必要将代码设计的太复杂。 Simple is better than complex. ， 嘿嘿。","tags":"Python","loc":"http://chenjiee815.github.io/fnmatchbiao-zhun-ku-yuan-ma-xue-xi.html","title":"fnmatch标准库源码学习"},{"text":"Contents 简介 常量定义 maketrans _multimap _TemplateMetaclass Template strop Fromatter 简介 string 库里面的大部分函数其实算是弃用了。 因为从 Python1.6 开始，那些函数都已经都已经在内置的 string 对象里实现了。 所以接下我所要讲解的代码就基本不包括这些函数了，何况它们也是比较简单好懂的。 常量定义 1 2 3 4 5 6 7 8 9 10 11 12 whitespace = ' \\t\\n\\r\\v\\f ' lowercase = 'abcdefghijklmnopqrstuvwxyz' uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' letters = lowercase + uppercase ascii_lowercase = lowercase ascii_uppercase = uppercase ascii_letters = ascii_lowercase + ascii_uppercase digits = '0123456789' hexdigits = digits + 'abcdef' + 'ABCDEF' octdigits = '01234567' punctuation = \"\"\"!\"#$%&'()*+,-./:;<=>?@[\\]&#94;_`{|}~\"\"\" printable = digits + letters + punctuation + whitespace 代码中上来就是一系列常用的常量定义，和 ctypes.h 中的定义相同，这没有好看的。知道就行，以后需要用到直接用（比如生成随机字符串啊，和 random 配合使用）。 maketrans 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 这里生成一个含有所有的 ASCII 字符的字符串（0～255） # 这里是先生成一个列表，然后再将其转换成字符串 # 但是到下面的 `maketrans` 函数使用时，又转换成列表 # 不知道想干嘛 l = map ( chr , xrange ( 256 )) _idmap = str ( '' ) . join ( l ) del l _idmapL = None def maketrans ( fromstr , tostr ): \"\"\"maketrans(frm, to) -> string 生成一个转换表，主要用来给 `translate` 函数使用 （translate 的第一个参数就要该函数的返回值）。 当然它还有一个要求： `frm` 和 `to` 的长度要一样。 注意：该转换表只能转换 ASCII \"\"\" if len ( fromstr ) != len ( tostr ): raise ValueError , \"maketrans arguments must have same length\" global _idmapL if not _idmapL : _idmapL = list ( _idmap ) L = _idmapL [:] fromstr = map ( ord , fromstr ) for i in range ( len ( fromstr )): # 这里为了效率，用了个小技巧 # L 中每个元素的值正好是自己在 L 中的索引 L [ fromstr [ i ]] = tostr [ i ] return '' . join ( L ) 上面的代码可能是为了效率考虑，采用点技巧（L 中每个元素的值正好是自己在 L 中的索引）。 那么我们用函数式编程的概念来如何实现呢？ maketrans 的最核心功能是什么呢？ 替换，将即在 L 中也在 frm 中的元素替换成 to 中对应 index 位置的元素 除了这个核心功能外，剩下的就是对整个 L 进行迭代了，很自然会想到使用 map 功能。 1 2 3 4 5 6 7 8 9 10 11 12 _ASCII_COUNT = 256 _IDMAP = [ chr ( n ) for n in xrange ( _ASCII_COUNT )] def maketrans ( fromstr , tostr ): if len ( fromstr ) != len ( tostr ): raise ValueError , \"maketrans arguments must have same length\" frm_to = zip ( fromstr , tostr ) # 如果字符 C 在 fromstr 中，则替换为 tostr 中对应 index 的字符 # 否则返回字符 C 本身 sub_c = lambda c : next (( t for f , t in frm_to if f == c ), c ) return '' . join (( sub_c ( c ) for c in _IDMAP )) 好了，刚才说到效率，那么两者效率相差多少呢？ 1 2 3 4 5 6 7 In [ 53 ]: % time string . maketrans ( \"abc\" , \"efg\" ) CPU times : user 0 ns , sys : 0 ns , total : 0 ns Wall time : 16 µ s In [ 66 ]: % time maketrans ( \"abc\" , \"efg\" ) CPU times : user 0 ns , sys : 0 ns , total : 0 ns Wall time : 660 µ s 是不是比较恐怖，40+ 倍的差距啊，所以说标准库的代码为了效率优化，还是下了功夫的。 _multimap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class _multimap : \"\"\" 一个辅助类，它是主要给下面的 `Template` 类使用的。 将两个字典绑定在一起。 如果在第一个字典中没有找到特定的 Key，则在第二个字典中查找。 \"\"\" def __init__ ( self , primary , secondary ): self . _primary = primary self . _secondary = secondary def __getitem__ ( self , key ): try : return self . _primary [ key ] except KeyError : return self . _secondary [ key ] 上面注释中也说了是 Template 的辅助类，那么它倒底在 Template 类中做了什么呢？ 1 2 3 4 5 6 7 8 9 def substitute ( self , * args , ** kws ): if len ( args ) > 1 : raise TypeError ( 'Too many positional arguments' ) if not args : mapping = kws elif kws : mapping = _multimap ( kws , args [ 0 ]) else : mapping = args [ 0 ] 上面是 Template 类中使用到 _multimap 类的代码，我们可以看到， _multimap 类中传入了两个参数： kws 和 args[0] 。 看到这里就应该明白了， Template 类为了提高易用性，无论你的 substitute 方法中传入的是一个字典、一个 / 多个关键字参数还是两者的结合，它都能给你想要的结果。 Note 第一个参数是 kws ，所以你在同时传入字典和一个 / 多个关键字参数时，如果两者包含同样字段的值，关键字参数的优先级是比较高的。 小心不要被坑喽。 1 2 3 4 In [ 38 ]: t = string . Template ( \"${name}: hello\" ) In [ 39 ]: t . substitute ({ \"name\" : \"dict\" }, name = \"key\" ) Out [ 39 ]: 'key: hello' 面向对象 SOLID 原则之一的 单一职责原则 ，这个类就是它的一个很好的体现。 _TemplateMetaclass 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class _TemplateMetaclass ( type ): pattern = r\"\"\" %(delim)s (?: (?P<escaped> %(delim)s ) | # Escape sequence of two delimiters (?P<named> %(id)s ) | # delimiter and a Python identifier {(?P<braced> %(id)s )} | # delimiter and a braced identifier (?P<invalid>) # Other ill-formed delimiter exprs ) \"\"\" def __init__ ( cls , name , bases , dct ): super ( _TemplateMetaclass , cls ) . __init__ ( name , bases , dct ) if 'pattern' in dct : pattern = cls . pattern else : pattern = _TemplateMetaclass . pattern % { 'delim' : _re . escape ( cls . delimiter ), 'id' : cls . idpattern , } cls . pattern = _re . compile ( pattern , _re . IGNORECASE | _re . VERBOSE ) _TemplateMetaclass 是一个元类，它提供了一个核心功能： 通过它创建出来的类，都有一个 pattern 属性 该属性能够解析类似于 delimiter{idpattern} 或者 delimiteridpattern 的字符串。 而通过它创建出来的类，只需要定制 delimiter 和 idpattern 的具体值就可拥有以上功能。 当然，通过它创建出来的类，也可以自己提供 pattern （但最终使用时，会被元类自动换成 re 对象）。 Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class Template : \"\"\" 能够解析 $ 表达式的字符串模板类 \"\"\" __metaclass__ = _TemplateMetaclass delimiter = '$' idpattern = r'[_a-z][_a-z0-9]*' def __init__ ( self , template ): self . template = template # Search for $$, $identifier, ${identifier}, and any bare $'s def _invalid ( self , mo ): \"\"\" 如果解析到无效的占位符，就告诉调用者在几行几列出错 \"\"\" i = mo . start ( 'invalid' ) lines = self . template [: i ] . splitlines ( True ) if not lines : colno = 1 lineno = 1 else : colno = i - len ( '' . join ( lines [: - 1 ])) lineno = len ( lines ) raise ValueError ( 'Invalid placeholder in string: line %d , col %d ' % ( lineno , colno )) def substitute ( self , * args , ** kws ): if len ( args ) > 1 : raise TypeError ( 'Too many positional arguments' ) if not args : # 传入一个 / 多个关键字参数 mapping = kws elif kws : # 传入一个字典及一个 / 多个关键字参数 mapping = _multimap ( kws , args [ 0 ]) else : # 只传入一个字典 mapping = args [ 0 ] # Helper function for .sub() def convert ( mo ): # 为了效率，将最有可能的情况先进行判断 # 最有可能出现 `$XXXX` 或者 `${XXXX}` 这两种正常的情况 named = mo . group ( 'named' ) or mo . group ( 'braced' ) if named is not None : val = mapping [ named ] # We use this idiom instead of str() because the latter will # fail if val is a Unicode containing non-ASCII characters. return ' %s ' % ( val ,) # 其次是 `$$` 这种情况 if mo . group ( 'escaped' ) is not None : return self . delimiter # 发现无效的占位符 if mo . group ( 'invalid' ) is not None : self . _invalid ( mo ) # 其它未知情况 raise ValueError ( 'Unrecognized named group in pattern' , self . pattern ) return self . pattern . sub ( convert , self . template ) def safe_substitute ( self , * args , ** kws ): \"\"\" 该方法的功能基本和 `substitute` 差不多， 只不过从参数中找不到可替换的字符串情况下， 不会抛出异常，而是原样输出而已 \"\"\" if len ( args ) > 1 : raise TypeError ( 'Too many positional arguments' ) if not args : mapping = kws elif kws : mapping = _multimap ( kws , args [ 0 ]) else : mapping = args [ 0 ] # Helper function for .sub() def convert ( mo ): named = mo . group ( 'named' ) if named is not None : # 这里最好不用异常的方式来判断，Python 里处理异常的代价相当大 # 可以使用 get 方法，或者 in 来判断。 try : # We use this idiom instead of str() because the latter # will fail if val is a Unicode containing non-ASCII return ' %s ' % ( mapping [ named ],) except KeyError : return self . delimiter + named braced = mo . group ( 'braced' ) if braced is not None : # 这里的问题同上所述，最好不要用异常方式 try : return ' %s ' % ( mapping [ braced ],) except KeyError : return self . delimiter + '{' + braced + '}' if mo . group ( 'escaped' ) is not None : return self . delimiter if mo . group ( 'invalid' ) is not None : return self . delimiter raise ValueError ( 'Unrecognized named group in pattern' , self . pattern ) return self . pattern . sub ( convert , self . template ) 说实在的，这里为什么要用到元类来实现这个功能，我还真想不清楚，如果有人能够知道，麻烦告诉我一下。 Template 类其实就相当于一个轻量级的模板引擎了，你可以直接用它，也做一些简单的定制。 1 2 class MyTemplate ( Template ): delimiter = '#' 比如以上的 MyTemplate 就支持 #XXXX 、 #{XXX} 这种语法了。 strop 1 2 3 4 5 try : from strop import maketrans , lowercase , uppercase , whitespace letters = lowercase + uppercase except ImportError : pass string 库还会检查当前 Python 实现中是否有 strop 库，如果有，则加载该库中的部分函数。该库为一个内置库，一些字符串操作比 string 库快 100～1000 倍。 Fromatter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class Formatter ( object ): def format ( self , format_string , * args , ** kwargs ): # Fomatter 支持类似于 {0}, {name} 的语法 # 所以将参数直接以元组和字典处理， # 从格式化字符串里取出来的 0, name 就可以直接传给 args, kwargs 调用了。 return self . vformat ( format_string , args , kwargs ) def vformat ( self , format_string , args , kwargs ): used_args = set () result = self . _vformat ( format_string , args , kwargs , used_args , 2 ) self . check_unused_args ( used_args , args , kwargs ) return result def _vformat ( self , format_string , args , kwargs , used_args , recursion_depth ): if recursion_depth < 0 : raise ValueError ( 'Max string recursion exceeded' ) result = [] # \"literal_text{field_name!conversion:format_spec}\" for literal_text , field_name , format_spec , conversion in \\ self . parse ( format_string ): # output the literal text if literal_text : result . append ( literal_text ) # if there's a field, output it if field_name is not None : # this is some markup, find the object and do # the formatting # given the field_name, find the object it references # and the argument it came from obj , arg_used = self . get_field ( field_name , args , kwargs ) used_args . add ( arg_used ) # do any conversion on the resulting object obj = self . convert_field ( obj , conversion ) # expand the format spec, if needed format_spec = self . _vformat ( format_spec , args , kwargs , used_args , recursion_depth - 1 ) # format the object and append to the result result . append ( self . format_field ( obj , format_spec )) return '' . join ( result ) def get_value ( self , key , args , kwargs ): if isinstance ( key , ( int , long )): return args [ key ] else : return kwargs [ key ] def check_unused_args ( self , used_args , args , kwargs ): pass def format_field ( self , value , format_spec ): return format ( value , format_spec ) def convert_field ( self , value , conversion ): # 根据指定的转换方法对传入的值进行转换 # 在格式化字符串中的语法为 !r, !s # 例如： \"{0!s}\"、 \"{name!r}\" if conversion is None : return value elif conversion == 's' : return str ( value ) elif conversion == 'r' : return repr ( value ) raise ValueError ( \"Unknown conversion specifier {0!s}\" . format ( conversion )) def parse ( self , format_string ): # 调用的是 C 语言实现的格式化字符串解析器 return format_string . _formatter_parser () def get_field ( self , field_name , args , kwargs ): # 将格式类似于 \"{person[name]}\"、 \"person.name\" 或 \"{person[0]}\" 的字段进行拆分 first , rest = field_name . _formatter_field_name_split () obj = self . get_value ( first , args , kwargs ) # loop through the rest of the field_name, doing # getattr or getitem as needed for is_attr , i in rest : if is_attr : obj = getattr ( obj , i ) else : obj = obj [ i ] return obj , first 提供 Formatter 类的本意和上面的 Template 类是一样的，给需要用到该功能的用户进行自定义使用的。 我们正常的 Python 使用的字符串格式化操作，并不会调用到这里面的代码，它是直接调用 Python 的内置类型 string 的方法，是由 C 语言实现的。","tags":"Python","loc":"http://chenjiee815.github.io/stringbiao-zhun-ku-yuan-ma-xue-xi.html","title":"string标准库源码学习"},{"text":"Contents 总纲 scheme 十戒 scheme 五律 第一章 : Toys 基本概念 其它概念 第二章 : Do It, Do It Again, and Again, and Again… lat 操作 基本概念 应用 第三章 : Cons the Magnificent lat 操作 应用 第四章 : Numbers Games 数字操作 基本概念 应用 综合操作 第五章 : *Oh My Gawd*: It's Full of Stars 第六章 : Shadows 应用 第七章 : Friends and Relations set 操作 基本概念 应用 pair 操作 基本概念 应用 rel 操作 基本概念 fun 操作 基本概念 应用 fullfun 操作 基本概念 应用 第八章 : Lambda the Ultimate 第九章 : … and Again, and Again, and Again, … 第十章 : What Is the Value of All of This? 总纲 scheme 十戒 当对一个原子列表进行递归时，要注意两个问题：(null? lat) and else。 当对一个数字进行递归时，要注意两个问题：(zero? n) and else。 当对一个 S 表达式列表进行递归时，要注意三个问题：(null? l), (atom? (car l)) 和 else。 使用 cons 来创建列表。 当创建一个列表时，先描述第一个元素，然后用 cons 来将它和递归连接在一起 递归时，至少要改变一个参数。 例如：递归一个原子列表使用 (cdr lat)；递归一个数字使用 (sub1 n)； 递归一个 S 表达式时，如果这个表达式即不 (null? l)，也不 (atom? (car l))， 那么使用 (car l) 和 (cdr l)。 并且该参数必须要越来越接近终止元素。在终止条件里面必须要对正在变化的参数进行检查： 当使用 cdr 时，终止条件使用 null? 当使用 sub1 时，终止条件使用 zero? 当你使用 + 来创建一个值时，必须总要用 0 来作为终止，0 加上任何值都不会改变原来的值。 当你使用 * 来创建一个值时，必须总要用 1 来作为终止，1 乘以任务值都不会改变原来的值。 当你使用 cons 来创建一个值时，必须总要用 () 来作为终止。 当函数运行正确后再考虑简化函数。 当一个对象的子对象是与其本身表现一致时，这时候可用递归操作。比如： 一个列表的子列表 一个算术表达式的子表达式 使用 help 函数来简化表述。 使用新的函数来抽象公共模式。 创建函数时，尽量能够一次性获取更多的值。 scheme 五律 car 函数最初只是用在非空列表上的。 cdr 函数最初只是用在非空列表上的，(cdr non-null-list) 的结果是另一个列表。 cons 函数最初只接受两个参数，第二个参数必须是一个列表，它返回的结果也是一个列表。 null? 函数只对列表有用。 eq? 函数只接受两个参数，两个参数必须都是非数字的原子。 第一章 : Toys 作者目的：使读者了解 scheme 一些基本概念和一些常用函数，为接下来的章节打基础。 基本概念 S 表达式 : scheme 中所以元素都可以叫做 S 表达式。 atom: 原子，是指一个非列表的 S 表达式。 list: 列表，用 () 包围起来的 S 表达式。 car: 返回非空列表中的首个 S 表达式， 所以它操作的对象一定要是非空的列表 ( 十戒第一条 )。 cdr: 取出非空列表中的除首个 S 表达式的列表， 它操作的对象也是要非空列表 ( 十戒第一条 )。 cons: 将两个 S 表达式连接成一个列表，第二个必须是一个列表。 null?: 只判断列表是否为空 (scheme 五律第四条 )。 atom?: 用来判断一个 S 表达式是否为一个原子。 1 2 3 ( define atom? ( lambda ( m ) ( and ( not ( pair? m )) ( not ( null? m ))))) eq?: 用来判断两个非数字的的原子是否相等， (PS: guile 的实现不太一样，它还可以比较数字。) 其它概念 define: 用来定义一个名称，或者一个函数。 lambda: 用来定义一个函数。 cond: 相当于其它语言中的 switch。 else: 永远返回 #t, 即 True。 第二章 : Do It, Do It Again, and Again, and Again… lat 操作 基本概念 lat: 列表中包含的每个 S 表达式都是原子的列表。 应用 lat?: 判断列表中是否每个 S 表达式都是原子。 1 2 3 4 5 6 ( define lat? ( lambda ( l ) ( cond (( null? l ) #t ) (( atom? ( car l )) ( lat? ( cdr l ))) ( else #f )))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define col ( lambda ( lat nolat ) ( null? nolat ))) ( define lat?&co ( lambda ( l col ) ( cond (( null? l ) ( col ' () ' ())) (( atom? ( car l )) ( lat?&co ( cdr l ) ( lambda ( lat nolat ) ( col ( cons ( car l ) lat ) nolat )))) ( else ( lat?&co ( cdr l ) ( lambda ( lat nolat ) ( col lat ( cons ( car l ) nolat )))))))) member?: 用来判断一个 S 表达式是否在一个列表之内。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( define member? ( lambda ( a lat ) ( cond (( null? lat ) #f ) (( eq? a ( car lat )) #t ) ( else ( member? a ( cdr lat )))))) ; CPS 变换 ( define col ( lambda ( in out ) ( not ( null? in )))) ( define member?&co ( lambda ( a lat col ) ( cond (( null? lat ) #f ) (( eq? a ( car lat )) ( member?&co a ( cdr lat ) ( lambda ( in out ) ( col ( cons a in ) out )))) ( else ( member?&co a ( cdr lat ) ( lambda ( in out ) ( col in ( cons a out )))))))) 第三章 : Cons the Magnificent lat 操作 应用 rember: 将一个 S 表达式从一个列表中删除。 1 2 3 4 5 6 ( define rember ( lambda ( a lat ) ( cond (( null? lat ) ' ()) (( eq? a ( car lat )) ( cdr lat )) ( else ( cons ( car lat ) ( rember a ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define col ( lambda ( rmcount leftlat ) ( display rmcount ) ( newline ) ( display leftlat ) ( newline ) leftlat )) ( define rember&co ( lambda ( a lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? a ( car lat )) ( col 1 ( cdr lat ))) ( else ( rember&co a ( cdr lat ) ( lambda ( rmcount leftlat ) ( col rmcount ( cons ( car lat ) leftlat )))))))) firsts: 从一个列表中的获取其每个子列表的首个 S 表达式，并以列表形式返回 1 2 3 4 5 ( define firsts ( lambda ( l ) ( cond (( null? l ) ' ()) ( else ( cons ( car ( car l )) ( firsts ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( first_ed ) ( display first_ed ) ( newline ) first_ed )) ( define firsts&co ( lambda ( l col ) ( display l ) ( newline ) ( cond (( null? l ) ( col ' ())) ( else ( firsts&co ( cdr l ) ( lambda ( first_ed ) ( col ( cons ( car ( car l )) first_ed )))))))) insertR: 将一个 S 表达式插入到一个列表中指定 S 表达式的右边， 并返回修改后的列表 insertL: 基本同上，只不过是插入到左边 Tip insert* 函数的整体逻辑与 rember 是差不多的。 1 2 3 4 5 6 ( define insertR ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons old ( cons new ( cdr lat )))) ( else ( cons ( car lat ) ( insertR new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define col ( lambda ( newlat ) ( display newlat ) ( newline ) newlat )) ( define insertR&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col ' ())) (( eq? old ( car lat )) ( col ( cons old ( cons new ( cdr lat ))))) ( else ( insertR&co new old ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat ) ))))))) 1 2 3 4 5 6 ( define insertL ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons new lat )) ( else ( cons ( car lat ) ( insertL new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ( define col ( lambda ( newlat ) ( display newlat ) ( newline ) newlat )) ( define insertL&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col ' ())) (( eq? old ( car lat )) ( col ( cons new lat ))) ( else ( insertL&co new old ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) subst: 用新的 S 表达式替代列表中指定的 S 表达式， 并返回修改后的列表 subst2: 用来替代列表中指定的两个 S 表达式 Tip subst* 函数的整体逻辑也与 rember 是差不多的。 1 2 3 4 5 6 ( define subst ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons new ( cdr lat ))) ( else ( cons ( car lat ) ( subst new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define col ( lambda ( newlat ) ( display newlat ) ( newline ) newlat )) ( define subst&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col ' ())) (( eq? old ( car lat )) ( col ( cons new ( cdr lat )))) ( else ( subst&co new old ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define subst2 ( lambda ( new old1 old2 lat ) ( cond (( null? lat ) ' ()) (( eq? old1 ( car lat )) ( cons new ( cdr lat ))) (( eq? old2 ( car lat )) ( cons new ( cdr lat ))) ( else ( cons ( car lat ) ( subst2 new old1 old2 ( cdr lat ))))))) ;subst2 简化版本 ( define subst2 ( lambda ( new old1 old2 lat ) ( cond (( null? lat ) ' ()) (( or ( eq? old2 ( car lat )) ( eq? old1 ( car lat ))) ( cons new ( cdr lat ))) ( else ( cons ( car lat ) ( subst2 new old1 old2 ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define col ( lambda ( newlat ) ( display newlat ) ( newline ) newlat )) ( define subst2&co ( lambda ( new old1 old2 lat col ) ( cond (( null? lat ) ( col ' ())) (( or ( eq? old1 ( car lat )) ( eq? old2 ( car lat ))) ( col ( cons new ( cdr lat )))) ( else ( subst&co new old1 old2 ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) multirember: 基本同 rember, 只不过是列表中所有符合的 S 表达式都会删除 . Tip 其逻辑基本是在 rember 逻辑上进行扩充的。 1 2 3 4 5 6 ( define multirember ( lambda ( a lat ) ( cond (( null? lat ) ' ()) (( eq? a ( car lat )) ( multirember a ( cdr lat ))) ( else ( cons ( car lat ) ( multirember a ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define col ( lambda ( rmcount newlat ) ( display rmcount ) ( display \" \" ) ( display newlat ) ( newline ) newlat )) ( define multirember&co ( lambda ( a lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? a ( car lat )) ( multirember&co a ( cdr lat ) ( lambda ( rmcount newlat ) ( col ( + rmcount 1 ) newlat )))) ( else ( multirember&co a ( cdr lat ) ( lambda ( rmcount newlat ) ( col rmcount ( cons ( car lat ) newlat )))))))) multiinsertR: 基本同 insertR, 只不过是列表中所有符合的 s 表达式都会插入其右边。 注意：其逻辑基本是在 insertR 逻辑上进行扩充的。 1 2 3 4 5 6 7 ( define multiinsertR ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons old ( cons new ( multiinsertR new old ( cdr lat ))))) ( else ( cons ( car lat ) ( multiinsertR new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define col ( lambda ( inscount newlat ) ( display inscount ) ( display \" \" ) ( display newlat ) ( newline ) newlat )) ( define multiinsertR&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? old ( car lat )) ( multiinsertR&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col ( + inscount 1 ) ( cons old ( cons new newlat )))))) ( else ( multiinsertR&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col inscount ( cons ( car lat ) newlat )))))))) multiinsertL: 基本同 insertL, 只不过是列表中所有符合的 s 表达式都会插入其左边 . 注意：其逻辑基本是在 insertL 逻辑上进行扩充的。 1 2 3 4 5 6 7 ( define multiinsertL ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons new ( cons old ( multiinsertL new old ( cdr lat ))))) ( else ( cons ( car lat ) ( multiinsertL new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ( define col ( lambda ( inscount newlat ) ( display inscount ) ( display \" \" ) ( display newlat ) ( newline ) newlat )) ( define mutlinsertL&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? old ( car lat )) ( mutlinsertL&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col ( + inscount 1 ) ( cons new ( cons old newlat )))))) ( else ( mutlinsertL&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col inscount ( cons ( car lat ) newlat )))))))) multisubst: 基本同 sbust, 只不过是列表中所有符合的 s 表达式都替换 1 2 3 4 5 6 7 ( define multisubst ( lambda ( new old lat ) ( cond (( null? lat ) ' ()) (( eq? old ( car lat )) ( cons new ( multisubst new old ( cdr lat )))) ( else ( cons ( car lat ) ( multisubst new old ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ( define col ( lambda ( stcount newlat ) ( display stcount ) ( display \" \" ) ( display newlat ) ( newline ) newlat )) ( define mutlsubst&co ( lambda ( new old lat col ) ( cond (( null? lat ) ( col 0 ' ())) (( eq? old ( car lat )) ( mutlisubst&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col ( + inscount 1 ) ( cons new newlat ))))) ( else ( mutlisubst&co new old ( cdr lat ) ( lambda ( inscount newlat ) ( col inscount ( cons ( car lat ) newlat )))))))) 第四章 : Numbers Games 数字操作 基本概念 数字也是一个 atom number?: 判断一个 S 表达式是否为数字 tup: 列表中包含的每个 s 表达式都是数字的列表。 应用 add1: 对数字加 1 sub1: 对数字减 1 +: 将两个数字相加 1 2 3 4 5 ( define + ( lambda ( a b ) ( cond (( zero? b ) a ) ( else ( add1 ( + a ( sub1 b ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define myadd&co ( lambda ( a b col ) ( cond (( zero? b ) ( col a )) ( else ( myadd&co a ( - b 1 ) ( lambda ( num ) ( col ( + num 1 )))))))) -: 将两个数字相减 1 2 3 4 5 ( define - ( lambda ( a b ) ( cond (( zero? b ) a ) ( else ( sub1 ( - a ( sub1 b ))))))) 1 2 3 4 5 6 7 8 9 10 11 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mysub&co ( lambda ( a b col ) ( cond (( zero? b ) ( col a )) ( else ( mysub&co ( - a 1 ) ( - b 1 ) col ))))) addtup: 一个 tup 中的所有数字相加 1 2 3 4 5 ( define addtup ( lambda ( tup ) ( cond (( null? tup ) 0 ) ( else ( + ( car tup ) ( addtup ( cdr tup ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define addtup&co ( lambda ( tup col ) ( cond (( null? tup ) ( col 0 )) ( else ( addtup&co ( cdr tup ) ( lambda ( sum ) ( col ( + sum ( car tup ))))))))) *: 将两个数字相乘 1 2 3 4 5 ( define * ( lambda ( n m ) ( cond (( zero? m ) 0 ) ( else ( + n ( * n ( sub1 m ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mymulti&co ( lambda ( n m col ) ( cond (( zero? m ) ( col 0 )) ( else ( mymulti&co n ( - m 1 ) ( lambda ( num ) ( + num n ))))))) tup+: 将两个 tup 中相对的数字相加 , 然后返回相加后的 tup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; 该函数允许两个参数的长度不一样 ( define tup+ ( lambda ( tup1 tup2 ) ( cond (( null? tup2 ) tup1 ) (( null? tup1 ) tup2 ) ( else ( cons ( +_ ( car tup1 ) ( car tup2 )) ( tup+ ( cdr tup1 ) ( cdr tup2 ))))))) ; 该函数的两个参数长度必须一样 ( define tup+ ( lambda ( tup1 tup2 ) ( cond (( and ( null? tup1 ) ( null? tup2 )) ' ()) ( else ( cons ( +_ ( car tup1 ) ( car tup2 )) ( tup+ ( cdr tup1 ) ( cdr tup2 ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( newtup ) ( display newtup ) ( newline ) newtup )) ( define tup+&co ( lambda ( tup1 tup2 col ) ( cond (( null? tup1 ) ( col tup2 )) (( null? tup2 ) ( col tup1 )) ( else ( tup+&co ( cdr tup1 ) ( cdr tup2 ) ( lambda ( newtup ) ( col ( cons ( + ( car tup1 ) ( car tup2 )) newtup )))))))) <: 比较两个数字的大小 >: 比较两个数字的大小 1 2 3 4 5 6 ( define > ( lambda ( n m ) ( cond (( zero? n ) #f ) (( zero? m ) #t ) ( else ( > ( sub1 n ) ( sub1 m )))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mylt&co ( lambda ( n m col ) ( cond (( zero? n ) ( col #f )) (( zero? m ) ( col #t )) ( else ( mylt&co ( - n 1 ) ( - m 1 ) col ))))) 1 2 3 4 5 6 7 ( define < ( lambda ( n m ) ( cond (( zero? m ) #f ) (( zero? n ) #t ) ( else ( < ( sub1 n ) ( sub1 m )))))) ; 基本同上 =: 比较两个数字是否相等 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define = ( lambda ( n m ) ( cond (( zero? m ) ( zero? n )) (( zero? n ) #f ) ( else ( = ( sub1 n ) ( sub1 m )))))) ( define = ( lambda ( n m ) ( cond (( > n m ) #f ) (( < n m ) #f ) ( else #t )))) &#94;: 阶乘 1 2 3 4 5 6 ( define &#94; ( lambda ( n m ) ( cond (( zero? n ) 0 ) (( zero? m ) 1 ) ( else ( * n ( &#94; n ( sub1 m ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mypower&co ( lambda ( n m col ) ( cond (( zero? n ) ( col 0 )) (( zero? m ) ( col 1 )) ( else ( mypower&co n ( - m 1 ) ( lambda ( num ) ( col ( * n num )))))))) /: 除 1 2 3 4 5 ( define / ( lambda ( n m ) ( cond (( < n m ) 0 ) ( else ( add1 ( / ( - n m ) m )))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define mydiv&co ( lambda ( n m col ) ( cond (( < n m ) ( col 0 )) ( else ( mydiv&co ( - n m ) m ( lambda ( num ) ( col ( + num 1 )))))))) 综合操作 length: 返回一个 lat 的长度 1 2 3 4 5 ( define length ( lambda ( lat ) ( cond (( null? lat ) 0 ) ( else ( add1 ( length ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define length&co ( lambda ( lat col ) ( cond (( null? lat ) ( col 0 )) ( else ( length&co ( cdr lat ) ( lambda ( num ) ( col ( + num 1 )))))))) pick: 根据传入的数字 , 获取其对应在 lat 中位置的 S 表达式 1 2 3 4 5 ( define pick ( lambda ( n lat ) ( cond (( zero? ( sub1 n )) ( car lat )) ( else ( pick ( sub1 n ) ( cdr lat )))))) 1 2 3 4 5 6 7 8 9 10 11 12 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define pick&co ( lambda ( n lat col ) ( cond (( null? lat ) ( col ' ())) (( zero? ( - n 1 )) ( col ( car lat ))) ( else ( pick&co ( - n 1 ) ( cdr lat ) col ))))) rempick: 根据传入的数字 , 删除其对应在 lat 中位置的 S 表达式 , 并返回剩余列表 1 2 3 4 5 6 ( define rempick ( lambda ( n lat ) ( cond (( null? lat ) ' ()) (( zero? ( sub1 n )) ( cdr lat )) ( else ( cons ( car lat ) ( rempick ( sub1 n ) ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define rempick&co ( lambda ( n lat col ) ( cond (( null? lat ) ( col ' ())) (( zero? ( - n 1 )) ( col ( cdr lat ))) ( else ( rempick&co ( - n 1 ) ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) no-nums: 选出列表中的非数字 S 表达式 , 并以列表形式返回 1 2 3 4 5 6 ( define no-nums ( lambda ( lat ) ( cond (( null? lat ) ' ()) (( number? ( car lat )) ( no-nums ( cdr lat ))) ( else ( cons ( car lat ) ( no-nums ( cdr lat ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define nonum&co ( lambda ( lat col ) ( cond (( null? lat ) ( col ' ())) (( number? ( car lat )) ( nonum&co ( cdr lat ) col )) ( else ( nonum&co ( cdr lat ) ( lambda ( newlat ) ( col ( cons ( car lat ) newlat )))))))) all-nums: 跟上面相反 , 只返回数字列表 1 2 3 4 5 6 7 8 ( define all-nums ( lambda ( lat ) ( cond (( null? lat ) ' ()) (( not ( number? ( car lat ))) ( all-nums ( cdr lat ))) ( else ( cons ( car lat ) ( all-nums ( cdr lat ))))))) ; 逻辑基本同上 eqan?: 比较两个 S 表达式是否是相等 1 2 3 4 5 6 7 8 ( define eqan? ( lambda ( a1 a2 ) ( cond (( and ( number? a1 ) ( number? a2 )) ( = a1 a2 )) (( or ( number? a1 ) ( number? a2 )) #f ) ( else ( eq? a1 a2 ))))) occur?: 检查列表中有几个指定的 S 表达式 1 2 3 4 5 6 7 ( define occur ( lambda ( a lat ) ( cond (( null? lat ) 0 ) (( eqan? a ( car lat )) ( add1 ( occur a ( cdr lat )))) ( else ( occur a ( cdr lat )))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define occur&co ( lambda ( n lat col ) ( cond (( null? lat ) ( col 0 )) (( eq? n ( car lat )) ( occur&co n ( cdr lat ) ( lambda ( num ) ( col ( + num 1 ))))) ( else ( occur&co n ( cdr lat ) col ))))) one?: 判断一个数字是否为 1 1 2 3 4 5 6 7 8 9 10 ( define one? ( lambda ( n ) ( cond (( zero? n ) #f ) ( else ( zero? ( sub1 n )))))) ( define one? ( lambda ( n ) ( cond ( else ( =_ n 1 ))))) 第五章 : *Oh My Gawd*: It's Full of Stars rember*: 基本同 rember, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define rember* ( lambda ( a l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( rember* a ( cdr l ))) ( else ( cons ( car l ) ( rember* a ( cdr l )))))) ( else ( cons ( rember* a ( car l )) ( rember* a ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define rember*&co ( lambda ( a l col ) ( cond (( null? l ) ( col ' ())) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( rember*&co a ( cdr l ) col )) ( else ( rember*&co a ( cdr l ) ( lambda ( newl ) ( col ( cons ( car l ) newl ))))))) ( else ( rember*&co a ( car l ) ( lambda ( carl ) ( rember*&co a ( cdr l ) ( lambda ( cdrl ) ( col ( cons carl cdrl )))))))))) insertR*: 基本同 insertR, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define insertR* ( lambda ( new old l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( cons old ( cons new ( insertR* new old ( cdr l ))))) ( else ( cons ( car l ) ( insertR* new old ( cdr l )))))) ( else ( cons ( insertR* new old ( car l )) ( insertR* new old ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define insertR*&co ( lambda ( new old l col ) ( cond (( null? l ) ( col ' ())) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( insertR*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons old ( cons new newl )))))) ( else ( insertR*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons ( car l ) newl ))))))) ( else ( insertR*&co new old ( car l ) ( lambda ( carl ) ( insertR*&co new old ( cdr l ) ( lambda ( cdrl ) ( col ( cons carl cdrl )))))))))) occur*: 基本同 occur, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define occur* ( lambda ( a l ) ( cond (( null? l ) 0 ) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( add1 ( occur* a ( cdr l )))) ( else ( occur* a ( cdr l ))))) ( else ( +_ ( occur* a ( car l )) ( occur* a ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define occur*&co ( lambda ( a l col ) ( cond (( null? l ) ( col 0 )) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( occur*&co a ( cdr l ) ( lambda ( num ) ( col ( + num 1 ))))) ( else ( occur*&co a ( cdr l ) col )))) ( else ( occur*&co a ( car l ) ( lambda ( carnum ) ( occur*&co a ( cdr l ) ( lambda ( cdrnum ) ( col ( + carnum cdrnum )))))))))) subst*: 基本同 subst, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define subst* ( lambda ( new old l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( cons new ( subst* new old ( cdr l )))) ( else ( cons ( car l ) ( subst* new old ( cdr l )))))) ( else ( cons ( subst* new old ( car l )) ( subst* new old ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define subst*&co ( lambda ( new old l col ) ( cond (( null? l ) ( col l )) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( subst*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons new newl ))))) ( else ( subst*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons ( car l ) newl ))))))) ( else ( subst*&co new old ( car l ) ( lambda ( carl ) ( subst*&co new old ( cdr l ) ( lambda ( cdrl ) ( col ( cons carl cdrl )))))))))) insertL*: 基本同 insertL, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 11 ( define insertL* ( lambda ( new old l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( cons new ( cons old ( insertL* new old ( cdr l ))))) ( else ( cons ( car l ) ( insertL* new old ( cdr l )))))) ( else ( cons ( insertL* new old ( car l )) ( insertL* new old ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define insertL*&co ( lambda ( new old l col ) ( cond (( null? l ) ( col l )) (( atom? ( car l )) ( cond (( eq? old ( car l )) ( insertL*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons new ( cons old newl )))))) ( else ( insertL*&co new old ( cdr l ) ( lambda ( newl ) ( col ( cons old newl ))))))) ( else ( insertL*&co new old ( car l ) ( lambda ( carl ) ( insertL*&co new old ( cdr l ) ( lambda ( cdrl ) ( col ( cons carl cdrl )))))))))) member*: 基本同 member, 但其处理的对象包括一个嵌套的列表 1 2 3 4 5 6 7 8 9 10 ( define member* ( lambda ( a l ) ( cond (( null? l ) #f ) (( atom? a ( car l )) ( cond (( eq? a ( car l )) #t ) ( else ( member* a ( cdr l ))))) ( else ( or ( member* a ( car l )) ( member* a ( cdr l ))))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ( define col ( lambda ( num ) ( display num ) ( newline ) num )) ( define member*&co ( lambda ( a l col ) ( cond (( null? l ) ( col #f )) (( atom? ( car l )) ( cond (( eq? a ( car l )) ( col #t )) ( else ( member*&co a ( cdr l ) col )))) ( else ( member*&co a ( car l ) ( lambda ( incar ) ( member*&co a ( cdr l ) ( lambda ( incdr ) ( col ( or incar incdr )))))))))) leftmost: 找出不包含空列表的列表 / 嵌套列表中的最左边的一个 atom 1 2 3 4 5 ( define leftmost ( lambda ( l ) ( cond (( atom? ( car l )) ( car l )) ( else ( leftmost ( car l )))))) eqlist?: 判断两个列表 / 嵌套列表是否相同 Tip 作者通过 equal? 来简化了 eqlist?， 而且 equal? 也是通过 eqlist? 来实现的。 只当函数正确的前提下再进行简化 / 优化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ( define eqlist? ( lambda ( l1 l2 ) ( cond (( and ( null? l1 ) ( null? l2 )) #t ) (( and ( null? l1 ) ( atom? ( car l2 ))) #f ) (( null? l1 ) #f ) (( and ( atom? ( car l1 )) ( null? l2 )) #f ) (( and ( atom? ( car l1 )) ( atom? ( car l2 ))) ( and ( eqan? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 )))) (( atom? ( car l1 )) #f ) (( null? l2 ) #f ) (( atom? ( car l2 )) #f ) ( else ( and ( eqlist? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 ))))))) ( define eqlist? ( lambda ( l1 l2 ) ( cond (( and ( null? l1 ) ( null? l2 )) #t ) (( or ( null? l1 ) ( null? l2 )) #f ) (( and ( atom? ( car l1 )) ( atom? ( car l2 ))) ( and ( eqan? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 )))) (( or ( atom? ( car l1 )) ( atom? ( car l2 ))) #f ) ( else ( and ( eqlist? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 ))))))) 1 2 3 4 5 6 7 ( define equal? ( lambda ( s1 s2 ) ( cond (( and ( atom? s1 ) ( atom? s2 )) ( eqan? s1 s2 )) (( or ( atom? s1 ) ( atom? s2 )) #f ) ( else ( eqlist? s1 s2 ))))) 1 2 3 4 5 6 7 8 ( define eqlist? ( lambda ( l1 l2 ) ( cond (( and ( null? l1 ) ( null? l2 )) #t ) (( or ( null? l1 ) ( null? l2 )) #f ) ( else ( and ( equal? ( car l1 ) ( car l2 )) ( eqlist? ( cdr l1 ) ( cdr l2 ))))))) rember: 重写之前简单的 rember, 参数 s 代表任何 S 表达式 , 参数 l 代码任何列表 1 2 3 4 5 6 ( define rember ( lambda ( s l ) ( cond (( null? l ) ' ()) (( equal? s ( car l )) ( cdr l )) ( else ( cons ( car l ) ( rember s ( cdr l ))))))) 第六章 : Shadows 这一章讲的是有关算术表达式的相关内容 , 它通过帮助函数来 支持前缀中缀后缀算术表达式 . 但我这里只写了前缀表达式的代码 . 应用 判断一个 S 表达式是否为算术表达式 1 2 3 4 5 6 7 8 9 10 ( define numbered? ( lambda ( aexp ) ( cond (( atom? aexp ) ( number? aexp )) (( or ( eq? ( car ( cdr aexp )) '+ ) ( eq? ( car ( cdr aexp )) '* ) ( eq? ( car ( cdr aexp )) '&#94; )) ( and ( numberd? ( car aexp )) ( numberd? ( car ( cdr ( cdr aexp )))))) ( else #f )))) &#94;: 倍数 1 2 3 ( define &#94; ( lambda ( n m ) ( expt n m ))) value: 获取一个算术表达式的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ( define value ( lambda ( nexp ) ( cond (( atom? nexp ) nexp ) (( eq? ( car nexp ) '+ ) ( + ( value ( cdr nexp )) ( value ( cdr ( cdr nexp ))))) (( eq? ( car nexp ) '* ) ( * ( value ( cdr nexp )) ( value ( cdr ( cdr nexp ))))) ( else ( &#94; ( value ( cdr nexp )) ( value ( cdr ( cdr nexp )))))))) ; 帮助函数 ( define 1 st-sub-exp ( lambda ( aexp ) ( car ( cdr aexp )))) ; 帮助函数 ( define 2 nd-sub-exp ( lambda ( aexp ) ( car ( cdr ( cdr aexp ))))) ; 帮助函数 ( define operator ( lambda ( aexp ) ( car aexp ))) ; 使用帮助函数重写的 value 函数 ; 这样修改后的函数 , 其实即可以用在前缀 , 也可以用在后缀表达式上 ; 只要修改几个帮助函数即可 ( define value ( lambda ( nexp ) ( cond (( atom? nexp ) nexp ) (( eq? ( operator nexp ) '+ ) ( + ( value ( 1 st-sub-exp nexp )) ( value ( 2 nd-sub-exp nexp )))) (( eq? ( operator nexp ) '* ) ( * ( value ( 1 st-sub-exp nexp )) ( value ( 2 nd-sub-exp )))) ( else ( &#94; ( value ( 1 st-sub-exp nexp )) ( value ( 2 nd-sub-exp nexp ))))))) 接下来作者用 () 来表示 0, (()) 表示 1, (() ()) 表示 2… 然后定义了对应的原语函数 : sero?, edd1, zub1, 第七章 : Friends and Relations set 操作 基本概念 set: 集合 , 类似于列表 , 但是它其中的元素唯一 应用 set?: 判断一个 S 表达式是否为 set 1 2 3 4 5 6 ( define set? ( lambda ( lat ) ( cond (( null? lat ) #t ) (( member? ( car lat ) ( cdr lat )) #f ) ( else ( set? ( cdr lat )))))) makeset: 生成一个 set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ( define makeset ( lambda ( lat ) ( cond (( null? lat ) ' ()) (( member? ( car lat ) ( cdr lat )) ( makeset ( cdr lat ))) ( else ( cons ( car lat ) ( makeset ( cdr lat ))))))) ; 使用 multirember, 另外一种思路 ( define makeset ( lambda ( lat ) ( cond (( null? lat ) ' ()) ( else ( cons ( car lat ) ( makeset ( multirember ( car lat ) ( cdr lat )))))))) subset?: 判断 set1 是否是 set2 的子集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define subset? ( lambda ( set1 set2 ) ( cond (( null? set1 ) #t ) (( member? ( car set1 ) set2 ) ( subset? ( cdr set1 ) set2 )) ( else #f )))) ( define subset? ( lambda ( set1 set2 ) ( cond (( null? set1 ) #t ) (( and ( member? ( car set1 ) set2 ) ( subset? ( cdr set1 ) set2 )))))) eqset?: 判断两个 set 是否相等 1 2 3 4 ( define eqset? ( lambda ( set1 set2 ) (( and ( subset? set1 set2 ) ( subset? set2 set1 ))))) interset?: 判断 set1 是否至少有一个 S 表达式在 set2 中 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define intersect? ( lambda ( set1 set2 ) ( cond (( null? set1 ) #t ) (( member? ( car set1 ) set2 ) #t ) ( else ( intersect? ( cdr set1 ) set2 ))))) ( define intersect? ( lambda ( set1 set2 ) ( cond (( null? set1 ) #t ) (( or ( member? ( car set1 ) set2 ) ( intersect? ( cdr set1 ) set2 )))))) interset: 求两个 set 的交集 1 2 3 4 5 6 7 8 9 10 ( define intersect ( lambda ( set1 set2 ) ( cond (( or ( null? set1 ) ( null? set2 )) ' ()) (( member? ( car set1 ) set2 ) ( cons ( car set1 ) ( intersect ( cdr set1 ) set2 ))) ( else ( intersect ( cdr set1 ) set2 ))))) union: 求两个 set 的并集 1 2 3 4 5 6 7 8 9 ( define union ( lambda ( set1 set2 ) ( cond (( null? set1 ) set2 ) (( null? set2 ) set1 ) (( member? ( car set1 ) set2 ) ( union ( cdr set1 ) set2 )) ( else ( cons ( car set1 ) ( union ( cdr set1 ) set2 )))))) intersectall: 获取 set 中每个子 set 的交集 1 2 3 4 5 6 ( define intersectall ( lambda ( l-set ) ( cond (( null? ( cdr l-set )) ( car l-set )) ( else ( intersect ( car l-set ) ( intersectall ( cdr l-set ))))))) pair 操作 基本概念 pair: 点对 , 只包含两个 S 表达式的列表 应用 a-pair?: 判断一个 S 表达式是否为 pair 1 2 3 4 5 6 7 8 ( define a-pair? ( lambda ( x ) ( cond (( atom? x ) #f ) (( null? x ) #f ) (( null? ( cdr lat ) #f )) (( null? ( cdr ( cdr lat ))) #t ) ( else #f )))) first: 获取 pair 的第一个 S 表达式 1 2 3 ( define first ( lambda ( p ) ( car p ))) second: 获取 pair 的第二个 S 表达式 1 2 3 ( define second ( lambda ( p ) ( car ( cdr p )))) build: 生成一个 pair 1 2 3 ( define build ( lambda ( s1 s2 ) ( cons s1 ( cons s2 ' ())))) rel 操作 基本概念 rel: 是一个内部嵌套 pair 的 list, 但是其所有子 pair 是唯一的 fun 操作 基本概念 fun: 同 rel, 但其所有子 pair 的第一个元素也是唯一的 , 类似于字典 (key->value) 应用 fun?: 判断一个 S 表达式是否为 fun 1 2 3 ( define fun? ( lambda ( rel ) ( set? ( firsts rel )))) revrel: 将 fun 中所有子 pair 的两个元素对调 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define revrel ( lambda ( rel ) (( null? rel ) ' ()) ( else ( cons ( build ( second ( car rel )) ( first ( car rel ))) ( revrel ( cdr rel )))))) ; 如果将其中的 pair 中两元素对调写成一个单独的函数 ; 则 revrel 看起来会更简洁明了 ( define revpair ( lambda ( pair ) ( build ( second pair ) ( first pair )))) ( define revrel ( lambda ( rel ) (( null? rel ) ' ()) ( else ( cons ( revpair ( car rel )) ( revrel ( cdr rel )))))) fullfun 操作 基本概念 fullfun: 基本同 fun, 但其所有子 pair 的第二个元素也是唯一的 应用 fullfun?: 判断一个 S 表达式是否为 fullfun 1 2 3 4 5 6 7 ( define fullfun? ( lambda ( fun ) ( set? ( seconds fun )))) ( define fullfun? ( lambda ( fun ) ( fun? ( revrel fun )))) 第八章 : Lambda the Ultimate 这一章才算开始高能 , 下面的九 , 十章则更是要下一翻功夫了 . 说高能 , 并不是指有多难 ( 除了连续概念的讲解 ), 而是指这一章揭示了很多更深入的东西 , 更深入的抽象 . rember-f: 基本同 rember, 但是其中的 eq/equal 比较函数 , 当作参数传入进来 , 具体的比较操作就抽象比来 , 可以用来支持各种对象 / 类型的删除操作 . 只需要你定义好其对象 / 类型的 eq/equal 比较函数即可 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ( define rember-f ( lambda ( test? a l ) ( cond (( null? l ) ' ()) (( test? a ( car l )) ( cdr l )) ( else ( cons ( car l ) ( rember-f ( test? a ( cdr l )))))))) ; 定义成为一个高阶函数 ( define rember-f ( lambda ( test? ) ( lambda ( a l ) ( cond (( null? l ) ' ()) (( test? a ( car l )) ( cdr l )) ( else ( cons ( car l ) ( rember-f ( test? a ( cdr l ))))))))) ( define rember-eq? ( lambda ( a l ) ( rember-f eq? ))) ( define rember-equal? ( lambda ( a l ) ( rember-f equal? ))) eq?-c: 返回一个函数 , 用来与固定 S 表达式比较 . 1 2 3 4 5 6 7 8 ( define eq?-c ( lambda ( a ) ( lambda ( x ) ( eq? x a )))) ; 与 salad 比较 ( define eq?-salad ( eq?-c 'salad )) insert-q: 返回一个函数 , 具体的操作函数当作参数传入 1 2 3 ( define seqL ( lambda ( new old l ) ( cons new ( cons old l )))) 1 2 3 ( define seqR ( lambda ( new old l ) ( cons old ( cons new l )))) 1 2 3 ( define seqS ( lambda ( new old l ) ( cons new l ))) 1 2 3 4 5 6 7 8 9 ( define insert-g ( lambda ( seq ) ( lambda ( new old l ) ( cond (( null? l ) ' ()) (( eq? ( car l ) old ) ( seq new old ( cdr l ))) ( else ( cons ( car l ) (( insert-g seq ) new old ( cdr l )))))))) 1 2 ( define insertL ( insert-g seqL )) 1 2 ( define insertR ( insert-g seqR )) 1 2 ( define subst ( insert-g seqS )) value: 重写之前的 value, 将里面的操作抽象出来 1 2 3 4 5 6 ( define atom-to-function ( lambda ( x ) ( cond (( eq? x '+ ) + ) (( eq? x '* ) * ) ( else &#94; )))) 1 2 3 4 5 6 7 8 ( define value ( lambda ( nexp ) ( cond (( atom? nexp ) nexp ) ( else (( atom-to-function ( operator nexp )) ( value ( 1 st-sub-exp nexp )) ( value ( 2 nd-sub-exp nexp ))))))) multirember-f: 同上 , 用 test? 代替 eq?/equal? 1 2 3 4 5 6 7 8 9 ( define multirember-f ( lambda ( test? ) ( lambda ( a lat ) ( cond (( null? lat ) ' ()) (( test? a ( car lat )) (( multirember-f test? ) a ( cdr lat ))) ( else ( cons ( car lat ) (( multirember-f test? ) a ( cdr lat )))))))) 1 2 ( define multirember-eq? ( multirember-f eq? )) 1 2 ( define multirember-equal? ( multirember-f equal? )) multiremberT: 基本同上 , 不过 test? 可以带参数， 将每次递归都不会变化的 test? 和 a 参数都存放到 test? 函数中 . 以后写函数 , 可以将哪些参数是不变的 , 哪些参数是变化的区分开来 . 1 2 3 4 5 6 7 8 ( define multiremberT ( lambda ( test? lat ) ( cond (( null? lat ) ' ()) (( test? ( car lat )) ( multiremberT test? ( cdr lat ))) ( else ( cons ( car lat ) ( multiremberT test? ( cdr lat ))))))) multirember&co: 将具体的操作放入 col 中 其中的 col 相当于一个收集器 (collector), 它将 lat 中和 a 参数不相同的 放入 col 的第一个参数中 , 相同的放入第二个参数中 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define multirember&co ( lambda ( a lat col ) ( cond (( null? lat ) ( col ' () ' ())) (( eq? ( car lat ) a ) ( multirember&co a ( cdr lat ) ( lambda ( newlat seen ) ( col newlat ( cons ( car lat ) seen ))))) ( else ( multirember&co a ( cdr lat ) ( lambda ( newlat seen ) ( col ( cons ( car lat ) newlat ) seen ))))))) 1 2 3 ( define a-friend ( lambda ( x y ) ( null? y ))) multiinsertLR: 将 new 插入到 oldL 的左边 ,oldR 的右边 . 1 2 3 4 5 6 7 8 9 10 ( define multiinsertLR ( lambda ( new oldL oldR lat ) ( cond (( null? lat ) ' ()) (( eq? oldL ( car lat )) ( cons new ( cons oldL ( multiinsertLR new oldL oldR ( cdr lat ))))) (( eq? oldR ( car lat )) ( cons oldR ( cons new ( multiinsertLR new oldL oldR ( cdr lat ))))) ( else ( cons ( car lat ) ( multiinsertLR new oldL oldR ( cdr lat ))))))) multiinsertLR&co: 将具体的操作放入 col 中 col 的 newlat 参数存放最后插入 new 参数后的 newlat, L 参数是在 oldL 参数左边插入的次数 , R 参数是在 oldR 参数右边插入的次数 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define multiinsertLR&co ( lambda ( new oldL oldR lat col ) ( cond (( null? lat ) ( col ' () 0 0 )) (( eq? oldL ( car lat )) ( multiinsertLR&co new oldL oldR ( cdr lat ) ( lambda ( newlat L R ) ( col ( cons new ( cons oldL newlat )) ( add1 L ) R )))) (( eq? oldR ( car lat )) ( multiinsertLR&co new oldL oldR ( cdr lat ) ( lambda ( newlat L R ) ( col ( cons oldR ( cons new newlat )) L ( add1 R ))))) ( else ( multiinsertLR&co new oldL oldR ( cdr lat ) ( lambda ( newlat L R ) ( col ( car lat ) L R ))))))) evens-only*: 找出嵌套队列中所有的偶数 1 2 3 4 5 ; 此处要用之前定义的运算符号 , 用系统自带的会出错 ; lisp 支持分数 , 即 3/2 不缺失其精度 ( define even? ( lambda ( n ) ( =_ ( *_ ( /_ n 2 ) 2 ) n ))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define evens-only* ( lambda ( l ) ( cond (( null? l ) ' ()) (( atom? ( car l )) ( cond (( even? ( car l )) ( cons ( car l ) ( evens-only* ( cdr l )))) ( else ( evens-only* ( cdr l ))))) ( else ( cons ( evens-only* ( car l )) ( evens-only* ( cdr l ))))))) evens-only*&co: 将具体的操作放入 col 中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ( define evens-only*&co ( lambda ( l col ) ( cond (( null? l ) ( col ' () 1 0 )) (( atom? ( car l )) ( cond (( even? ( car l )) ( evens-only*&co ( cdr l ) ( lambda ( newlat m s ) ( col ( cons ( car l ) newlat ) ( * ( car l ) m ) s )))) ( else ( evens-only*&co ( cdr l ) ( lambda ( newlat m s ) ( col newlat m ( + ( car l ) s ))))))) ( else ( evens-only*&co ( car l ) ( lambda ( al am as ) ( evens-only*&co ( cdr l ) ( lambda ( dl dm ds ) ( col ( cons al dl ) ( * am dm ) ( + as ds )))))))))) 这里建议一下，最好将从第二章开始的所有递归函数都用 cps 形式手动重写一遍 第九章 : … and Again, and Again, and Again, … looking/keep-looking: 1 2 3 4 5 6 7 8 9 10 ( define looking ( lambda ( a lat ) ( keep-looing a ( pick 1 lat ) lat ))) ( define keep-looing ( lambda ( a sorn lat ) ( cond (( number? sorn ) ( keep-looking a ( pick sorn lat ) lat )) ( else ( eq? sorn a ))))) shift: 1 2 3 4 5 ( define shift ( lambda ( pair ) ( build ( first ( first pair )) ( build ( second ( first pair )) ( second pair ))))) align: 接下来讲的是停机理论和 Y 算子的概念 , 基本都是理论上的东西 第十章 : What Is the Value of All of This? 1 2 3 4 5 6 ( define lookup-in-entry ( lambda ( name entry entry-f ) ( lookup-in-entry-help name ( first entry ) ( second entry ) entry-f )))","tags":"scheme","loc":"http://chenjiee815.github.io/thelittleschemerbi-ji.html","title":"TheLittleSchemer笔记"},{"text":"Contents 表 习题 9.1.3 习题 9.1.4 cons 和结构体的确切关系 任意长的表的数据定义 处理任意长的表 习题 9.3.1 习题 9.3.2 习题 9.3.3 设计自引用数据定义的函数 更多关于简单表的例子 习题 9.5.2 习题 9.5.3 习题 9.5.4 习题 9.5.5 习题 9.5.6 习题 9.5.7 习题 9.5.8 表 结构体 是表达复合信息的一种方法。 如果我们事先不确定有多少个数据放在一起，该用什么？ 这时候可以用 表 。 表 可以表示任意且有限数目的数据。 empty 在 Scheme 表示为一个空表。 cons 可以从一个表构造出一个更长的表。 表并非一定由同种类型的数据组成，它可以包括任何类型的数据。 first 提取表中的第一个字段，Scheme 规范好像是 car rest 提取表中的第二个字段，Scheme 规范好像是 cdr 习题 9.1.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ;; add-up-3: list-of-3-numbers -> number ;; 求表 a-list-of-3-numbers 中 3 个数之和 ( define ( add-up-3 a-list-of-3-numbers ) ( + ( first a-list-of-3-numbers ) ( first ( rest a-list-of-3-numbers )) ( first ( rest ( rest a-list-of-3-numbers ))))) ;; 递归形式和尾递归形式，题目未做要求， ;; 一时兴起写的 ;; 递归形式 ( define ( add-up-3 a-list-of-3-numbers ) ( cond [( null? a-list-of-3-numbers ) 0 ] [ else ( + ( fist a-list-of-3-numbers ) ( add-up-3 ( rest a-list-of-3-numbers )))])) ;; 尾递归形式 ( define ( add-up-3 a-list-of-3-numbers start ) ( cond [( null? a-list-of-3-numbers ) start ] [ else ( add-up-3 ( rest a-list-of-3-numbers ) ( + ( fist a-list-of-3-numbers ) start ))])) ;; distance-to-0-for-3: list-of-3-numbers -> number ;; 三维空间中某个点到原点的距离 ( define ( distance-to-0-for-3 list-of-3-numbers ) ( sqrt ( + ( sqr ( first list-of-3-numbers )) ( sqr ( first ( rest list-of-3-numbers ))) ( sqr ( first ( rest ( rest list-of-3-numbers ))))))) ;; 测试 ( distance-to-0-for-3 ' ( 2 3 4 )) 习题 9.1.4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; contains-2-doll?: a-list-of-2-symbols -> boolean ;; 判断一个包含两个符号的表中是否有 'doll ;; 模板 ( define ( contains-2-doll? a-list-of-2-symbols ) ... ( first a-list-of-2-symbols ) ... ... ( first ( rest a-list-of-2-symbols ) ... )) ( define DOLL 'doll ) ( define ( contains-2-doll? a-list-of-2-symbols ) ( or ( symbol=? ( first a-list-of-2-symbols )) ( symbol=? ( first ( rest a-list-of-2-symbols ))))) ;; 测试 ( contains-2-doll? ' ( as doll )) ( contains-2-doll? ' ( as sss )) cons 和结构体的确切关系 cons 其实是一个结构体，first 和 rest 是它的两个选择器。 1 2 3 4 5 6 7 8 9 ( define-struct pair ( left right )) ( define ( out-cons a-value a-list ) ( make-pair ( a-value a-list ))) ( define ( out-first a-pair ) ( pair-left a-pair )) ( define ( our-rest a-pair ) ( pair-right a-pair )) ( define ( out-cons? x ) ( pair? x )) 不过 cons 还有一个要求，right 字段要确保是一个表。 即，要么是 cons 结构，要么是一个空表。 1 2 3 4 5 ( define ( our-cons a-value a-list ) ( cond [( empty? a-list ) ( make-pair ( a-value a-list ))] [( our-cons? a-list ) ( make-pair ( a-value a-list ))] [ else ( error 'cons \"list as second argument expected\" )])) 任意长的表的数据定义 list-of-symbols( 符号表 ) 是下列两者之一： 空表 empty (cons s los)，其中 s 是符号，而 los 是由符号组成的表 该定义使用了自引用，或者叫递归。 处理任意长的表 习题 9.3.1 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; contains-doll?: list-of-symbols -> boolean ;; 判断符号 'doll 是否在 a-list-of-symbols 中 ( define ( contains-doll? a-list-of-symbols ) ( cond [( empty? a-list-of-symbols ) false ] [( symbol=? ( first a-list-of-symbols ) 'doll ) true ] [ else ( contains-doll? ( rest a-list-of-symbols ))])) ;; 测试 ( contains-doll? empty ) ( contains-doll? ( cons 'ball empty )) ( contains-doll? ( cons 'arrow ( cons 'doll empty ))) ( contains-doll? ( cons 'bow ( cons 'arrow ( cons 'ball empty )))) 习题 9.3.2 1 2 3 4 5 6 7 ;; contains-doll?: list-of-symbols -> boolean ;; 判断符号 'doll 是否在 a-list-of-symbols 中 ( define ( contains-doll? a-list-of-symbols ) ( cond [( empty? a-list-of-symbols ) false ] [ else ( or ( symbol=? ( first a-list-of-symbols ) 'doll ) ( contains-doll? ( rest a-list-of-symbols )))])) 习题 9.3.3 1 2 3 4 5 6 7 ;; contains?: list-of-symbols symbol -> boolean ;; 判断符号 a-symbol 是否在 a-list-of-symbols 中 ( define ( contains-doll? a-list-of-symbols a-symbol ) ( cond [( empty? a-list-of-symbols ) false ] [( symbol=? ( first a-list-of-symbols ) a-symbol ) true ] [ else ( contains-doll? ( rest a-list-of-symbols ) a-symbol )])) 设计自引用数据定义的函数 更多关于简单表的例子 习题 9.5.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ;; how-many-symbols: list-of-symbols -> number ;; 返回一个符号表中元素的个数 ( define ( how-many-symbols a-list-of-symbols ) ( cond [( empty? a-list-of-symbols ) 0 ] [ else ( + 1 ( how-many-symbols ( rest a-list-of-symbols )))])) ;; how-many-numbers: list-of-numbers -> number ;; 返回一个数值表中元素的个数 ( define ( how-many-numbers a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) 0 ] [ else ( + 1 ( how-many-numbers ( rest a-list-of-numbers )))])) ;; 两者除了参数类型不一样外，函数的具体逻辑是一模一样的 习题 9.5.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ;; dollar-store?: list-of-numbers -> boolean ;; 检查一个物价表中是否所有元素小于 1 ( define MIN_PRICE 1 ) ( define ( dollar-store? a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) false ] [ else ( and ( < MIN_PRICE ( first a-list-of-numbers )) ( dollar-store? ( rest a-list-of-numbers )))])) ( define ( super-dollar-store? a-list-of-numbers min-price ) ( cond [( empty? a-list-of-numbers ) false ] [ else ( and ( < min-price ( first a-list-of-numbers )) ( super-dollar-store? ( rest a-list-of-numbers ) min-price ))])) ;; 测试 ( dollar-store? empty ) ( not ( dollar-store? ( cons . 75 ( cons 1.95 ( cons . 25 empty ))))) ( dollar-store? ( cons . 75 ( cons . 95 ( cons . 25 empty )))) 习题 9.5.4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define-struct temp-range ( min max )) ;; 结构体 : (make-temp-range min max) ;; min, max 都为数值 ;; in-temp-range: temp-range number -> boolean ;; 检查某一个数值是否在温度区间内 ( define ( in-temp-range a-temp-range a-temp ) ( and ( >= a-temp ( temp-range-min a-temp-range )) ( <= a-temp ( temp-range-max a-temp-range )))) ;; check-range: list-of-numbers, number -> boolean ;; 检查温度值表中所有元素是否都在温度区间内 ( define ( check-range a-list-of-numbers a-temp-range ) ( cond [( empty? a-list-of-numbers ) true ] [ else ( and ( in-temp-range a-temp-range ( fist a-list-of-numbers )) ( check-range ( rest a-list-of-numbers ) a-temp-range ))])) 习题 9.5.5 1 2 3 4 5 6 7 8 9 10 11 12 ( define BASE 10 ) ;; 进制位 ;; convert: list-of-numbers -> number ;; 读取一个数值表，然后输出一个数值 ;; 数值表的顺序和数值的每位数顺序一致 ( define ( convert a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) 0 ] [ else ( + ( * ( expt BASE ( how-many-numbers a-list-of-numbers )) ( first a-list-of-numbers )) ( convert ( rest a-list-of-numbers )))])) 习题 9.5.6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ;; sum: list-of-numbers -> number ;; 求一个数值表中所有数值之和 ( define ( sum a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) 0 ] [ else ( + ( first a-list-of-numbers ) ( sum ( rest a-list-of-numbers )))])) ;; delta: list-of-numbers list-of-numbers -> number ;; 第一数值表表示月初的库存清单 ;; 第二数值表表示月末的库存清单 ;; 求两者价格差 ( define ( delta start-list-of-numbers end-list-of-numbers ) ( - ( sum end-list-of-numbers ) ( sum start-list-of-numbers ))) 习题 9.5.7 1 2 3 4 5 6 7 8 ;; average-price: list-of-numbers -> number ;; 读入一个价格表并计算其平均价格 ( define ( average-price a-list-of-numbers ) ( cond [( empty? a-list-of-numbers ) ( error 'average-price \"non-empty list-of-number expected\" )] [ else ( / ( sum a-list-of-numbers ) ( how-many-numbers a-list-of-numbers ))])) 习题 9.5.8 1 2 3 4 5 6 7 8 ;; draw-circles: posn list-of-numbers -> number ;; 读取一个圆心位置和一系列的圆半径数值表 ;; 在画布上画出所有的圆 ( define ( draw-circles center radiuses ) ( cond [( empty? radiuses ) true ] [ else ( and ( draw-circle center ( first radiuses )) ( draw-circles center ( rest radiuses )))]))","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-jiu-zhang-fu-he-shu-ju-lei-xing-zhi-er-biao.html","title":"HTDP第九章：复合数据类型之二：表"},{"text":"Contents Scheme 的词汇 Scheme 的文法 习题 8.2.1 习题 8.2.2 习题 8.2.3 习题 8.2.4 Scheme 的含义 错误 布尔值表达式 变量定义 结构体的定义 Beginning Student Scheme 的完整语法 Scheme 的词汇 <var> = x|area-of-disk|... <con> = true|false 'a|'b|... 1|-1|3/5|2.12|... <prm> = +|-|... Scheme 的文法 <def> = (define (<var> <var> ... <var>) (exp)) <exp> = <var> | <con> | (<prm> <exp> ... <exp>) | ((var) <exp> ... <exp>) | (cond (<exp> <exp>) ... (<exp> <exp>)) | (cond (<exp> <exp>) ... (else <exp>)) 习题 8.2.1 x <var> (= y z) (<prm> <var> <var>) (= (= y z) 0) (<prm> <exp> <var>) (3 + 4) 3 为一个常量 empty?(l) empty? 没有用括号包围，且参数调用也不合法 (x) 这个表达式如果按照本书图 8.2 的语法规则来说是不正确的。 因为 x 后面没有其它表达式。 但在真正的 Scheme 语法规则中是正确的。 习题 8.2.2 (define (f 'x) x) (<prm> <exp> <var>) (define (f x) x) (<prm> <exp> <exp>) (define (f x y) 3) (<prm> <exp> <con>) (define (f 'x) x) 'x 应该为一个 <var> (define (f x y z) (x)) (x) 中的 x 后面没有其它表达式 (define (f) 10) (f) 中的 f 后面没有其它表达式 习题 8.2.3 (x) 不合法，因为 x 后面没有其它表达式 (+ 1 (not x)) 符合 (<prm> <con> <exp>) (+ 1 2 3) 符合 (<prm> <con> <con> <con>) 习题 8.2.4 (define (f x) 'x) 符合 (<prm> <exp> <exp>) (define (f 'x) x) 不符合， 'x 应该为一个 <var> (define (f x y) (+ 'y (not x))) 不符合， 'y 应该为一个数值 , (not x) 也应该为一个数值 Note 这一题和标准答案不一样，我还是觉得我的正确 Scheme 的含义 错误 表达式计算原则 简化最外（最左的）可以计算的表达式。 布尔值表达式 <exp> = (and <exp> <exp>) | (or <exp> <exp>) 1 2 3 4 5 6 7 8 9 10 11 ( and <exp-1> <exp-2> ) ;; == ( cond [ <exp-1> <exp-2> ] [ else false ]) ( or <exp-1> <exp-2> ) ;; == ( cond [ <exp-1> true ] [ else <exp-2> ]) 变量定义 <def> = (define <var> <exp>) 结构体的定义 <def> = (define-struct <var0> (<var-1> <var-2> ... <var-n>)) <val> = (make-c <val> ... <val>) Beginning Student Scheme 的完整语法 <def> = (define (<var> <var> ... <var>) (exp)) | (define <var> <exp>) | (define-struct <var0> (<var-1> <var-2> ... <var-n>)) <exp> = <var> | <con> | (<prm> <exp> ... <exp>) | ((var) <exp> ... <exp>) | (cond (<exp> <exp>) ... (<exp> <exp>)) | (cond (<exp> <exp>) ... (else <exp>)) | (and <exp> <exp>) | (or <exp> <exp>)","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-ba-zhang-yu-fa-he-yu-yi.html","title":"HTDP第八章：语法和语义"},{"text":"Contents 数据混合与区分 习题 7.1.3 设计处理混合数据的函数 习题 7.2.1 习题 7.2.2 再论函数复合 习题 7.3.1 补充练习：图形的移动 习题 7.4.1 习题 7.4.2 习题 7.4.3 习题 7.4.4 习题 7.4.5 习题 7.4.6 输入错误 习题 7.5.1 习题 7.5.2 习题 7.5.3 数据混合与区分 之前设计的函数都是只能处理一种类型的数据。 这章要讲的是同一个函数如何能处理不同的类型的数据。 其实很简单，在函数的开头， 通过一定的方法先判断一下传入的数据属于哪一类型即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define PI 3.14 ) ( define-struct square ( nw length )) ;; nw 为 posn 结构体， length 为数值 ( define-struct circle ( center radius )) ;; center 为 posn 结构体， radius 为数值 ;; perimeter: a-shape -> number ;; 传入一个图形来获取其周长（只支持正方形、圆形） ( define ( perimeter a-shape ) ( cond (( square? a-shape ) ( * ( square-length a-shape ) 4 )) (( circle? a-shape ) ( * 2 ( circle-radius a-shape ) PI )))) 习题 7.1.3 1 2 3 4 5 6 ;; area: a-shape -> number ;; 传入一个图形来获取其面积（只支持正方形、圆形） ( define ( area a-shape ) ( cond (( square? a-shape ) ( sqr ( square-length a-shape ))) (( circle? a-shape ) ( * ( sqr ( circle-radius a-shape )) PI )))) 设计处理混合数据的函数 习题 7.2.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ( define-struct spider ( legs space )) ( define-struct elephant ( space )) ( define-struct monkey ( intelligence space )) ;; animal 是下列三者之一 ;; 1. 结构体：(make-spider l s) ;; l 为数值，s 为数值 ;; 2. 结构体：(make-elephant s) ;; s 为数值 ;; 3. 结构体：(make-monkey (i s)) ;; i 为数值，s 为数值 ;; 模板 ;; (define (f a-animal) ;; (cond ;; ((spider? a-animal) ...(spider-space a-animal)...) ;; ((elephant? a-animal) ...(elephant-space a-animal)...) ;; ((monkey? a-animal) ...(monkey-space)...))) ;; fits?: animal, number -> boolean ;; 判断笼子是否能容得下一个动物 ( define ( fits? animal cage-area ) ( cond [( spider? animal ) ( = ( spider-space animal ) cage-area )] [( elephant? animal ) ( = ( elephant-space animal ) cage-area )] [( monkey? animal ) ( = ( monkey-space animal ) cage-area )])) ;; 测试 ( fits? ( make-spider 6 10 ) 500 ) ( fits? ( make-elephant 10000 ) 5000 ) ( fits? ( make-monkey 30 1000 ) 800 ) 习题 7.2.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ( define-struct bus ( area passengers )) ( define-struct luxurycar ( area passengers )) ( define-struct coach ( area passengers )) ( define-struct subway ( area passengers )) ;; vehicle 是以下四者之一 ;; 1. 结构体：(make-bus a p) ;; a, p 都为数值 ;; 2. 结构体：(make-luxurycar a p) ;; a, p 都为数值 ;; 3. 结构体：(make-coach a p) ;; a, p 都为数值 ;; 4. 结构体：(make-subway a p) ;; a, p 都为数值 ;; 模板 ;; (define (f a-vehicle) ;; (cond ;; [(bus? a-vehicle) ;; ...(bus-area a-vehicle)... ;; ...(bus-passengers a-vehicle)...] ;; [(luxurycar? a-vehicle) ;; ...(luxurycar-area a-vehicle)... ;; ...(luxurycar-passengers a-vehicle)...] ;; [(coach? a-vehicle) ;; ...(coach-area a-vehicle)... ;; ...(coach-passengers a-vehicle)...] ;; [(subway? a-vehicle) ;; ...(subway-area a-vehicle)... ;; ...(subway-passengers a-vehicle)...])) 再论函数复合 习题 7.3.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( define PI 3.14 ) ( define-struct circle ( center radius )) ( define-struct square ( nw length )) ( define-struct rectangle ( nw width length )) ;; shape 是下列三者之一 ;; 1. 结构体 : (make-circle c r) ;; c 是 posn 结构体，s 是数值 n ;; 2. 结构体：(make-square n l) ;; n 是 posn 结构体，l 是数值 ;; 3. 结构体：(make-rectangle n w l) ;; n 是 posn 结构体，w, l 是数值 ;; perimeter: shape -> number ;; 计算 a-shape 的周长 ( define ( perimeter a-shape ) ( cond [( circle? a-shape ) ( * ( * 2 ( circle-radius a-shape )) PI )] [( square? a-shape ) ( * ( square-length a-shape ) 4 )] [( rectangle? a-shape ) ( * 2 ( + ( rectangle-width a-shape ) ( rectangle-length a-shape )))])) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ( define PI 3.14 ) ( define-struct circle ( center radius )) ;; 结构体 : (make-circle c r) ;; c 是 posn 结构体，s 是数值 n ( define-struct square ( nw length )) ;; 结构体：(make-square n l) ;; n 是 posn 结构体，l 是数值 ( define-struct rectangle ( nw width length )) ;; 结构体：(make-rectangle n w l) ;; n 是 posn 结构体，w, l 是数值 ;; shape 是下列三者之一 ;; 1. circle ;; 2. square ;; 3. rectangle ;; perimeter: shape -> number ;; 计算 a-shape 的周长 ( define ( perimeter a-shape ) ( cond [( circle? a-shape ) ( perimeter-circle a-shape )] [( square? a-shape ) ( perimeter-square a-shape )] [( rectangle? a-shape ) ( perimeter-rectangle a-shape )])) ;; perimeter-circle: circle -> number ;; 计算 circle 的周长 ( define ( perimeter-circle a-circle ) ( * ( * 2 ( circle-radius a-circle )) PI )) ;; perimeter-square: square -> number ;; 计算 square 的周长 ( define ( perimeter-square a-square ) ( * ( square-length a-square ) 4 )) ;; perimeter-rectangle: rectangle -> number ;; 计算 rectangle 的周长 ( define ( perimeter-rectangle a-rectangle ) ( * 2 ( + ( rectangle-width a-rectangle ) ( rectangle-length a-rectangle )))) 补充练习：图形的移动 这章的练习是 6.6 章节的扩展。 习题 7.4.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define-struct circle ( point radius color )) ( define-struct rectangle ( nw-corner width height color )) ;; shape 是下列二者之一 ;; 1. 结构体 : (make-circle point radius color) ;; point 为 posn 结构体，radius 为一个整数，color 为一个符号 ;; 2. 结构体：(make-rectangle nw-corner width height color) ;; nw-color 为一个 posn 结构体 ;; width height 为数值 ;; color 为符号 ;; 模板 ( define ( fun-for-shape a-shape ) ( cond [( circle? a-shape ) ... ( circle-point a-shape ) ... ... ( circle-radius a-shape ) ... ... ( circle-color a-shape ) ... ] [( rectangle? a-shape ) ... ( rectangle-nw-corner a-shape ) ... ... ( rectangle-width a-shape ) ... ... ( rectangle-height a-shape ) ... ... ( rectangle-color a-shape ) ... ])) 习题 7.4.2 1 2 3 4 5 6 7 8 ;; draw-shape: shape -> boolean ;; 将一个图形画到画布上 ( define ( draw-shape a-shape ) ( cond [( circle? a-shape ) ( draw-a-circle a-shape )] [( rectangle? a-shape ) ( draw-a-rectangle a-shape )])) 习题 7.4.3 1 2 3 4 5 6 7 8 9 ;; translate-shape: shape number -> shape ;; 根据原始的图形和一个数 delta， ;; 输出另外一个图形，其位于原始图形的右边 ( define ( translate-shape a-shape delta ) ( cond [( circle? a-shape ) ( translate-circle a-shape delta )] [( rectangle? a-shape ) ( translate-rectangle a-shape delta )])) 习题 7.4.4 1 2 3 4 5 6 7 8 ;; clear-shape: shape -> boolean ;; 在画布上清除一个图形 ( define ( clear-shape a-shape ) ( cond [( circle? a-shape ) ( clear-a-circle a-shape )] [( rectangle? a-shape ) ( clear-a-rectangle a-shape )])) 习题 7.4.5 1 2 3 4 5 6 7 8 ;; draw-and-clear-shape: shape -> boolean ;; 在画布上画出一个图形，然后过一段时间清除 ( define ( draw-and-clear-shape a-shape ) ( cond [( circle? a-shape ) ( draw-and-clear-circle a-shape )] [( rectangle? a-shape ) ( draw-and-clear-rectangle a-shape )])) 习题 7.4.6 1 2 3 4 5 6 7 8 ;; move-shape: delta shape -> shape ;; 绘制并消除一个图形，再平移 delta 个像素 ( define ( move-shape delta a-shape ) ( cond [( circle? a-shape ) ( move-circle a-shape )] [( rectangle? a-shape ) ( move-rectangle a-shape )])) 输入错误 习题 7.5.1 1 2 3 4 5 6 7 8 9 ( define PI 3.14 ) ( define ( area-of-disk r ) ( * PI ( * r r ))) ( define ( checked-area-of-disk v ) ( cond [( and ( number? v ) ( > v 0 )) ( area-of-disk v )] [ else ( error 'check-area-of-disk \"positive number expected\" )])) 习题 7.5.2 懒得到各章节找对应的函数了。 习题 7.5.3 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define-struct vec ( x y )) ;; 结构体 : (make-vec x y) ;; x, y 都为正数 ( define ( positive-number? v ) ( and ( number? v ) ( > v 0 ))) ( define ( check-make-vec x y ) ( cond [( and ( positive-number? x ) ( positive-number? y )) ( make-vec x y )] [ else ( error 'check-make-vec \"positive number expected\" )]))","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-qi-zhang-shu-ju-de-duo-yang-xing.html","title":"HTDP第七章：数据的多样性"},{"text":"补充练习：绘制简单图形 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; 红绿灯的大小 ( define WIDTH 50 ) ( define HEIGHT 160 ) ( define BULB-RADIUS 20 ) ( define BULB-DISTANCE 10 ) ;; 灯泡的位置 ( define X-BULBS ( quotient WIDTH 2 )) ( define Y-RED ( + BULB-DISTANCE BULB-RADIUS )) ( define Y-YELLOW ( + Y-RED BULB-DISTANCE ( * 2 BULB-RADIUS ))) ( define Y-GREEN ( + Y-YELLOW BULB-DISTANCE ( * 2 BULB-RADIUS ))) ;; 绘制红灯亮时的灯光 ( start WIDTH HEIGHT ) ( draw-solid-disk ( make-posn X-BULBS Y-RED ) BULB-RADIUS 'red ) ( draw-circle ( make-posn X-BULBS Y-YELLOW ) BULB-RADIUS 'yellow ) ( draw-circle ( make-posn X-BULBS Y-GREEN ) BULB-RADIUS 'green ) 习题 6.2.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ;; clear-bulb: symbol -> boolean ;; 关闭对应颜色的红绿灯 ( define ( clear-bulb color ) ( cond (( symbol=? color 'red ) ( clear-red-bulb )) (( symbol=? color 'green ) ( clear-green-bulb )) (( symbol=? color 'yellow ) ( clear-yellow-bulb )))) ;; clear-red-bulb ;; 关闭红灯 ( define ( clear-red-bulb ) ( and ( clear-solid-disk ( make-posn X-BULBS Y-RED ) BULB-RADIUS 'red ) ( draw-circle ( make-posn X-BULBS Y-RED ) BULB-RADIUS 'red ))) ;; clear-yellow-bulb ;; 关闭黄灯 ( define ( clear-yellow-bulb ) ( and ( clear-solid-disk ( make-posn X-BULBS Y-YELLOW ) BULB-RADIUS 'yellow ) ( draw-circle ( make-posn X-BULBS Y-YELLOW ) BULB-RADIUS 'yellow ))) ;; clear-green-bulb ;; 关闭绿灯 ( define ( clear-green-bulb ) ( and ( clear-solid-disk ( make-posn X-BULBS Y-GREEN ) BULB-RADIUS 'green ) ( draw-circle ( make-posn X-BULBS Y-GREEN ) BULB-RADIUS 'green ))) 习题 6.2.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ;; draw-bulb: symbol -> boolean ;; 打开对应颜色的红绿灯 ( define ( draw-bulb color ) ( cond (( symbol=? color 'red ) ( draw-red-bulb )) (( symbol=? color 'green ) ( draw-green-bulb )) (( symbol=? color 'yellow ) ( draw-yellow-bulb )))) ;; draw-red-bulb ;; 打开红灯 ( define ( draw-red-bulb ) ( draw-solid-disk ( make-posn X-BULBS Y-RED ) BULB-RADIUS 'red )) ;; draw-yellow-bulb ;; 打开黄灯 ( define ( draw-yellow-bulb ) ( draw-solid-disk ( make-posn X-BULBS Y-YELLOW ) BULB-RADIUS 'yellow )) ;; draw-green-bulb ;; 打开绿灯 ( define ( draw-green-bulb ) ( draw-solid-disk ( make-posn X-BULBS Y-GREEN ) BULB-RADIUS 'green )) 习题 6.2.4 1 2 3 4 ;; switch: symbol symbol -> boolean ;; 关闭第一个灯，打开第二个灯 ( define ( switch close open ) ( and ( clear-bulb close ) ( draw-bulb open ))) 习题 6.2.5 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; next: symbol -> symbol ;; 将当前红绿灯颜色救困扶危为下一颜色 ( define ( next current-color ) ( cond (( and ( symbol=? current-color 'red ) ( switch 'red 'green )) 'green ) (( and ( symbol=? current-color 'yellow ) ( switch 'yellow 'red )) 'red ) (( and ( symbol=? current-color 'green ) ( switch 'green 'yellow )) 'yellow ))) 结构体定义 Racket 创建结构体： 1 2 3 4 5 ( define-struct structname ( field1 field2 ... )) ( define tmp_entry ( make-structname field1 field2 ... )) ( structname-field1 tmp_entry ) ( structname-field2 tmp_entry ) ... 习题 6.3.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define-struct movie ( title producer )) ( define m ( make-movie 'title 'producer )) ( movie-title m ) ( movie-producer m ) ( define-struct boyfriend ( name hair eyes phone )) ( define d ( make-boyfriend 'name 'hair 'eyes 'phone )) ( boyfriend-name d ) ( boyfriend-hair d ) ( boyfriend-eyes d ) ( boyfriend-phone d ) ( define-struct cheerleader ( name number )) ( define r ( make-cheerleader 'name 'number )) ( cheerleader-name r ) ( cheerleader-number r ) ... 习题 6.3.3 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define-struct plane ( name acceleration max-speed voyage )) ;; within-range: plane number -> boolean ;; 确定某个飞机是否能够到达指定目标 ( define ( within-range plane distence ) ( >= ( plane-voyage plane ) distence )) ;; reduce-reduce: plane -> plane ( define ( reduce-range plane ) ( make-plane ( plane-name plane ) ( plane-acceleration plane ) ( plane-max-speed plane ) ( * 0.8 ( plane-voyage plane )))) 数据定义 Scheme 规范中没有强制在代码中提供方法来指定结构中每个字段的具体数据定义， 但是可以通过注释的方式来进行说明。 不过具体到各个 Scheme 方言，它们或多或少都在代码内提供相关方法来指定了。 设计处理复合数据的函数 习题 6.5.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ( define-struct movie ( title producer )) ;; movie-template: movie -> ??? ( define ( movie-template a-movie ) ... ( movie-title a-movie ) ... ... ( movie-producer a-movie ) ... ) ( define-struct boyfriend ( name hair eyes phone )) ;; boyfriend-template: boyfriend -> ??? ( define ( boyfriend-template a-boyfriend ) ... ( boyfriend-name a-boyfriend ) ... ... ( boyfriend-hair a-boyfriend ) ... ... ( boyfriend-eyes a-boyfriend ) ... ... ( boyfriend-phone a-boyfriend ) ... ) ( define-struct cheerleader ( name number )) ;; cheerleader-template: cheerleader -> ??? ( define ( cheerleader-template a-cheerleader ) ... ( cheerleader-name a-cheerleader ) ... ... ( cheerleader-number a-cheerleader ) ... ) ( define-struct CD ( artist title price )) ;; CD-template: CD -> ?? ( define ( CD-template a-CD ) ... ( CD-artist a-CD ) ... ... ( CD-title a-CD ) ... ... ( CD-price a-CD ) ... ) ( define-struct sweater ( material size producer )) ;; sweater-template: sweater -> ??? ( define ( sweater-template a-sweater ) ... ( sweater-material a-sweater ) ... ... ( sweater-size a-sweater ) ... ... ( sweater-producer a-sweater ) ... ) 习题 6.5.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ( define-struct time ( hours minutes seconds )) ;; hours, minutes, seconds 都为一个整数 ;; time->seconds: time -> number ;; 将时间转换成零晨到当前 time 的秒数 ;; (0 0 1) 就离零晨 1 秒 ;; (0 1 1) 就离零晨 61 秒 ;; (1 1 1) 就离零晨 3661 秒 ;; time-template: time -> ?? ( define ( time-template a-time ) ... ( time-hours a-time ) ... ... ( time-minutes a-time ) ... ... ( time-seconds a-time ) ... ) ( define ( time->seconds t ) ( + ( * 60 60 ( time-hours t )) ( * 60 ( time-minutes t )) ( time-seconds t ))) ;; 测试 time->seconds ( eq? ( time->seconds ( make-time 0 0 0 )) 0 ) ( eq? ( time->seconds ( make-time 0 0 1 )) 1 ) ( eq? ( time->seconds ( make-time 0 1 0 )) 60 ) ( eq? ( time->seconds ( make-time 1 0 0 )) ( * 60 60 )) ( eq? ( time->seconds ( make-time 1 1 1 )) ( + ( * 60 60 ) 60 1 )) 补充练习：圆和长方形的移动 作者将实现这个补充练习的要求：圆和长方形的移动， 拆分成多个习题，每个习题基本是一个对应一个功能函数， 当你做完所有习题，就能体会到作者来做这这个练习的做题思路了。 并且每步的习题设计都是按照之前提出的 设计决窍 来执行的。 所以一定要按步骤完成，不要为了做习题而做习题， 而是掌握 设计决窍 ，了解作者的设计思路 / 思想并模仿以及学会它。 习题 6.6.1 按照 设计决窍 , 第一步先说明数据定义，并设计该数据定义的模板。 1 2 3 4 5 6 7 8 ( define-struct circle ( point radius color )) ;; point 为 posn 结构体，radius 为一个整数，color 为一个符号 ;; fun-for-circle: circle -> ?? ( define ( fun-for-circle a-circle ) ... ( circle-point a-circle ) ... ... ( circle-radius a-circle ) ... ... ( circle-color a-color ) ... ) 习题 6.6.2 从这一题开始就是作者的做题思路了， 他将这一练习拆分成多个函数，如果让你自己做，你会有什么思路 ? 1 2 3 4 5 6 7 8 9 10 11 12 ;; draw-a-circle: circle -> boolean ;; 在屏幕上绘制一个圆 ( define ( draw-a-circle circle ) ( draw-circle ( circle-point circle ) ( circle-radius circle ) ( circle-color circle ))) ;; 测试 ( start 300 300 ) ( draw-a-circle ( make-circle ( make-posn 100 100 ) 50 'red )) ( draw-a-circle ( make-circle ( make-posn 150 150 ) 10 'yellow )) 习题 6.6.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; posn-distance: posn posn -> number ;; 得到两点之间的距离 ( define ( posn-distance posn-a posn-b ) ( sqrt ( + ( sqr ( - ( posn-x posn-a ) ( posn-x posn-b ))) ( sqr ( - ( posn-y posn-a ) ( posn-y posn-b )))))) ;; 测试 ( = ( posn-distance ( make-posn 1 1 ) ( make-posn 4 5 )) 5 ) ;; in-circle?: circle posn -> boolean ;; 判断 posn 结构体表示的点是否在圆内 ( define ( in-circle? circle posn ) ( <= ( posn-distance ( circle-point circle ) posn ) ( circle-radius circle ))) ;; 测试 ( eq? ( in-circle? ( make-circle ( make-posn 100 100 ) 50 'red ) ( make-posn 110 110 )) #t ) ( eq? ( in-circle? ( make-circle ( make-posn 100 100 ) 50 'red ) ( make-posn 200 210 )) #f ) 习题 6.6.4 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; translate-circle: circle number -> circle ;; 根据原始的圆 circle 和一个数 delta， ;; 输出另外一个圆，其圆心位于原始圆的右边 ( define ( translate-circle circle delta ) ( make-circle ( make-posn ( + ( posn-x ( circle-point circle )) delta ) ( posn-y ( circle-point circle ))) ( circle-radius circle ) ( circle-color circle ))) ;; 测试 ( eq? ( translate-circle ( make-circle ( make-posn 100 100 ) 50 'red ) 200 ) ( make-circle ( make-posn 300 100 ) 50 'red )) 习题 6.6.5 1 2 3 4 5 6 7 8 9 10 11 12 ;; clear-a-circle: circle -> boolean ;; 在画布上清除一个圆 ( define ( clear-a-circle circle ) ( clear-circle ( circle-point circle ) ( circle-radius circle ) ( circle-color circle ))) ;; 测试 ( start 300 300 ) ( define a-circle ( make-circle ( make-posn 100 100 ) 50 'red )) ( draw-a-circle a-circle ) ( clear-a-circle a-circle ) 习题 6.6.6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ;; draw-and-clear-circle: circle -> boolean ;; 在画布上画出一个圆，然后过一段时间清除 ( define ( draw-and-clear-circle circle ) ( and ( draw-a-circle circle ) ( sleep-for-a-while 1 ) ( clear-a-circle circle ))) ;; 测试 ( start 300 300 ) ( draw-and-clear-circle ( make-circle ( make-posn 100 100 ) 50 'red )) ;; move-circle: number circle -> circle ;; 绘制并消除一个圆，再平移 delta 个像素 ( define ( move-circle delta a-circle ) ( cond (( draw-and-clear-circle a-circle ) ( translate-circle a-circle delta )) ( else a-circle ))) ;; 测试 ( start 200 100 ) ( draw-a-circle ( move-circle 10 ( move-circle 10 ( move-circle 10 ( make-circle ( make-posn 100 50 ) 20 'red ))))) 习题 6.6.7 1 2 3 4 5 6 7 8 9 10 11 ( define-struct rectangle ( nw-corner width height color )) ;; nw-color 为一个 posn 结构体 ;; width height 为数值 ;; color 为符号 ;; fun-for-rect: rectangle -> ?? ( define ( fun-for-rect a-rectangle ) ... ( rectangle-nw-corner a-rectangle ) ... ... ( rectangle-width a-rectangle ) ... ... ( rectangle-height a-rectangle ) ... ... ( rectangle-color a-rectangle ) ... ) 习题 6.6.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; draw-a-rectangle: rectangle -> boolean ;; 在画布上画出一个实心长方形 ( define ( draw-a-rectangle a-rectangle ) ( draw-solid-rect ( rectangle-nw-corner a-rectangle ) ( rectangle-width a-rectangle ) ( rectangle-height a-rectangle ) ( rectangle-color a-rectangle ))) ;; 测试 ( start 300 300 ) ( draw-a-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) 习题 6.6.9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ( define-struct distance ( x y )) ;; x y 为数值 ;; fun-for-distance: distance -> ?? ( define ( fun-for-distance a-distance ) ... ( distance-x a-distance ) ... ... ( distance-y a-distance ) ... ) ;; in-rectangle?: rectangle posn ;; 判断一个像素是否在长方形内部 ( define ( in-rectangle? a-rectangle point ) ( let ( dis ( make-distance ( - ( posn-x point ) ( posn-x ( rectangle-nw-corner a-rectangle ))) ( - ( posn-y point ) ( posn-y ( rectangle-nw-corner a-rectangle ))))) ( and ( > ( distance-x dis ) 0 ) ( > ( distance-y dis ) 0 ) ( > ( distance-x dis ) ( rectangle-width a-rectangle )) ( > ( distance-y dis ) ( rectangle-height a-rectangle ))))) 习题 6.6.10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ;; translate-rectangle: rectangle -> rectangle ;; 根据原始的长方形和一个数 delta， ;; 输出另外一个长方形，其位于原始长方形的右边， ;; 左上角和原长方形的左上角距离为 delta ( define ( translate-rectangle a-rectangle ) ( let (( nw-corner ( rectangle-nw-corner a-rectangle ))) ( make-rectangle ( make-posn ( + ( posn-x nw-corner ) delta ) ( posn-y nw-corner )) ( rectangle-width a-rectangle ) ( rectangle-height a-rectangle ) ( rectangle-color a-rectangle )))) ;; 测试 ( define src-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) ( define new-rectangle ( translate-rectangle src-rectangle 20 )) ( = ( + ( posn-x ( rectangle-nw-corner src-rectangle )) 20 ) ( posn-x ( rectangle-nw-corner new-rectangle ))) 习题 6.6.11 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; clear-a-rectangle: rectangle -> boolean ;; 清除一个长方形 ( define ( clear-a-rectangle rectangle ) ( clear-solid-rect ( rectangle-nw-corner a-rectangle ) ( rectangle-width a-rectangle ) ( rectangle-height a-rectangle ) ( rectangle-color a-rectangle ))) ;; 测试 ( start 300 300 ) ( define a-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) ( draw-a-rectangle a-rectangle ) ( clear-a-rectangle a-rectangle ) 习题 6.6.12 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; draw-and-clear-rectangle: rectangle -> boolean ;; 在画布上画出一个圆，然后过一段时间清除 ( define ( draw-and-clear-rectangle rectangle ) ( and ( draw-a-rectangle rectangle ) ( sleep-for-a-while 1 ) ( clear-a-rectangle rectangle ))) ;; 测试 ( start 300 300 ) ( draw-and-clear-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) ;; move-rectangle: number rectangle -> rectangle ;; 绘制并清除一个长方形，然后平移 delta 个像素 ( define ( move-rectangle delta a-rectangle ) ( cond (( draw-and-clear-rectangle a-rectangle ) ( translate-rectangle a-rectangle delta )) ( else a-rectangle ))) ;; 创建一个长方形，并移动 4 次 ( define a-rectangle ( make-rectangle ( make-posn 100 100 ) 100 50 'red )) ( draw-a-rectangle ( move-rectangle 10 ( move-rectangle 10 ( move-rectangle 10 ( move-rectangle 10 a-rectangle ))))) 补充练习：刽子手游戏 习题 6.7.1 这一题我是直接复制官方的答案， 我压根没看懂它给的三个快照图片 ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 ;; draw-next-part: symbol -> boolean ;; 绘制人体的某一部分， ;; 函数输入为以下七个符号之一 : ;; 'right-leg 'left-leg 'left-arm 'right-arm 'body 'head 'noose ( define ( draw-next-part body-part ) ( cond [( eq? body-part 'body ) ( draw-solid-line ( make-posn 100 60 ) ( make-posn 100 130 ) 'black )] [( eq? body-part 'right-leg ) ( draw-solid-line ( make-posn 100 130 ) ( make-posn 30 170 ) 'black )] [( eq? body-part 'left-leg ) ( draw-solid-line ( make-posn 100 130 ) ( make-posn 170 170 ) 'black )] [( eq? body-part 'right-arm ) ( draw-solid-line ( make-posn 100 75 ) ( make-posn 40 65 ) 'black )] [( eq? body-part 'left-arm ) ( draw-solid-line ( make-posn 100 75 ) ( make-posn 160 65 ) 'black )] [( eq? body-part 'head ) ( and ( draw-solid-disk ( make-posn 120 50 ) 30 'red ) ( draw-solid-line ( make-posn 115 35 ) ( make-posn 123 43 ) 'black ) ( draw-solid-line ( make-posn 123 35 ) ( make-posn 115 43 ) 'black ) ( draw-solid-line ( make-posn 131 40 ) ( make-posn 139 48 ) 'black ) ( draw-solid-line ( make-posn 139 40 ) ( make-posn 131 48 ) 'black ))] [( eq? body-part 'noose ) ( and ( draw-solid-line ( make-posn 100 30 ) ( make-posn 100 10 ) 'black ) ( draw-solid-line ( make-posn 100 10 ) ( make-posn 0 10 ) 'black ))])) ;; 测试 ( start 200 200 ) ( draw-next-part 'noose ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( draw-next-part 'right-arm ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( draw-next-part 'right-arm ) ( draw-next-part 'left-arm ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( draw-next-part 'right-arm ) ( draw-next-part 'left-arm ) ( draw-next-part 'right-leg ) ( start 200 200 ) ( draw-next-part 'noose ) ( draw-next-part 'head ) ( draw-next-part 'body ) ( draw-next-part 'right-arm ) ( draw-next-part 'left-arm ) ( draw-next-part 'right-leg ) ( draw-next-part 'left-leg ) 习题 6.7.2 1 2 3 4 5 6 7 8 ( define-struct chars ( a b c )) ;; a, b, c 都是符号类型 ;; chars-template: a-chars -> ??? ( define ( chars-template a-chars ) ... ( chars-a a-chars ) ... ... ( chars-b a-chars ) ... ... ( chars-c a-chars ) ... ) 习题 6.7.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; reveal: chars chars symbol -> chars ( define ( reveal chosen status char ) ( make-chars ( cond (( symbol=? ( chars-a chosen ) char ) char ) ( else ( chars-a status ))) ( cond (( symbol=? ( chars-b chosen ) char ) char ) ( else ( chars-b status ))) ( cond (( symbol=? ( chars-c chosen ) char ) char ) ( else ( chars-c status ))))) ;; 测试 ( reveal ( make-chars 't 'e 'a ) ( make-chars '_ 'e '_ ) 'u ) ( reveal ( make-chars 'a 'l 'e ) ( make-chars 'a '_ '_ ) 'e ) ( reveal ( make-chars 'a 'l 'l ) ( make-chars '_ '_ '_ ) 'l )","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-liu-zhang-fu-he-shu-ju-zhi-yi-jie-gou-ti.html","title":"HTDP第六章：复合数据之一：结构体"},{"text":"习题 5.1.1 1 2 3 4 5 6 7 ;; replay: symbol -> symbol ;; 用布尔表达式来来表示问候与回答 ( define ( reply s ) ( or ( and ( symbol=? s 'GoodMorning ) 'Hi ) ( and ( symbol=? s 'HowAreYou? ) 'Fine ) ( and ( symbol=? s 'GoodAternoon ) 'INeedANap ) ( and ( symbol=? s 'GoodEvening ) 'BoyAmITired ))) 习题 5.1.2 1 2 3 4 5 6 7 ;; check-guess: number number -> symbol ;; 比较猜测的数和目的数得出猜测数是猜大了、是猜小了还是猜对了 ( define ( check-guess guess target ) ( cond (( < guess target ) 'TooSmall ) (( > guess target ) 'TooLarge ) ( else 'Perfect ))) 习题 5.1.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; check-guess3: number number number number -> symbol ;; 分别输入一个三位数的每位数，然后再进行猜大小 ( define ( check-guess3 n1 n2 n3 target ) ( let (( guess ( number3 n1 n2 n3 ))) ( cond (( < guess target ) 'TooSmall ) (( > guess target ) 'TooLarge ) ( else 'Perfect )))) ;; number3: number number number -> number ;; 根据一个三位数每位数，得出其数 ( define ( number3 n1 n2 n3 ) ( + n1 ( * 10 n2 ) ( * 100 n3 ))) 习题 5.1.4 1 2 3 4 5 6 7 8 ;; what-kind: number number number -> symbol ;; 根据一个方程的三个系数得出该方程是否为退化方程，如果不是则该方程有几个解 ( define ( what-kind a b c ) ( cond (( eq? a 0 ) 'degenerate ) (( > ( * b b ) ( * 4 a c )) 'two ) (( < ( * b b ) ( * 4 a c )) 'one ) ( else 'none ))) 习题 5.1.5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; check-color: symbol symbol symbol symbol -> symbol ;; 猜颜色游戏，模块第一个人的行为 ( define ( check-color t1 t2 g1 g2 ) ( cond (( and ( symbol=? t1 g1 ) ( symbol=? t2 g2 )) 'Perfect ) (( or ( symbol=? t1 g1 ) ( symbol=? t2 g2 )) 'OneColorAtCorrectPosition ) (( or ( symbol=? t1 g2 ) ( symbol=? t2 g1 )) 'OneColorOccurs ) ( else 'NothingCorrect )))","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-wu-zhang-fu-hao-xin-xi.html","title":"HTDP第五章：符号信息"},{"text":"布尔类型和关系 这一小段主要介绍了 Scheme 中有关布尔运算的知识， 为下面的段落打基础。 条件和条件函数 虽然书中给出了第二种语法，但是 Racket 以下两种都是支持的。 然后我又试了 Scheme 的另外一个方言 Guile，也是两者都支持的。 这都属于语法而已，没必要在这里纠结，只要了解它支持即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 ( cond (( condition1 ) expresssion1 ) (( condition2 ) expresssion2 ) ... ( else else_expression ) ) ( cond [( condition1 ) expression1 ] [( condition2 ) expression2 ] ... [ else else_expression2 ] ) 条件函数的设计 习题 4.4.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; interest: number -> number ;; 根据存款得出年存款收益（本金 + 利息） ( define ( interest amount ) ( + amount ( rate-amount amount ))) ;; rate-amount: number -> number ;; 根据存款得出其利息 ( define ( rate-amount amount ) ( * amount ( rate amount ))) ;; rate: number -> number ;; 根据存款额度得出其利率 ( define ( rate amount ) ( cond (( <= amount 1000 ) 0.040 ) (( <= amount 5000 ) 0.045 ) ( else 0.050 ))) 习题 4.4.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; tax: number -> number ;; 根据毛收入得出其税款 ( define ( tax income ) ( * income ( rate-tax income ))) ;; rate-tax: number -> number ;; 根据毛收入的额度得出其税率 ( define ( rate-tax income ) ( cond (( <= income 240 ) 0.000 ) (( <= income 480 ) 0.150 ) ( else 0.280 ))) ;; 每小时 12 美元收入 ( define HOUR_INCOME 12 ) ( define ( netpay-someone work_hours ) ( netpay HOUR_INCOME work_hours )) ;; netpay: number number -> number ;; 根据每周工作的小时数和每小时的毛收入得出其每周的净收入（毛收入 - 税款） ( define ( netpay hour_income work_hours ) ( * ( net-income hour_income ) work_hours )) ;; net-incone: number -> number ;; 根据毛收入获取其净收入 ( define ( net-income income ) ( - income ( tax income ))) 习题 4.4.3 这一题目有好几种解法。 我这里写出两种，其中一种就是将每种条件都写出来。 但是有一个问题就是后期如果有更多的奖励级别， 越后面的级别，要累加的函数就越多。 有没有方法避免呢？ 递归。第二种解法就是用的递归。 至于其它解法，也是在这两种解法的基础上演化而来。 比如加入缓存机制，使用连续等等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ;; 0 等级奖赏标准 ( define LEVEL0_CONSUMPTION_STD 500 ) ;; 1 等级奖赏标准 ( define LEVEL1_CONSUMPTION_STD 1500 ) ;; 2 等级奖赏标准 ( define LEVEL2_CONSUMPTION_STD 2500 ) ;; pay-back: number -> number ;; 根据一年的消费额来得出其奖励金额 ( define ( pay-back year_consumption ) ( cond (( <= year_consumption LEVEL0_CONSUMPTION_STD ) ( level0 year_consumption )) (( <= year_consumption LEVEL1_CONSUMPTION_STD ) ( + ( level0 LEVEL0_CONSUMPTION_STD ) ( level1 ( - year_consumption LEVEL0_CONSUMPTION_STD )))) (( <= year_consumption LEVEL2_CONSUMPTION_STD ) ( + ( level0 LEVEL0_CONSUMPTION_STD ) ( level1 ( - LEVEL1_CONSUMPTION_STD LEVEL0_CONSUMPTION_STD )) ( level2 ( - year_consumption LEVEL1_CONSUMPTION_STD )))) ( else ( + ( level0 LEVEL0_CONSUMPTION_STD ) ( level1 ( - LEVEL1_CONSUMPTION_STD LEVEL0_CONSUMPTION_STD )) ( level2 ( - LEVEL2_CONSUMPTION_STD LEVEL1_CONSUMPTION_STD )) ( level3 ( - year_consumption LEVEL2_CONSUMPTION_STD )))))) ;; level0: number -> number ;; 0 等级奖赏额度 ( define ( level0 consumption ) ( level ( * 0.25 ( / 1 100 )) consumption )) ;; level1: number -> number ;; 1 等级奖赏额度 ( define ( level1 consumption ) ( level ( * 0.50 ( / 1 100 )) consumption )) ;; level2: number -> number ;; 2 等级奖赏额度 ( define ( level2 consumption ) ( level ( * 0.75 ( / 1 100 )) consumption )) ;; level3: number -> number ;; 3 等级奖赏额度 ( define ( level3 consumption ) ( level ( * 1.0 ( / 1 100 )) consumption )) ;; level: number -> number ;; 根据等级奖赏比例来得出其奖赏额度 ( define ( level rate consumption ) ( * rate consumption )) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ;; 0 等级奖赏标准 ( define LEVEL0_CONSUMPTION_STD 500 ) ;; 1 等级奖赏标准 ( define LEVEL1_CONSUMPTION_STD 1500 ) ;; 2 等级奖赏标准 ( define LEVEL2_CONSUMPTION_STD 2500 ) ;; pay-back: number -> number ;; 根据一年的消费额来得出其奖励金额 ( define ( pay-back year_consumption ) ( cond (( > year_consumption LEVEL2_CONSUMPTION_STD ) ( + ( level3 ( - year_consumption LEVEL2_CONSUMPTION_STD )) ( pay-back LEVEL2_CONSUMPTION_STD ))) (( > year_consumption LEVEL1_CONSUMPTION_STD ) ( + ( level2 ( - year_consumption LEVEL1_CONSUMPTION_STD )) ( pay-back LEVEL1_CONSUMPTION_STD ))) (( > year_consumption LEVEL0_CONSUMPTION_STD ) ( + ( level1 ( - year_consumption LEVEL0_CONSUMPTION_STD )) ( pay-back LEVE0_CONSUMPTION_STD ))) ( else ( level0 year_consumption )))) ;; level0: number -> number ;; 0 等级奖赏额度 ( define ( level0 consumption ) ( level ( * 0.25 ( / 1 100 )) consumption )) ;; level1: number -> number ;; 1 等级奖赏额度 ( define ( level1 consumption ) ( level ( * 0.50 ( / 1 100 )) consumption )) ;; level2: number -> number ;; 2 等级奖赏额度 ( define ( level2 consumption ) ( level ( * 0.75 ( / 1 100 )) consumption )) ;; level3: number -> number ;; 3 等级奖赏额度 ( define ( level3 consumption ) ( level ( * 1.0 ( / 1 100 )) consumption )) ;; level: number -> number ;; 根据等级奖赏比例来得出其奖赏额度 ( define ( level rate consumption ) ( * rate consumption )) 习题 4.4.4 1 2 3 4 5 6 7 ;; how-many: number number number -> number ;; 根据方程 ax&#94;2 + bx + c = 0, 得出该方程解的个数 ( define ( how-many a b c ) ( cond (( > ( * b b ) ( * 4 a c )) 2 ) (( < ( * b b ) ( * 4 a c )) 0 ) ( else 1 )))","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-si-zhang-tiao-jian-biao-da-shi-he-han-shu.html","title":"HTDP第四章：条件表达式和函数"},{"text":"函数复合 电影院定制电影票价格的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ;; profit: number -> number ;; 利润 ( define ( profit ticket-price ) ( - ( revenue ticket-price ) ( cost ticket-price ))) ;; revenue: number -> number ;; 收入 ( define ( revenue ticket-price ) ( * ( attendees ticket-price ) ticket-price )) ;; cost: number -> number ;; 支出 ( define ( cost ticket-price ) ( + 180 ( * 0.04 ( attendees ticket-price )))) ;; attendees: number -> number ;; 观众数 ( define ( attendees ticket-price ) ( + 120 ( * 10 ( - 5.0 ticket-price ) 15 ))) 上面是使用辅助函数实现的代码。由该问题引出一条程序设计原则： 辅助函数原则 对在表述中所提到的或在进行实例计算中所发现的每种依赖关系 都使用一个辅助函数进行明确表达。 习题 3.14，这一题能够很明显看到使用辅助函数的好处， 虽然需求改变，但是只需要改变 cost 函数的具体算法即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; profit: number -> number ;; 利润 ( define ( profit ticket-price ) ( - ( revenue ticket-price ) ( cost ticket-price ))) ;; revenue: number -> number ;; 收入 ( define ( revenue ticket-price ) ( * ( attendees ticket-price ) ticket-price )) ;; cost: number -> number ;; 支出 ( define ( cost ticket-price ) ( * ( + 0.04 1.5 ) ( attendees ticket-price ))) ;; attendees: number -> number ;; 观众数 ( define ( attendees ticket-price ) ( + 120 ( * 10 ( - 5.0 ticket-price ) 15 ))) 变量定义 变量定义原则 给频繁使用的常量定义一个名字，并在程序中使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ( define FILM_COST 180 ) ( define ATTENDEES_COST 0.04 ) ( define ATTENDEES_AT_MAX_TICKET_PRICE 120 ) ( define MAX_TICKET_PRICE 5.0 ) ( define PER_ADD_ATTENDEES_NUM 15 ) ( define PER_SUB_TICKET_PRICE 0.1 ) ;; profit: number -> number ;; 利润 ( define ( profit ticket-price ) ( - ( revenue ticket-price ) ( cost ticket-price ))) ;; revenue: number -> number ;; 收入 ( define ( revenue ticket-price ) ( * ( attendees ticket-price ) ticket-price )) ;; cost: number -> number ;; 支出 ( define ( cost ticket-price ) ( + FILM_COST ( * ATTENDEES_COST ( attendees ticket-price )))) ;; attendees: number -> number ;; 观众数 ( define ( attendees ticket-price ) ( + ATTENDEES_AT_MAX_TICKET_PRICE ( * ( / PER_ADD_ATTENDEES_NUM PER_SUB_TICKET_PRICE ) ( - MAX_TICKET_PRICE ticket-price )))) 函数复合练习 习题 3.3.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ;; british->metric: number -> number ;; 英制转换成公制 ( define ( british->metric reduced_unit num ) ( * reduced_unit num )) ( define INCHES->CM_UNIT 2.54 ) ;; inches->cm: number -> number ( define ( inches->cm num ) ( british->metric INCHES->CM_UNIT num )) ( define FEET->INCHES_UNIT 12 ) ;; feet->inches: number -> number ( define ( feet->inches num ) ( british->metric FEET->INCHES_UNIT num )) ( define YARDS->FEET_UNIT 3 ) ;; yards->feet: number -> number ( define ( yards->feet num ) ( british->metric YARDS->FEET_UNIT num )) ( define RODS->YARDS_UNIT ( / 1 2 ) 5 ) ;; rods->yards: number -> number ( define ( rods->yards num ) ( british->metric RODS->YARDS_UNIT num )) ( define FURLONGS->RODS_UNIT 40 ) ;; furlongs->rods: number -> number ( define ( furlongs->rods num ) ( british->metric FURLONGS->RODS_UNIT num )) ( define MILES->FURLONGS_UNIT 8 ) ;; miles->furlongs: number -> number ( define ( miles->furlongs num ) ( british->metric MILES->FURLONGS_UNIT num )) ;; feet->cm: number -> number ( define ( feet->cm num ) ( inches->cm ( feet->inches num ))) ;; yards->cm: number -> number ( define ( yards->cm num ) ( inches->cm ( feet->inches ( yards->feet num )))) ;; yards->cm: number -> number ( define ( rods->inches num ) ( feet->inches ( yards->feet ( rods->yards num )))) ;; yards->cm: number -> number ( define ( miles->feet num ) ( yards->feet ( rods->yards ( furlongs->rods ( miles->furlongs num ))))) 习题 3.3.2 1 2 3 4 5 6 ( define PI 3.14 ) ;; volume-cylinder: number -> number ;; 求圆柱体体积 ( define ( volume-cylinder radius height ) ( * PI ( * radius radius ) height )) 习题 3.3.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( define PI 3.14 ) ;; circumference-bottem: number -> number ;; 底部的周长 ( define ( circumference-bottem radius ) ( * 2 PI radius )) ;; area-bottem: number -> number ;; 底部面积 ( define ( area-bottem radius ) ( * PI ( * radius radius ))) ;; area-flank: number number -> number ;; 侧面积 ( define ( area-flank radius height ) ( * height ( circumference-bottem radius ))) ;; area-cylinder: number number -> number ;; 求圆柱体的表面积 ( define ( area-cylinder radius height ) ( + ( area-flank radius height ) ( * 2 ( area-bottem radius )))) 习题 3.3.4 单一函数版本 Pass 辅助函数版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ( define PI 3.14 ) ;; area-pipe: number number number -> number ;; 管道（中空的圆柱体）的表面积 ( define ( area-pipe inner_radius length thickness ) ( let (( outer_radius ( outer-radius inner_radius thickness ))) ( + ( outer-area-flank length outer_radius ) ( inner-area-flank length inner_radius ) ( * 2 ( area-ring outer_radius inner_radius ))))) ;; outer-area-flank: number number -> number ;; 外部的侧面积 ( define ( outer-area-flank length outer_radius ) ( area-flank outer_radius length )) ;; inner-area-flank: number number -> number ;; 内部的侧面积 ( define ( inner-area-flank length inner_radius ) ( area-flank inner_radius length )) ;; area-ring: number number -> number ;; 空心圆的面积 ( define ( area-ring outer_radius inner_radius ) ( - ( area-cycle outer_radius ) ( area-cycle inner_radius ))) ;; outer-radius: number number -> number ;; 外半径 ( define ( outer-radius inner_radius thickness ) ( + inner_radius thickness )) ;; area-flank: number number -> number ;; 侧面积 ( define ( area-flank radius height ) ( * height ( circumference-cycle radius ))) ;; area-cycle: number -> number ;; 圆面积 ( define ( area-cycle radius ) ( * PI ( * radius radius ))) ;; circumference-cycle: number -> number ;; 圆周长 ( define ( circumference-cycle radius ) ( * 2 PI radius )) 习题 3.3.5 1 2 3 4 5 6 7 8 9 10 11 ( define G 9.8 ) ;; 重力加速度 ;; height: number -> number ;; 计算火箭升空后在给定时刻所到达的高度 ( define ( height sec ) ( * ( / 1 2 ) ( speed sec ) sec )) ;; speed: number -> number ;; 计算火箭升空后在给定时刻所到达的速度 ( define ( speed sec ) ( * G sec )) 习题 3.3.6 Pass","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-san-zhang-cheng-xu-jiu-shi-han-shu-jia-shang-bian-liang-ding-yi.html","title":"HTDP第三章：程序就是函数加上变量定义"},{"text":"这一章开始 4 小段简单介绍了一下 Racket/Scheme 语法。 Racket/Scheme 的语法相当简单，所以廖廖几页就说完了。 相关的习题也是讲解： 各种不符合 Racket/Scheme 语法情况下的代码的运行出错提示是什么。 2.5 段则给出了一个 设计诀窍 表格。 其实就是设计一个函数的具体步骤有哪些。 程序设计原则 这里我也具体列出下面每章都会提及的程序设计原则。 辅助函数原则 对在表述中所提到的或在进行实例计算中所发现的每种依赖关系 都使用一个辅助函数进行明确表达。 变量定义原则 给频繁使用的常量定义一个名字，并在程序中使用。 表达式计算原则 简化最外（最左的）可以计算的表达式。","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-er-zhang-shu-biao-da-shi-he-jian-dan-cheng-xu.html","title":"HTDP第二章：数、表达式和简单程序"},{"text":"Contents 返回表的函数 习题 10.1.1 习题 10.1.2 习题 10.1.3 习题 10.1.4 习题 10.1.5 习题 10.1.6 习题 10.1.7 习题 10.1.8 返回表的函数 习题 10.1.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ;; hours->wages: list-of-numbers -> list-of-numbers ;; 由周工作时间表得到周工资表 ( define ( hours->wages alon ) ( cond [( empty? alon ) empty ] [ else ( cons ( wage ( first alon )) ( hours->wages ( rest alon )))])) ( define PER_HOUR_WAGE 14 ) ;; 每小时工资 ;; wage: number -> number ;; 根据工时计算工资 ( define ( wage h ) ( * PER_HOUR_WAGE h )) 习题 10.1.2 对 alon 中的每个周工作时间进行检查，确保没有 >100 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ;; hours->wages: list-of-numbers -> list-of-numbers ;; 由周工作时间表得到周工资表 ( define ( hours->wages alon ) ( cond [( empty? alon ) empty ] [ else ( cons ( wage ( first alon )) ( hours->wages ( rest alon )))])) ( define PER_HOUR_WAGE 14 ) ;; 每小时工资 ( define MAX_HOURS 100 ) ;; 每周最大工作小时数 ;; wage: number -> number ;; 根据工时计算工资 ( define ( wage h ) ( cond [( > h MAX_HOURS ) ( error 'wage \"too many hours\" )] [ else ( * PER_HOUR_WAGE h )])) 习题 10.1.3 解题思路和 10.1.2 是一样的。 习题 10.1.4 解题思路和 10.1.2 是一样的。 习题 10.1.5 1 2 3 4 5 6 7 8 9 10 11 12 ;; eliminate-exp: number list-of-numbers -> list-of-numbers ;; 读入一个数和玩具价格表 ;; 返回玩具价格表中所有比较那个数小的值 ( define ( eliminate-exp ua lotp ) ( cond [( empty? lotp ) empty ] [( > ( first lotp ) ua ) ( eliminate-exp ( rest lotp ))] [ else ( cons ( first lotp ) ( eliminate-exp ( rest lotp )))])) ;; 测试 ( eliminate-exp 1.0 ( cons . 95 ( cons 1.0 empty ))) 习题 10.1.6 1 2 3 4 5 6 7 8 9 10 11 12 ;; substitute: symbol symbol list-of-symbols -> list-of-symbols ;; 读取两个符号 new old，和一个符号表 list-of-symbols， ;; 返回一个新的符号表，其中所有 old 替代为 new ( define ( substitute new old name-robot ) ( cond [( empty? lotp ) empty ] [( = old ( first name-robot )) ( cons new ( substitute new old ( rest name-robot )))] [ else ( cons old ( substitute new old ( rest name-robot )))])) ;; 测试 ( substitute ( cons 'robot ( cons 'Barbie ( cons 'dress empty )))) 习题 10.1.7 1 2 3 4 5 6 7 8 9 10 ;; recall: symbol list-of-symbols -> list-of-symbols ;; 从符号表 lon 中移除 ty ( define ( recall ty lon ) ( cond [( empty? ty ) empty ] [( = ty ( first lon )) ( recall ty ( rest lon ))] [ else ( cons ( first lon ) ( recall ty ( rest lon )))])) ;; 测试 ( recall ( cons 'doll ( cons 'dress empty ))) 习题 10.1.8 1 ;;","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-shi-zhang-biao-de-jin-yi-bu-chu-li.html","title":"HTDP第十章：表的进一步处理"},{"text":"第一章对程序设计这个概念作了一个简单介绍。 本书主要使用的是 Scheme 语言的一种方言，叫做 Racket。 我在这里简单说介绍一下 HTDP 用到的教学软件包。 从 Racket 官方网站 下载最新版本的 Racket 软件。 运行命令 drracket 。 在 语言 中 选择语言 ... 选择 教学语言 (ctl-T) 。 级别随便选择，我一开始做习题就是选择 初级 。 然后根据课后习题的要求，在 语言 中选择 加载教学包 ... 。","tags":"scheme","loc":"http://chenjiee815.github.io/htdpdi-yi-zhang-xue-sheng-lao-shi-he-ji-suan-ji.html","title":"HTDP第一章：学生、老师和计算机"},{"text":"setuptools 官方文档 以下内容是根据官方文档做的笔记。 Contents 推荐用法 基本用法 版本号格式 可选的 setup() 函数参数 使用 find_packages() 脚本的自动生成 Eggsecutable 脚本 依赖的声明 数据文件的安装 依赖包的声明 easy_install pkg_resources 命名空间包 工作集对象 推荐用法 在项目根目录添加 ez_setup.py 文件， 然后在 setup.py 文件的开头添加如下代码： 1 2 from ez_setup import use_setuptools use_setuptools () 这样写的话，其他人安装你的 Python 包时， 如果没有安装 setuptools 工具，该脚本就会自动下载并安装 setuptools。 当然也可以通过这个脚本来直接安装、更新 setuptools： 1 $ sudo python ez_setup.py -U setuptools 基本用法 下面是一个最基本的 setup.py。 1 2 3 4 5 6 from setuptools import setup , find_packages setup ( name = \"HelloWorld\" , version = \"0.1\" , packages = find_packages (), ) 就是这里的几行代码，就可以自动查找需要打包的文件， 将当前的项目打包成 eggs，支持上传到 PyPI 。 当然如果需要上传到 PyPI ，最好再添加一些额外信息。 版本号格式 setuptools 能够支持大部分的版本号格式。 如果您不是很确定您定义的版本号是否被 setuptools 支持， 您可以使用 pkg_resources.parse_version() 来判断。 1 2 3 4 5 6 7 >>> from pkg_resources import parse_version >>> parse_version ( '1.9.a.dev' ) == parse_version ( '1.9a0dev' ) True >>> parse_version ( '2.1-rc2' ) < parse_version ( '2.1' ) True >>> parse_version ( '0.6a9dev-r41475' ) < parse_version ( '0.6a9' ) True 可选的 setup() 函数参数 include_package_data 如果设置为 True，setuptools 就会在项目目录里自动查找所有的数据文件 这些数据文件包括被 CVS/SVN 进行版本管理的， 或者你在 MANIFEST.in 中指定的文件。 详见 数据文件的安装 。 exclude_package_data 它的值为一个字典。 打包时排除某些文件 / 目录， 即使该文件 / 目录在 include_package_data 指定的范围内。 详见 数据文件的安装 。 package_data 它的值也为一个字典。 如果 include_package_data 值为 True，那么这个参数就没必要再用。 它提供了更细粒度的控制哪些文件该被打包。 详见 数据文件的安装 。 zip_safe 它的值为 True/False。它用来指定打出来的 ZIP 包是否能够安全的被安装， 或者直接运行。 如果你不提供该值， bdist_egg 子命令每次打包时都需要做检查。 zip 包形式能够占用更少的磁盘空间，且加载速度更快（ 就一个文件，虽然要解压，但是 CPU 速度远快于磁盘速度）。 install_requires 该值为一个列表，其中每个值表示该包所依赖的包的名称。 当你在安装该包时，setuptools 会自动安装它所依赖的那些包。 详见 依赖包的声明 。 entry_points 该值为一个字典。是用来动态地发现该包所提供的服务或者插件。 详见 ` 服务和插件的动态发现 `_ 。 额外插一句，该值也可以用来 脚本的自动生成 。 extras_require 该值为一个字典。用来指定你的包所提供的额外功能所需要用来的依赖包。 详见 依赖的声明 。 setup_requires 该值为一个字符串列表。 当你在执行 setup.py 时需要安装哪些额外的包，你可以在该值里面指定。 Note 这些包默认只会下载下来，并不会进行安装。 如果需要安装请配合使用 install_requires 和 setup_requires dependency_links 该值为一个字符串列表。 用来查找依赖包的 URLs。 namespace_packages 该值为一个字符串列表。 命名空间包是一个包含多个其它包的虚拟包。 详见 命名空间包 。 test_suite 该值为一个字符串。 用来指定测试该包用的一个测试套件。比如 nosetest 。 指定之后，就可以通过 python setup.py test 来进行测试。 详见 `test 命令 `_ 。 tests_require 该值为一个字符串或者一个字符串列表。 如果测试该包需要安装一些额外的包，请在该值内指定。 Note 这些额外的包并不会安装到系统里，默认只会下载下来。 test_loader 如果你不想用 setuptools 的默认查找测试用例的规则，而是想自己自定义， 那么，这个参数正合你意。 eager_resources 该值为一个字符串列表。 详见 ` 资源的自动扩展 `_ 。 use_2to3 在编译过程中使用 2to3 脚本来将 Python2 的代码转换成 Python3 的代码。 convert_2to3_doctests 该值为一个字符串列表。 用来指定哪些 doctest 源代码需要使用 2to3 脚本进行转换的。 use_2to3_fixers 该值为一个字符串列表。 在 2to3 的转换过程中还哪些额外的 fixers。 使用 find_packages() 针对简单的项目，你可以直接手工在 packages 参数里指定需要打包的文件。 但是针对非常大型的项目（Twisted, PEAK, Zope, Chandler, etc.）， find_packages() 是派得上用场了。 find_packages() 有三个参数： where, 指定源目录，默认为 setup.py 脚本所在的目录。 exclude, 类似于 exclude_package_data include, 类似于 include_package_data 脚本的自动生成 打包和安装脚本对于 distutils 模块来说有点棘手。 没有一个比较容易的指定符合各个平台（Windows、Linux，etc）约定的脚本名称。 你需要专门为 main 函数创建一个脚本。 setuptools 就解决如上的所有问题。它可以自动创建脚本。 在 Windows 平台甚至直接生成 exe 文件。 当然，想要 setuptools 自动完成这一切， 你需要在 entry_points 参数说明。 1 2 3 4 5 6 7 8 9 10 11 12 setup ( # other arguments here... entry_points = { 'console_scripts' : [ 'foo = my_package.some_module:main_func' , 'bar = other_module:some_func' , ], 'gui_scripts' : [ 'baz = my_package_gui.start_func' , ] } ) Eggsecutable 脚本 某些情况，你可能需要让一个 egg 格式的 Python 包能够直接被执行。 那么，你只需要像下面一样做就可以了： 1 2 3 4 5 6 7 8 setup ( # other arguments here... entry_points = { 'setuptools.installation' : [ 'eggsecutable = my_package.some_module:main_func' , ] } ) Note eggsecutable 的 egg 包不能被重命名或者通过连接来执行。 依赖的声明 数据文件的安装 setuptools 提供三种方式来定制包内的数据文件。 你需要将打开 include_package_data 参数。 1 2 3 4 5 from setuptools import setup , find_packages setup ( ... include_package_data = True ) 这个参数会告诉 setuptools 自动查找包内包含的数据文件， 但是自动查找是有要求的。 这些数据文件必须是在 CVS/SVN 这些版本管理工具的仓库里面受版本控制的 （当然你也可以写 setuptools 扩展来支持其它的版本管理工具）， 或者在 MANIFEST.in 文件中被指定的。 如果你想有比较细粒度地控制 setuptools 打包哪些数据文件， 那么你可以使用 package_data 参数。 1 2 3 4 5 6 7 8 9 10 from setuptools import setup , find_packages setup ( ... package_data = { # If any package contains *.txt or *.rst files, include them: '' : [ '*.txt' , '*.rst' ], # And include any *.msg files found in the 'hello' package, too: 'hello' : [ '*.msg' ], } ) package_data 参数是一个字典，它的 Key 值是包内目录的名称， Value 值是一个包含通配符字符串的列表。 比如一个包的内部目录结构 setup.py src/ mypkg/ __init__.py mypkg.txt data/ somefile.dat otherdata.dat 那么它对应的 package_data 参数就是： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from setuptools import setup , find_packages setup ( ... packages = find_packages ( 'src' ), # include all packages under src package_dir = { '' : 'src' }, # tell distutils packages are under src package_data = { # If any package contains *.txt files, include them: '' : [ '*.txt' ], # And include any *.dat files found in the 'data' subdirectory # of the 'mypkg' package, also: 'mypkg' : [ 'data/*.dat' ], } ) 注意：上面两个示例中 package_data 的一个 Key 值是一个空字符串， 这个就代表会在所有的目录里查找对应的数据文件。 注意：如果你使用到了路径，请使用 / 来指定路径分隔， 即使在 Windows 平台也是这样，setuptools 会根据当前的打包平台自动识别。 注意：在 Python2.4 之后的 distutils 模块也添加对该参数的支持。 如果你指定了 include_package_data 参数，那么 package_data 将无效。 但是还有些情况，以上两个参数还是满足不了。 比如你想在你发布的 Python 包内包含 README 文件， 但是安装的时候又不希望安装它。 这时候，你就需要 exclude_package_data 参数来帮忙了。 1 2 3 4 5 6 7 8 9 10 11 from setuptools import setup , find_packages setup ( ... packages = find_packages ( 'src' ), # include all packages under src package_dir = { '' : 'src' }, # tell distutils packages are under src include_package_data = True , # include everything in source control # ...but exclude README.txt from all packages exclude_package_data = { '' : [ 'README.txt' ] }, ) exclude_package_data 参数和 package_data 是一样的， 也是字典，在该字典里匹配到的所有文件都不会被安装。 即使这个文件符合 include_package_data 或者 package_data 参数 的要求。 注意： disutils 模块的打包流程会导致一种现象， 你之前的包有包含过某些数据文件，但之后你又删除了该数据文件。 那么这些数据文件在你的打包目录便会变成孤儿，你最好运行命令 python setup.py clean --all 来完全删除它们。 你的这个包的使用者或者其它代码贡献者通过版本管理工具追踪版本时， 他们就会知道是你做了某些改变，然后需要删除这此文件的， 那么他们也就能够放心大胆运行 python setup.py clean --all 命令了。 依赖包的声明 easy_install pkg_resources 该模块的全称为： Package Discovery and Resource Access 这个模块主要有以下几个功能： 提供 API 给 Python 库来让它们能够访问它们自己的资源文件 能让扩展的应用和框架自动发现插件 给 zip 格式的 eggs 包内的 C 扩展提示运行时支持 能够合并各种独立分发的 Python 模块，就是下文的命名空间包 提供 API 来管理当前 \" 工作集 \" 中的 Python 包 命名空间包 命名空间包本质算是一个虚拟包， 这个包主要将多个独立分发的包集合成一个，方便安装。 比如： peak 是一个命名空间包，它包含了一系列不同用途的子包。 那么如何创建一个命名空间包呢？ 在 setup() 函数中添加 namespace_package 参数。 该参数为一个列表，然后将需要集合的包的名称写进去。 你也必须在命名空间包的 __init__.py 文件中添加 __declare_namespace() 函数的调用。 工作集对象 Docutils System Messages System Message: ERROR/3 ( /media/cj/self/git/chenjiee815_blogs/chenjiee815_blogs/content/python/tools/setuptools_guide.rst , line 120); backlink Unknown target name: \" 服务和插件的动态发现 \". System Message: ERROR/3 ( /media/cj/self/git/chenjiee815_blogs/chenjiee815_blogs/content/python/tools/setuptools_guide.rst , line 158); backlink Unknown target name: \"test 命令 \". System Message: ERROR/3 ( /media/cj/self/git/chenjiee815_blogs/chenjiee815_blogs/content/python/tools/setuptools_guide.rst , line 180); backlink Unknown target name: \" 资源的自动扩展 \".","tags":"python","loc":"http://chenjiee815.github.io/setuptoolszhi-nan-wei-wan-dai-xu.html","title":"setuptools指南：未完待续"},{"text":"pip 官方文档 以下内容是根据 pip 的 1.5.X 版本的官方文档写的笔记。 官方文档有用户指南专门一章节，我翻译时将之分割到多个章节中去了。 Contents 安装 pip 升级 pip 常用命令介绍 配置 配置文件 环境变量 配置的优先级 命令的自动补全 pip install 使用方法 本地快速安装 非递归式升级 特定用户安装 pip uninstall 使用方法 已知缺陷 参数 pip freeze 使用方法 参数 常见应用场景 pip list 使用方法 参数 pip show 使用方法 参数 pip search 使用方法 参数 pip wheel 使用方法 参数 常见应用场景 其它 国内镜像源 安装 pip 可以下载 get-pip.py ， 运行命令： 1 $ python get-pip.py 如果 setuptools 没有安装，该命令同时也会安装它。 如果已经安装了 setuptools 库，那么可以通过 easy_install 安装： 1 $ easy_install pip 升级 pip 在 Linux 系统上： 1 $ pip insall -U pip 在 Windows 系统上： 1 $ python -m pip install -U pip 常用命令介绍 安装包 1 $ pip install SomePackage 升级包 1 2 3 $ pip install --upgrade SomePackage $ pip install -U SomePackage 删除包 1 $ pip uninstall SomePackage 查看某个包安装了哪些文件 1 $ pip show --files SomePackage 列出哪些包过期了，或者说是有新的版本了 1 $ pip list --outdated 配置 配置文件 配置文件路径： Unix: ~/.pip/pip.conf Windows: %HOMEPATH%pippip.ini 当然，如果你想自定义配置文件的存放路径，你可以将你自定义的路径保存到环境变量 PIP_ONFIG_FILE 。 配置文件的格式类似于 INI 文件。 当你想添加一个对所有命令都生效的参数时，可以将该配置放置在 [global] 段中。例如： 1 2 3 [global] timeout = 60 index-url = http://pypi.douban.com/simple 如果你想针对 pip 的某个子命令进行配置的话，可以将该子命令名称当作段名称，该段内的配置与 [global] 中的配置冲突则会覆盖之。 比如 freeze 子命令： 1 2 [freeze] timeout = 10 比如 install 子命令： 1 2 3 4 5 6 [install] ignore-installed = true no-dependencies = yes find-links = http://mirror1.example.com http://mirror2.example.com 环境变量 pip 的命令行参数也可以通过环境变量来设置。 它的格式为： PIP_<UPPER_LONG_NAME> 。 比如设置超时： 1 $ export PIP_DEFAULT_TIMEOUT = 60 其效果等于： 1 $ pip --default-timeout = 60 [ ... ] 比如设置 find-links： 1 $ export PIP_FIND_LINKS = \"http://mirror1.example.com http://mirror2.example.com\" 其效果等于： 1 2 $ pip install --find-links = http://mirror1.example.com --find-links = http://mirror2.example.com 配置的优先级 刚才讲到一个参数的三种配置方法优先级顺序是： 命令行 环境变量 配置文件 命令的自动补全 用过 bash/zsh 环境的人都知道有自动补全功能。 pip 命令想要自动补全功能的话，可以运行以下命令： 1 2 3 $ pip completion --bash >> ~/.profile $ pip completion --zsh >> ~/.zprofile 加入到 profile 文件后，需要重新进入 bash/zsh 环境才能生效，你也可以运行以下命令，立即生效自动补全功能： 1 $ eval \"`pip completion --bash`\" pip install 安装 Python 包 使用方法 1 2 3 4 5 6 7 8 9 $ pip install [ options ] <requirement specifier> ... $ pip install [ options ] -r <requirements file> ... $ pip install [ options ] [ -e ] <vcs project url> ... $ pip install [ options ] [ -e ] < local project path> ... $ pip install [ options ] <archive url/path> ... 本地快速安装 下载你所需要的所有的 Python 包 1 $ pip install --download <DIR> -r requirements.txt 使用以下命令即可安装刚才下载到本地的 Python 包 1 $ pip install --no-index --find-links =[ file:// ] <DIR> -r requirements.txt 非递归式升级 其实就是只升级你需要的包，但是该包所依赖的包不安装 / 升级。 1 $ pip install --upgrade --no-deps SomePackage 特定用户安装 从 Python2.6 开始，Python 就支持将 Python 包安装到指定的用户目录了。 该用户的目录默认值是由 site.USER_BASE 所指定的。 如果想覆盖该值，则使用环境变量 PYTHONUSERBASE 。 可以通过 --user 参数来指定特定用户。 1 2 $ export PYTHONUSERBASE = /myappenv $ pip install --user SomePackage pip uninstall 卸载 Python 包 使用方法 1 2 3 $ pip uninstall [ options ] <package> ... $ pip uninstall [ options ] -r <requirements file> ... 已知缺陷 目前已知的两种无法正常删除的情况： 完全使用 disutils 模块制定的 Python 包，且通过 python setup.py install 来安装的。这种包没有什么元信息能够知道它倒底安装了哪些文件。 通过 python setup.py develp 来安装的脚本。 参数 -r , --requirement <file> 删除 requirements.txt 文件中的包含的 Python 包名，可以跟多个该参数 -y , --yes 在删除时不需要确认 pip freeze 将当前 Python 环境所有的安装包名输出成 requirements 格式。 使用方法 1 $ pip freeze [ options ] 参数 -r , --requirement <file> 先输出该 requirement 文件内的 Python 包名。 再输出当前环境安装的 Python 包，requirement 文件中有的 Python 包名则不再显示。 当 requirement 文件中的包名在环境没有，则会给出提示。 -f , --find-links <url> 从该 URL 来查找 Python 包，查找出来的 Python 包名也会输出出来。 说实话，我还真不知道这个参数的应用场景是什么。 -l , --local 如果一个 virtualenv 环境被配置成能够读取全局的 Python 包，那么在该环境内运行 pip freeze -l 时，不会显示全局的 Python 包名。 常见应用场景 当你需要将一个 virtualenv 环境中复制到另外一个 virtualenv 环境时，你可以先在源 virtualenv 环境运行命令： 1 $ pip freeze > requirements.txt 然后再进入目的 virtualenv 环境运行命令： 1 $ pip install -r requirements.txt 这样就完成了虚拟环境的复制过程。 这时可能有人会问，virtualenv 环境不就是一个目录么，直接拷贝一下，不就一个跟原来一样的新的 virtualenv 环境么？ 好吧，我觉得这方法一般情况也可以的。 但是如果源 virtualenv 环境和目的 virtualenv 环境的 Python 版本或者操作系统不一样，建议你还是老实地按照上面的说做吧。 pip list 列出当前环境所有已经安装的 Python 包，包括可编辑的包（including editables）。 好像功能和 pip freeze 功能差不多的么，只是输出的格式不一样。 可编辑的包是啥意思？暂时还不清楚。 使用方法 1 $ pip list [ options ] 参数 -o , --outdated 列出所有有新版本的 Python 包名（不包括可编辑包） -u , --uptodate 列出所有更新到最新版本的 Python 包名 -e , --editable 列出所有可编辑的包名 -l , --local 如果一个 virtualenv 环境被配置成能够读取全局的 Python 包，那么在该环境内运行 pip list -l 时，不会显示全局的 Python 包名。 --pre 列出的包中包括预发行或者是开发包，默认只会列出稳定版本的包 -i , --index-url <url> Python Package Index 的 URL 地址 --extra-index-url <url> 更多的 Python Package Index 的 URL 地址 --no-index 忽略包索引，只与 --find-links 参数配合使用 -f , --find-links <url> 如果为一个 URL 或者是一个指定 HTML 页面的路径，PIP 会从该地址解析出包地址。 如果是一个本地目录，PIP 就会直接从该目录中查找所需要的包。 --allow-external <package> Allow the installation of externally hosted files --allow-all-external Allow the installation of all externally hosted files --allow-unverified <package> Allow the installation of insecure and unverifiable files --process-dependency-links Enable the processing of dependency links pip show 列出一个或者多个包的信息 使用方法 1 $ pip show [ options ] <package> ... 参数 -f , --files 列出一个已安装包中的所有文件 pip search 从 Python Package Index 上查找 Python 包名或者其简要描述中包含关键字（<query>）的 Python 包。 使用方法 1 $ pip search [ options ] <query> 参数 --index <url> Python Package Index URL 地址 pip wheel 创建 wheel 格式的 Python 包 使用该参数，需要您的环境安装 setuptools >= 0.8，并且安装了 wheel。 pip wheel 使用 setuptools 扩展 bdist_wheel 来制作 wheel 格式的 Python 包。 如果想更多了解 wheel，请看 wheel 官方文档 。 使用方法 1 2 3 4 5 6 7 8 9 $ pip pip wheel [ options ] <requirement specifier> ... $ pip wheel [ options ] -r <requirements file> ... $ pip wheel [ options ] <vcs project url> ... $ pip wheel [ options ] < local project path> ... $ pip wheel [ options ] <archive url/path> ... 参数 -w , --wheel-dir <dir> wheel 格式 Python 包的存放目录，默认为 <cwd>/wheelhouse --no-use-wheel 当在 Python Package Index 上查找包时不优先查找 wheel 格式的 Python 包 --build-option <options> setup.py bdist_wheel 提供的额外参数 -r , --requirement <file> 从 requirements 文件进行安装，该参数可以跟多个 --download-cache <dir> 从网上下载的原始 Python 包的临时存放目录 --no-deps 不安装某个包的依赖包 -b , --build <dir> build 目录，在 virtualenv 环境中默认值为 <venv path>/build , 在正常环境默认值为 <OS temp dir>/pip_build_<username> --global-option <options> bdsit_wheel 命令所用到的一些全局参数 --pre 列出的包中包括预发行或者是开发包，默认只会列出稳定版本的包 --no-clean 不清除 build 目录 -i , --index-url <url> Python Package Index 的 URL 地址 ( 默认为 https://pypi.python.org/simple/ ) --extra-index-url <url> 更多的 Python Package Index 的 URL 地址 --no-index 忽略包索引，只与 --find-links 参数配合使用 -f , --find-links <url> 如果为一个 URL 或者是一个指定 HTML 页面的路径，PIP 会从该地址解析出包地址。 如果是一个本地目录，PIP 就会直接从该目录中查找所需要的包。 --allow-external <package> Allow the installation of externally hosted files --allow-all-external Allow the installation of all externally hosted files --allow-unverified <package> Allow the installation of insecure and unverifiable files --process-dependency-links Enable the processing of dependency links. 常见应用场景 先将需要的所有第三方 Python 包打包到本地目录，然后再从本地目录直接安装之前已经打包好的 wheel 格式的 Python 包。 1 2 $ pip wheel --wheel-dir = /tmp/wheelhouse SomePackage $ pip install --no-index --find-links = /tmp/wheelhouse SomePackage 其它 国内镜像源 豆瓣 PyPI 华中理工大学 PyPI 山东理工大学 PyPI ， 这个貌似用不了。 中国科学技术大学 PyPI 可以用 pip 的 -i 参数来指定镜像源。 1 $ pip install gevent -i http://pypi.douban.com/simple 如果不想每次手动指定，且永久有效的话，可以写入到 pip 的配置文件中。 1 2 [global] index-url = http://pypi.douban.com/simple","tags":"python","loc":"http://chenjiee815.github.io/pipzhi-nan.html","title":"pip指南"},{"text":"Contents 简介 安装 依赖 更新 创建 Pelican 工程目录 使用 Pelican 编写文章 语法高亮 Makefile make html make clean make regenerate make serve make devserver make stopserver 其它 make 子命令 develop_server.sh 简介 Pelican 是一个用 Python 实现的静态网站生成器。 通过 reStructuredText 或 MarkDown 语言，直接使用你的编辑器编写博客 使用简单的命令行工具生成博客 易于与版本控制工具和 WEB 应用配合使用 全静态输出可以方便的在任何地方部署 简单来说，就是你使用 reStructuredText 或者 MarkDown 来生写网站的具体内容，然后用这个工具根据你之前写的内容来生成对应的网页。 这个工具一般用来生成静态的博客是极好的，并且网上也很多技术人的博客也已经是这样来实现的。 本指南只讲解了一些有关 Pelican 的入门知识，如果你想了解更多，请移步 Pelican 中文文档 ，或者 Pelican 官方文档 。 安装 Pelican 的安装还是很简单的，因为它属于 Python 的一个第三方库，所以直接一条命令即可： 1 $ pip install pelican 如果系统报没有 pip 这个命令，你可以点击 pip 的安装文档 。 依赖 到目前为止， Pelican 依赖于以下 Python 包： Pelican 安装之后，依赖于以下的 Python 包都将会自动安装： feedgenerator, 生成 Atom jinja2, 模板支持 pygments, 语法高亮 docutils, 支持 reStructuredText 输入格式 pytz, 定义时区 blinker, 消息分发系统 unidecode, Unicode 文件转码 six, 兼容 Python2、3 MarkupSafe, 安全标记字符串 如果需要以下安装包，可以通过 pip 命令手动安装： markdown, 支持 Markdown 格式输入 typogrify, 增强排版 更新 Pelican 的更新还是一样依赖于 pip 命令： 1 $ pip install -U pelican 创建 Pelican 工程目录 首先创建一个 Pelican 工程目录 myblog （目录名称自定义）： 1 2 3 $ mkdir myblog $ cd myblog $ pelican-quickstart 运行 pelican-quickstart 后会有一堆的提示信息。 Where do you want to create your new web site? 你想在哪里创建你的网站，默认当前目录 What will be the title of this web site? 网站标题是什么？ Who will be the author of this web site? 网站作者？ What will be the default language of this web site? 网站默认语言？默认为 en，我一般写 zh。 Do you want to specify a URL prefix? 是否指定一个 URL 前缀 Do you want to enable article pagination? 文章是否需要分页？ How many articles per page do you want? 每页多少个文章？ 默认 10 个。 Do you want to generate a Fabfile/Makefile to automate generation and publishing? 是否需要生成 Fabfile/Makefile 来对文档的生成和发布进行管理。 建议你选择是。 Do you want an auto-reload & simpleHTTP script to assist with theme and site development? 是否需要一个文档更改后能够自动更新的简单 HTTP 服务器。 建议也选择是。下面会讲到这个服务器，很有用。 下面的问题，都是问你通过哪种方面将你生成的网页上传到你的真实站点。 然后会在 myblog 目录中生成一些目录及文件，其结构 blog/ ├── content # 存放你要写的博客 │ └── (pages) # 单纯的页面 ├── output # 生成的输出文件 ├── develop_server.sh# 方便开启测试服务器 ├── Makefile # 方便管理博客的 Makefile ├── pelicanconf.py # 主配置文件 └── publishconf.py # 主发布文件，可删除 使用 Pelican 编写文章 Pelican 尽可能地会从文件系统中来获取信息（比如，获取文章分类的方式）。 但是你最好在文件的元数据中提供。 下面以 reStructuredText 为例。 1 2 3 4 5 6 7 ============= |PL| 指南 ============= :date: 2014-06-22 10:00 :tags: pelican, python, blog :category: 学习 Tip 除了标题外，其它元素都不是必须的。 如果没有日期， Pelican 是以对应文件的修改时间为日期。 如果没有分类， Pelican 将使用文件所放置的目录名称作为分类。 语法高亮 Pelican 使用 Pyments 来支持语法高亮，所以你可以在你的 reStructuredText 文档里使用如下方法： 1 2 3 .. code-block :: identifier your code 其中 identifier 必须存在与这个列表中 list of available lexers 的字段匹配。 Makefile 你可以直接在之前创建的 Pelican 的工程目录里面执行 make 命令： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ make Makefile for a pelican Web site Usage: make html ( re ) generate the web site make clean remove the generated files make regenerate regenerate files upon modification make publish generate using production settings make serve [ PORT = 8000 ] serve site at http://localhost:8000 make devserver [ PORT = 8000 ] start/restart develop_server.sh make stopserver stop local server make ssh_upload upload the web site via SSH make rsync_upload upload the web site via rsync+ssh make dropbox_upload upload the web site via Dropbox make ftp_upload upload the web site via FTP make s3_upload upload the web site via S3 make cf_upload upload the web site via Cloud Files make github upload the web site via gh-pages Set the DEBUG variable to 1 to enable debugging, e.g. make DEBUG = 1 html Pelican 的作者将所有 Pelican 的用到的功能都封装进去了。你可以不用理会 Pelican 提供的其它命令是如何使用的，直接使用 make 的各种子命令就可以了。 关于各个子命令，我下面穿插着讲到。 同时会也讲到这个子命令封装了 Pelican 提供的哪个原始命令。 make html 这个命令将当前 content 目录中的内容生成对应的网页，不过此命令生成的网页只是简单的 HTML 内容，并没有 CSS 样式之类。 make clean 直接清除整个 output 目录 make regenerate 如果每次检测到变化时，你希望 Pelican 会自动重新生成页面（本地测试都是基于手动生成），可以使用该命令。 它的生成的页面还是和 make html 是一样的，没有什么 CSS 样式。 make serve 启动一个后台服务，来显示生成的网页，不过当 content 目录内容更新时，该服务不会自动更新网页。 make devserver 同样也是启动一个后台服务，不过它会在 content 目录内容更新时，会自动更新网页内容。 make stopserver 停止用上面两个命令启动的后台服务。 其它 make 子命令 其它子命令都是用来上传生成的网页到指定服务器用的。 develop_server.sh 该命令开启一个测试用的服务器。 基本使用方法： 1 $ ./develop_server.sh ( start|stop|restart ) [ port ] 可以看到，它的使用方法也是比较简单的： start 开启一个测试服务器，启动成功后，服务器会在后台运行 stop 停止一个测试服务器 restart 重启测试服务器 port 绑定特定的端口号，默认为 8000 这个测试服务器比较方便的就是它会自动监控 content 目录中的文件，如果有新的文件生成、文件内容发生变化，它会立即生成新的页面（在浏览器里手动刷新即可看到新生成的页面），同时它也会在后台打印出详细的 debug 日志。 make devserver 其实就是对该命令一层简单封装。","tags":"python","loc":"http://chenjiee815.github.io/pelicanru-men-zhi-nan.html","title":"Pelican入门指南"},{"text":"Contents 简介 代码解析 代码吐槽 总结 简介 glob 库提供了以下两个函数： glob 输入 文件路径模式字符串（仅支持 Shell 通配符） 输出 和模式字符串匹配的真实文件名列表 iglob 输入 文件路径模式字符串（仅支持 Shell 通配符） 输出 和模式字符串匹配的真实文件名列表迭代器 代码解析 glob 库中最重要函数就是 iglob 函数了。 glob 函数其实也是调用 iglob 来实现的。 1 2 def glob ( pathname ): return list ( iglob ( pathname )) 那么接下就主讲 iglob 这个函数。 首先我们分析一下传入的文件路径模式字符串有几种情况： 文件路径模式字符串中没有 Shell 通配符 文件路径模式字符串中有 Shell 通配符 这种情况还要再细分： dirname 没有 Shell 通配符，basename 有 Shell 通配符 dirname 有 Shell 通配符，basename 没有 Shell 通配符 dirname 有 Shell 通配符，basename 有 Shell 通配符 经过以上分析，我们为了函数的参数统一，可以将上面的几种情况，归纳如下： dirname 没有 Shell 通配符，basename 有 Shell 通配符 dirname 有 Shell 通配符，basename 没有 Shell 通配符 dirname 有 Shell 通配符，basename 有 Shell 通配符 dirname 没有 Shell 通配符，basename 没有 Shell 通配符 根据以上的分析，我们就可以得出需要以下几个辅助函数： has_magic 判断一个字符串是否有 Shell 通配符 glob0 处理 dirname 没有通配符，basename 也没有通配符的情况 glob1 处理 dirname 没有通配符，basename 有通配符的情况 glob2 处理 dirname 有通配符，basename 没有通配符的情况 glob3 处理 dirname 有通配符，basename 有通配符的情况 但是我们看一下 iglob 函数的源码，它只用到了 has_magic 、 glob0 、 glob1 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def iglob ( pathname ): # 如果整个文件路径模式字符串中没有 Shell 通配符 # 直接判断该路径是否存在即可 if not has_magic ( pathname ): if os . path . lexists ( pathname ): yield pathname return # 如果有的话，就要按上面分析的四种情况考虑了 dirname , basename = os . path . split ( pathname ) # 这里针对目录名没有的情况做了一下特殊处理 if not dirname : for name in glob1 ( os . curdir , basename ): yield name return # 这里为什么要先判断 dirname != pathname？ # 源代码注释中说得很明白。 # pathname 为一个驱动器路径（就是 C 盘，D 盘 ...） # 或者为一个 UNC 路径（自行百度 /Google）。那么 , # os.path.split 函数就会将之当作 dirname 返回。 # 这样会导致下面的代码无限递归，直到 Python 异常。 # `os.path.split()` returns the argument itself as a dirname if it is a # drive or UNC path. Prevent an infinite recursion if a drive or UNC path # contains magic characters (i.e. r'\\\\?\\C:'). if dirname != pathname and has_magic ( dirname ): dirs = iglob ( dirname ) else : dirs = [ dirname ] if has_magic ( basename ): glob_in_dir = glob1 else : glob_in_dir = glob0 # 这里将 dirname 中有通配符的情况， # 转换成没有通配符的情况 # 然后对每个 dirname 使用 glob1/glob0 进行处理 for dirname in dirs : for name in glob_in_dir ( dirname , basename ): yield os . path . join ( dirname , name ) 代码吐槽 还是按照我上面的解析思路来，添加两个辅助函数 glob2 和 glob3 ，这样 iglob 函数的逻辑就比较清楚了，完全按照我上面的解析思路来的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def iglob ( pathname ): dirname , basename = os . path . split ( pathname ) if dirname != pathname and has_magic ( dirname ): glob_func = glob3 if has_magic ( basename ) else glob2 else : glob_func = glob1 if has_magic ( basename ) else glob0 for name in glob_func ( dirname , basename ): yield name def glob1 ( dirname , pattern ): if not dirname : dirname = os . curdir if isinstance ( pattern , _unicode ) and not isinstance ( dirname , unicode ): dirname = unicode ( dirname , sys . getfilesystemencoding () or sys . getdefaultencoding ()) try : names = os . listdir ( dirname ) except os . error : return [] # . 号开头的文件在 unix 平台上为隐藏文件， # 但是在正则表达式中它又可以匹配任意字符， # 所以需要先单独过滤一下 if pattern [ 0 ] != '.' : names = filter ( lambda x : x [ 0 ] != '.' , names ) return fnmatch . filter ( names , pattern ) def glob0 ( dirname , basename ): if basename == '' : # `os.path.split()` returns an empty basename for paths ending with a # directory separator. 'q*x/' should match only directories. if os . path . isdir ( dirname ): return [ basename ] else : if os . path . lexists ( os . path . join ( dirname , basename )): return [ basename ] return [] def glob2 ( dirpattern , basename ): return [ os . path . join ( dirname , name ) for dirname in iglob ( dirpattern ) for name in glob0 ( dirname , basename ) ] def glob3 ( dirpattern , basepattern ): return [ os . path . join ( dirname , name ) for dirname in iglob ( dirpattern ) for name in glob1 ( dirname , basepattern ) ] 总结 即然用到递归了，就要用得干净利落点。","tags":"Python","loc":"http://chenjiee815.github.io/globbiao-zhun-ku-yuan-ma-xue-xi.html","title":"glob标准库源码学习"},{"text":"Contents Flask 扩展导入方式 Flask 的扩展包都列在了 Flask 扩展注册 中。 这些包本质都属于 Python 库， 所以你都可以通过 easy_install 或者 pip 来进行安装。 Flask 扩展导入方式 Flask 扩展的导入方式在 Flask 0.8 版本前后还是有点区别的。 如果你使用的是 Flask 0.8 或者其更新的版本，你可以通过： 1 from flast.ext import ext_name 的方式来导入扩展包。 如果你使用的是比 Flask 0.8 旧的版本， 你只能通过直接导入扩展包的名称来导入了。 但是 Flask 官方还是提供了一个兼容模块用来兼容老版本的 Flask。 你可以从这里下载： flaskext_compat.py 使用方法 : 1 2 3 4 import flaskext_compat flaskext_compat . activate () from flast.ext import ext_name","tags":"python","loc":"http://chenjiee815.github.io/flaskkuo-zhan-ji-zhi-wei-wan-dai-xu.html","title":"Flask扩展机制（未完待续）"},{"text":"Contents HTTP 的连接过程 HTTP 和 HTTPS 网络协议栈区别 HTTP 的连接过程 HTTP 连接本质上就是 TCP 连接和一些使用连接的规则。 HTTP 和 HTTPS 网络协议栈区别 HTTPS 连接其中就是在 HTTP 和 TCP 层之间插入一个 TSL/SSL 层。 HTTP 要传送一条报文时， 会以流的形式将报文数据通过一条打开的 TCP 连接按序传输。 TCP 收到数据流后，会将数据流分成多个小段， 并将该段封装在 IP 分组中。 每个 IP 分组包括： 一个 IP 分组首部（通常为 20 个字节） 一个 TCP 段首部（通常为 20 个字节） 一个 TCP 数据块（0 个或者多个字节）","tags":"http","loc":"http://chenjiee815.github.io/httpquan-wei-zhi-nan-bi-ji-di-si-zhang-lian-jie-guan-li.html","title":"《HTTP权威指南》笔记 第四章 连接管理"},{"text":"Contents 起始行 请求行 响应行 状态码 首部 主体 起始行 所有的 HTTP 报文都以一个起始行作为开始。 请求报文的起始行（请求行）说明： 要做些什么 。 响应报文的起始行（响应行）说明： 发生了什么 。 请求行 包含一个方法和一个请求 URL。 这个方法描述了服务器应该执行的操作， 请求 URL 描述了要对哪个资源执行这个方法。 此外，它还包含了客户端使用 HTTP 版本。 响应行 包含服务器使用 HTTP 版本、数字状态码及其对应的原因短语。 所有这些字段通过空格来进行分隔。 状态码 状态码表示为三位数字。 200~299 之间的状态码表示成功。 300~399 之间的状态码表示资源已经被移走。 400~499 之间的状态码表示客户端请求出错。 500~599 之间的状态码表示服务器响应出错。 首部 本质上是一些 KeyValue 对的列表。 将长的首部行分为多行可以提高可读性， 多出来的每行前面至少要有一个空格或者制表符。 主体 主体是 HTTP 要传输的具体内容。","tags":"http","loc":"http://chenjiee815.github.io/httpquan-wei-zhi-nan-bi-ji-di-san-zhang-httpbao-wen.html","title":"《HTTP权威指南》笔记 第三章 HTTP报文"},{"text":"Contents URL 语法 相对 URL 转义字符 保留字符 URL 语法 大多数 URL 的格式： <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag> 其中最重要的是 scheme, host, path。 相对 URL 有时候网页里面的 URL 不是绝对路径的， 那么就会有相应的算法将之转换成绝对 URL。 转义字符 为了在 URL 中表示各种不安全的字符， 需要在 URL 用转义字符来表示这些不安全的字符。 这种转义表示法包含一个百分号，后面跟着两个表示字符 ASCII 码的 16 进制数。 一些编码字符举例 字符 ASCII 码 示例 URL ~ 126(0x7E) http://www.joes-hardware.com/%7Ejoe 空格 32(0x20) http://www.joes-hardware.com/more%20tools.html 保留字符 在 URL 中，有几个字符被保留起来，有特殊的用途。","tags":"http","loc":"http://chenjiee815.github.io/httpquan-wei-zhi-nan-bi-ji-di-er-zhang-urlyu-zi-yuan.html","title":"《HTTP权威指南》笔记 第二章 URL与资源"},{"text":"这一章主要介绍了 HTTP 协议的一些基本概念， 这样大家会对 HTTP 有一个基本的了解。 Contents Web 客户端和服务器 Web 资源 媒体类型 URI URL URN 事务 方法 状态码 报文 连接 Web 的结构组件 代理 缓存 网关 隧道 Agent 代理 Web 客户端和服务器 Web 资源 资源既可以是静态文件，也可以是根据需求动态生成的。 媒体类型 资源多了，就要分类。HTTP 采用了 MIME 类型。 MIME 类型原来是在邮件里面使用的，由于它很成熟也很好用， 所以 HTTP 也采用了。 Web 服务器会为所有的 HTTP 对象数据附加一个 MIME 类型。 当浏览器从服务器中取回一个对象时，会去查看相关的 MIME 类型， 这样它就知道如何处理这个对象了。 常用 MIME 类型举例： HTML 格式的文本文档：text/tml 普通的 ASCII 文本文档：text/plain JPEG 格式的图片：image/jpeg URI Uniform Resource Idenifier: 统一资源标识符 URI 有两种形式：URL 和 URN。 URL 统一资源定位符，它描述了一台特定服务器上某资源的特定位置。 大部分 URL 都遵循一种标准格式： 第一部分：方案 (scheme)，说明了使用的协议类型。 第二部分：服务器地址。 其余部分：服务器上的某个资源。 URN 统一资源名，作为特定内容的唯一名称使用，与资源的所在地无关。 现实中用的很少，还处于试验阶段。 事务 一个 HTTP 事务由一条（客户端发给服务器）的请求消息和 一个（从服务器发回客户端）的响应消息组成。 这种通信是通过名为 HTTP 报文（HTTP message）的格式化数据块进行的。 方法 每条 HTTP 请求报文都包含一个方法，这些叫做 HTTP 方法（HTTP method）。 这些方法会告诉服务器要执行什么动作。 常见的 HTTP 方法 方法名 说明 GET 获取资源 PUT 更新资源 DELETE 删除资源 POST 添加资源 HEAD 获取 HTTP 响应首部 状态码 每条 HTTP 响应报文返回时都会携带一个状态码。 状态码是一个三位数字，用来告知客户端请求是否成功， 或者是否需要采取其它动作。 HTTP 的响应报文中除了会返回状态码之外，还会同时返回对应的原因短语。 常见 HTTP 状态码： 200 OK：文档正常返回 302 Redirect：重定向，到其它地方获取资源 404 Not Found：没找到，无法找到该资源 报文 HTTP 报文是由一行行的简单字符串组成的。HTTP 报文都是纯文本，非二进制代码。 HTTP 报文分为： 请求报文（request message） 响应报文（response message） HTTP 报文包括以下三个部分： 起始行 报文的第一行就是起始行， 在请求报文里说明要做些什么， 在响应报文中说明出现了什么情况。 首部字段 起始行后面有零个或多个首部字段。 每个字段都包含一个名字和一个值。两者用：号分割。 首部以一个空行结束。 主体 空行之后就是可选的报文主体了。其中包含了所有类型的数据。 请求报文主体中包含了要发给服务器的数据；响应报文主体中包含了 要返回客户端的数据。主体中可以包含任意的二进制数据。 连接 HTTP 是个应用层协议，它将联网的具体细节交给了 TCP/IP 协议。 所以在 HTTP 客户端向服务器发送报文之前，需要用 IP 地址及端口号在 客户端与服务器之间建立一条 TCP/IP 连接。 之前有讲过，客户端是通过 URL 来请求资源的。 所以 IP 地址及端口也是从 URL 中获取到的。 下面简单介绍一下浏览器的连接步骤： 浏览器从 URL 中解析出服务器的主机名 / 域名 浏览器将主机名 / 域名通过 DNS 服务转换成服务器的 IP 地址 浏览器将端口号从 URL 中解析出来（没有则用默认的端口号） 浏览器建立一条与服务器的 TCP 连接 浏览器向服务器发送一条 HTTP 请求报文 服务器向浏览器回送一条 HTTP 响应报文 浏览器关闭连接，渲染并显示文档 Web 的结构组件 代理 位于客户端和服务器之间。 一般的应用场景是，客户端无法访问某些服务器，但是可以连接到某台设备， 而这台设备可以访问这些服务器，那么就可以在这个设备上开启一个代理服务器， 客户端通过走这台设备的代理就可以访问那些它之前无法访问的服务器了。 缓存 它是一种特殊的代理服务器，可以将经过代理传送的常用文档保存下来， 当有其它客户端或者该客户端再次请求相同文档时， 就可以直接将缓存的文档返回了。 网关 也是一种特殊的代理服务器中，通常是将 HTTP 请求转换成其它协议的请求。 隧道 对 HTTP 通信报文进行盲转发的特殊代理。 在一条或者多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。 常用的就是 HTTPS，通过 HTTP 连接承载加密安全套接字层（SSL）。 Agent 代理 是指代表客户发起 HTTP 请求的客户端程序。 最有代表性的就是：浏览器。","tags":"http","loc":"http://chenjiee815.github.io/httpquan-wei-zhi-nan-bi-ji-di-yi-zhang-httpgai-shu.html","title":"《HTTP权威指南》笔记 第一章 HTTP概述"},{"text":"背景 应该是前三周的 DNA 会议，我做了第一次 P3 的演讲。 很遗憾，那次的演讲由于超时没有通过。 这事虽然对我打击不是很大，但是却让我反思了一下自己的演讲水平。 有多烂？事实在这里 我发现自己从 P1 到 P3 的整个演讲历程走得磕磕跘跘： P1 做了三次，其中有一次说到一半忘词说不下去了。 P2 做了两次，第一次超时了，第二次也是勉强过了。 P3 正如大家所见，我正在做第二次的 P3 演讲。 为什么会这么烂？原因何在？ 认为演讲水平不好，只是上台的经历比较少，经历多了，自然会讲得比较好。 认为演讲时紧张，还是上台的经历比较少，经历多了，脸皮就厚了。 没有做好提前准备，既然是备稿演讲，你的稿子在哪？每次只是打个提纲。 每次演讲完成，没有回顾自己在演讲时被拍摄的视频，找出缺点并改正。 在演讲时，一遇到需要表演的地方，就觉得很假，就会把一个很有感觉的事说得平淡无奇。 如何解决这些问题？ 难道自己就没有优点？ 结尾","tags":"dna","loc":"http://chenjiee815.github.io/wo-de-yan-jiang-shui-ping-wei-shi-yao-zhe-yao-lan.html","title":"我的演讲水平为什么这么烂？"},{"text":"Contents 引言 瓶颈期的状态 我是怎样察觉到自己处在瓶颈期的？ 我在瓶颈期的状态如何？ 如何渡过瓶颈期 什么是我的瓶颈？ 如何解决这些瓶颈？ 掌握计算的本质 掌握目前主要的硬通货 我目前的状态 我在哪些方面提高了？ 为了纪念刚刚出离的瓶颈期，我写了这篇博文。 同时也总结这一下这段时间的心态与所得。 引言 我目前的职业规划还是做 技术 为主。 做为一个 程序员 ，我觉得 技术 才是我们的立身之本。只有在技术上掌握到较高的层次，你才好围绕着技术拓展自己的其它能力。 当你的技术还没达到较高的层次之前，就相当于在打基础。那这个打基础的过程在我的理解里有点像上台阶。 当你走一段比较长的平台，遇到了一个台阶，就是遇到了你的瓶颈。你跨上去了，你就成长了一点，你又会走过一段比较长的平台。但是随后的台阶会越来越高，有人经历了几个台阶后只能原地踏步、有人只经历一两个台阶就另换职业，有人可能会越战越勇，不断得突破自己。 那我比较幸运，在我的 IT 职业生涯第二年就遇到了的第一个瓶颈期。 瓶颈期的状态 我是怎样察觉到自己处在瓶颈期的？ 说到怎样察觉，我体会到的是： 不是突然遇到一件事就让我察觉到了自己处在瓶颈期。 而是在比较长的一段时间内，遇到很多的事情让你有以下几种感觉： 工作没有目标，没有动力，看不到未来 感觉自己活得好累，事业上平平淡淡，生活上没房没车 感觉自己在技术方面很难进步，反而有些退步 感觉自己不明白的东西太多，而自己基础又太薄弱 ... ... 总之一句话： 感觉自己就是一个 loser 干啥啥不行，吃啥啥不剩。 我在瓶颈期的状态如何？ 我是从医药行业跨到 IT 行业的。 我为什么要来到 IT 行业？ 因为我热爱编程，觉得编程是件很神奇的事。 以编程作为自己的职业，是我的梦想。 当初我是怀着一腔热血进入 IT 行业的，冲劲十足，进步神速。只要是和计算机、编程相关的事，我都觉得很有意义，是个学习的机会。 但是经过差不多两年的时间，我发现自己很难进步了。 我目前的工作是以 Python 为主，所以就看了大量的目前市面流行的 Python 书籍。但是我发现那些书没啥好看的，基础的我都懂，高深的又比较理论化，感觉投影不到现实编程当中。 工作的内容也慢慢 Hold 不住了，以前只用写些小型的界面程序、辅助程序等等。现在面对着复杂的业务逻辑，复杂的业务处理流程，我不知道该怎么这才能比较好的实现了。 自己平时都有关注一些新技术、新的 Python 库，新的语言。然后就会花点时间学点皮毛，但总是无法深入。 不断接触和涌出的各种技术，让我感觉无所适从，难不成有一个我就学一个？学到死？ 谈了恋爱，钱、房子、车子等等这些以前想都不想事情，在女朋友有意无意的提示之下，也觉得这些事成了当务之急。而现在自己，却一无所有。 看了大量道家的书、佛家的书以及这些圈子的人写的各类文章，让我整个人的理想和实现有了很大的矛盾。 总而言之： 整个人生没有了方向，不知道该怎么走，也没有什么动力走下去。 如何渡过瓶颈期 当我意识到自己处在一个瓶颈期时，第一个念头就是怎么出离这个令人迷茫而又不舒服状态。 我就思考我要怎么做。 什么是我的瓶颈？ 我是一个非科班出身的程序员，基础的知识薄弱。 我是一个动态语言为专业的程序员，底层知识薄弱。 我只做过一些小型程序、软件，中型以及大型系统的设计及编程能力薄弱。 我大部分时间只是在熟悉业务，而对承载业务的各类协议、数据库、操作系统等目前硬通货了解不深入。 如何解决这些瓶颈？ 想要有优质的生活，你需要有好的事业。 想要有好的事业，你需要有市场需求的鹤立鸡群的职业技能。 想要有过硬的职业技能，你需要能人所不能。 想要能人所不能，你需要了解技术的本质，一通百通。 在参考了网上一些前辈写的文章，我确定了我以后的两条主线： 先掌握计算的本质、再掌握计算机的本质 掌握目前主要的硬通货 掌握计算的本质 看完《The Little Schemer》、《How to Design Programs》、《structure and interpretation of computer programs》... ... 掌握 Scheme、Haskell、prolog。 以实现一门自己的高级语言解释器为一个里程碑。 后面的路暂时还未想到。 掌握目前主要的硬通货 掌握 HTTP 协议 一个 Web 框架的整个实现原理 以编写出一个自己的 Web 框架为里程碑 掌握 Python 实现 以实现一个简化版本的 tiny python 为里程碑 Linux 内核实现 以编写一个自己的小型操作系统里程碑 我目前的状态 我最近一段时间的心理相对于以前来说，平稳了许多。而且很明显得感觉到自己已经开始慢慢摆脱瓶颈期了。 怎么感觉到的？ 很简单。我现在有了方向，有了动力，并且努力朝着这个方向前进。 我在哪些方面提高了？ 递归 之前的理解 印象中的递归更多的是教科书内的汉诺塔之类的例子。 递归效率不高，递归层次深了更可能会栈溢出。 现在的理解 在看了《The Little Schemer》后，对递归有了更进一步的了解。具体的看 glob 标准库的学习 。 怎样读其他人的代码 之前的理解 刚开始学一门语言时，语法不是很熟悉，看别人代码 关注更多的是 作者写的是什么 看完别人的代码，感觉自己懂了，但是当你脱离作者的代码想自己实现时，还要时不时地看一下原作者的代码 现在的理解 但是当你熟悉一门语言后，你应该转换你的观点了， 应该更多的关注是 作者是怎么想的 你了解到了作者在写代码时的整个大脑活动，那作者的代码就内化成你自己的代码，同时，由于你本身处于局外人的身份，你还会发现作者的思路缺陷，能够写出更漂亮的代码 程序设计基本思想 之前的理解 单一职责、自顶向下、模块化、接口先行、自底向上 ... ... 只知道这些名词是啥意思，但是在代码设计及实现却没有有意识的按照这些思想去做。 现在的理解 自顶向下体现的是一种全局观，根据需求划分出多个功能模块、然后每个功能模块需要提供哪些接口 然后再自底向上挨个实现每个功能模块，当然在每个功能模块内部也同样可以复用以上逻辑 设计模式 之前的理解 以前有过一段做 GUI 程序的经历，在做 GUI 时，我觉得 GUI 这个领域算是面向对象的最佳实践之一。当时也是首次有意识地将设计模式应用到代码中。当然，一开始必然是生搬硬套。对着书，觉得这个设计模式有意思，好，看看程序里哪边可以使用上。 后来，又接触到了函数式编程的概念。网上很多文章将函数式编程和面向对象编程放在了对立面，然后将函数式编程捧得很高，将面向对象编程批得很挫。我也受到这种思想的荼毒，走得比较极端，开始厌恶使用面向对象编程，甚至拒绝使用 Python 中的 class 关键字定义类。 现在的理解 设计模式最重要的是什么？ 设计模式最重要的是它的 SOLID 原则。 单一职责原则：The Single Presponsibility Principle 开放封闭原则：The Open Closed Principle 里氏替换原则：The Liskov Substitution Principle 接口分离原则：The Interface Segregation Principle 依赖倒置原则：The Dependency Inversion Principle 那些所谓的设计模式只是在一定的应该场景中这些原则的全部或者部分的映射。 class 定义一个类是提供了一种封装的手段，那么闭包也是。它们都是为了实现封装而提供的工具而已。","tags":"职业生涯","loc":"http://chenjiee815.github.io/zhi-ye-sheng-ya-ping-jing-qi-zhi-wo-de-jing-li.html","title":"职业生涯瓶颈期之我的经历"}]}