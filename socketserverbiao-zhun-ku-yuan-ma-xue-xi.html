<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Chen Jie" />
        <meta name="copyright" content="Chen Jie" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="python, stdlibs, Python, " />

<meta property="og:title" content="SocketServer标准库源码学习 "/>
<meta property="og:url" content="http://chenjiee815.github.io/socketserverbiao-zhun-ku-yuan-ma-xue-xi.html" />
<meta property="og:description" content="Contents 简介 Server: 实现一个服务 MixIn: 让你的服务支持多线程 / 多进程 RequestHandler: 如何实现请求处理 未解决问题 _eintr_retry 慢系统调用 (slow system call) EINTR 错误的产生 Server BaseServer TCPServer allow_reuse_address socket 的 close&amp;&amp;shutdown close shutdown 总结 UDPServer get_request class UDPServer(TCPServer) MixIn ForkingMixIn os.waitpid(0, 0) os._exit ThreadingMixIn 其它 RequestHandler BaseRequestHandler StreamRequestHandler rbufsize&amp;&amp;wbufsize Nagle 算法 ..." />
<meta property="og:site_name" content="January Star" />
<meta property="og:article:author" content="Chen Jie" />
<meta property="og:article:published_time" content="2014-10-28T11:48:00.039635" />
<meta name="twitter:title" content="SocketServer标准库源码学习 ">
<meta name="twitter:description" content="Contents 简介 Server: 实现一个服务 MixIn: 让你的服务支持多线程 / 多进程 RequestHandler: 如何实现请求处理 未解决问题 _eintr_retry 慢系统调用 (slow system call) EINTR 错误的产生 Server BaseServer TCPServer allow_reuse_address socket 的 close&amp;&amp;shutdown close shutdown 总结 UDPServer get_request class UDPServer(TCPServer) MixIn ForkingMixIn os.waitpid(0, 0) os._exit ThreadingMixIn 其它 RequestHandler BaseRequestHandler StreamRequestHandler rbufsize&amp;&amp;wbufsize Nagle 算法 ...">

        <title>SocketServer标准库源码学习  · January Star
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="http://chenjiee815.github.io/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://chenjiee815.github.io/theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://chenjiee815.github.io/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://chenjiee815.github.io/theme/css/custom.css" media="screen">
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-52167018-1', 'auto');
    ga('send', 'pageview');
</script>
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <div class="span1"></div>
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="http://chenjiee815.github.io/"><span class=site-name>January Star</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="http://chenjiee815.github.io">Home</a></li>
                            <li ><a href="http://chenjiee815.github.io/categories.html">Categories</a></li>
                            <li ><a href="http://chenjiee815.github.io/tags.html">Tags</a></li>
                            <li ><a href="http://chenjiee815.github.io/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="http://chenjiee815.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="http://chenjiee815.github.io/socketserverbiao-zhun-ku-yuan-ma-xue-xi.html"> SocketServer标准库源码学习  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            
            <div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id10"> 简介 </a><ul>
<li><a class="reference internal" href="#server" id="id11">Server: 实现一个服务 </a></li>
<li><a class="reference internal" href="#mixin" id="id12">MixIn: 让你的服务支持多线程 / 多进程 </a></li>
<li><a class="reference internal" href="#requesthandler" id="id13">RequestHandler: 如何实现请求处理 </a></li>
<li><a class="reference internal" href="#id2" id="id14"> 未解决问题 </a></li>
</ul>
</li>
<li><a class="reference internal" href="#eintr-retry" id="id15">_eintr_retry</a><ul>
<li><a class="reference internal" href="#slow-system-call" id="id16"> 慢系统调用 (slow system call)</a></li>
<li><a class="reference internal" href="#eintr" id="id17">EINTR 错误的产生 </a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3" id="id18">Server</a><ul>
<li><a class="reference internal" href="#baseserver" id="id19">BaseServer</a></li>
<li><a class="reference internal" href="#tcpserver" id="id20">TCPServer</a><ul>
<li><a class="reference internal" href="#allow-reuse-address" id="id21">allow_reuse_address</a></li>
<li><a class="reference internal" href="#socketclose-shutdown" id="id22">socket 的 close&amp;&amp;shutdown</a><ul>
<li><a class="reference internal" href="#close" id="id23">close</a></li>
<li><a class="reference internal" href="#shutdown" id="id24">shutdown</a></li>
<li><a class="reference internal" href="#id4" id="id25"> 总结 </a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#udpserver" id="id26">UDPServer</a><ul>
<li><a class="reference internal" href="#get-request" id="id27">get_request</a></li>
<li><a class="reference internal" href="#class-udpserver-tcpserver" id="id28">class UDPServer(TCPServer)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id5" id="id29">MixIn</a><ul>
<li><a class="reference internal" href="#forkingmixin" id="id30">ForkingMixIn</a><ul>
<li><a class="reference internal" href="#os-waitpid-0-0" id="id31">os.waitpid(0, 0)</a></li>
<li><a class="reference internal" href="#os-exit" id="id32">os._exit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#threadingmixin" id="id33">ThreadingMixIn</a></li>
<li><a class="reference internal" href="#id6" id="id34"> 其它 </a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7" id="id35">RequestHandler</a><ul>
<li><a class="reference internal" href="#baserequesthandler" id="id36">BaseRequestHandler</a></li>
<li><a class="reference internal" href="#streamrequesthandler" id="id37">StreamRequestHandler</a><ul>
<li><a class="reference internal" href="#rbufsize-wbufsize" id="id38">rbufsize&amp;&amp;wbufsize</a></li>
<li><a class="reference internal" href="#nagle" id="id39">Nagle 算法 </a></li>
<li><a class="reference internal" href="#econnaborted" id="id40">ECONNABORTED</a></li>
</ul>
</li>
<li><a class="reference internal" href="#datagramrequesthandler" id="id41">DatagramRequestHandler</a><ul>
<li><a class="reference internal" href="#self-packet-self-socket-self-request" id="id42">self.packet, self.socket = self.request</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id10"> 简介 </a></h2>
<p> 本模块的代码基本分为以下三大块功能。</p>
<div class="section" id="server">
<h3><a class="toc-backref" href="#id11">Server: 实现一个服务 </a></h3>
<p>Server 本身只负责搭建整个服务的框架。</p>
<p> 至于服务本身如何处理客户端上来的请求，是通过 Server 绑定的 RequestHandler 来进行处理的。</p>
<p> 本模块 Server 类的继承关系 </p>
<pre class="literal-block">
+------------+
| BaseServer |
+------------+
      |
      v
+-----------+        +------------------+
| TCPServer |-------&gt;| UnixStreamServer |
+-----------+        +------------------+
      |
      v
+-----------+        +--------------------+
| UDPServer |-------&gt;| UnixDatagramServer |
+-----------+        +--------------------+
</pre>
</div>
<div class="section" id="mixin">
<h3><a class="toc-backref" href="#id12">MixIn: 让你的服务支持多线程 / 多进程 </a></h3>
<p> 该模块的代码还用到了 Python 的高级编程技巧 Mixin。</p>
<p> 如果你想让你的服务支持多线程 / 多进程，你可以使用如下代码：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ThreadingTCPServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">TCPServer</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ThreadingUDPServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UDPServer</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</td></tr></table><p> 当然你真正使用时不需要写这些代码，它们已经在该模块内已经实现了。</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p><cite>ThreadingMixIn</cite> 会覆盖 <cite>TCPServer</cite> 、 <cite>UDPServer</cite> 某些特定的方法，以提供额外的多线程功能。</p>
<p class="last"> 所以 <cite>ThreadingMixIn</cite> 必须要放在前面，这是由 Python 对于属性 / 方法的查找算法决定。</p>
</div>
</div>
<div class="section" id="requesthandler">
<h3><a class="toc-backref" href="#id13">RequestHandler: 如何实现请求处理 </a></h3>
<p> 本模块提供的 RequestHandler 基本有两种用法 。</p>
<ol class="arabic simple">
<li> 继承 <cite>BaseRequestHandler</cite> 类，重载它的 <cite>handle()</cite> 方法，</li>
<li> 直接使用本模块封装好的 <cite>StreamRequestHandler</cite> 和  <cite>DatagramRequestHandler</cite>, 并重载它的 <cite>handle()</cite> 方法。</li>
</ol>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id14"> 未解决问题 </a></h3>
<p> 目前无法处理带外 (out-of-band) 数据 </p>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last"> 我对此不是很了解，谁感兴趣可以自行 <a class="reference external" href="http://baike.baidu.com/link?url=5SG8mhk8xgFVPOEiUsvErYzu2G7sZ7X6NwvCJJ_0AQ3kocFyGcJS7cRIiFVaT4V_"> 百度百科：带外数据 </a></p>
</div>
</div>
</div>
<div class="section" id="eintr-retry">
<h2><a class="toc-backref" href="#id15">_eintr_retry</a></h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_eintr_retry</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; 忽略除 EINTR 错误外所有其它错误 &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="n">select</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">:</span>
                <span class="k">raise</span>
</pre></div>
</td></tr></table><p> 下面是搜索到的有关 <cite>EINTR</cite> 错误的一些说明。</p>
<div class="section" id="slow-system-call">
<h3><a class="toc-backref" href="#id16"> 慢系统调用 (slow system call)</a></h3>
<p> 此术语适用于那些可能永远阻塞的系统调用。</p>
<p> 永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类。如：若没有客户连接到服务器上，那么服务器的 accept 调用就没有返回的保证。</p>
</div>
<div class="section" id="eintr">
<h3><a class="toc-backref" href="#id17">EINTR 错误的产生 </a></h3>
<p> 当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个 EINTR 错误。</p>
<p> 例如：在 socket 服务器端，设置了信号捕获机制，有子进程，当在父进程阻塞于慢系统调用时由父进程捕获到了一个有效信号时，内核会致使 accept 返回一个 EINTR 错误 ( 被中断的系统调用 )。</p>
<p> 当碰到 EINTR 错误的时候，可以采取有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。</p>
<p> 例如：accept、read、write、select、和 open 之类的函数来说，是可以进行重启的。</p>
<p> 不过对于套接字编程中的 connect 函数我们是不能重启的，若 connect 函数返回一个 EINTR 错误的时候，我们不能再次调用它，否则将立即返回一个错误。</p>
<p> 针对 connect 不能重启的处理方法是，必须调用 select 来等待连接完成。</p>
</div>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id18">Server</a></h2>
<div class="section" id="baseserver">
<h3><a class="toc-backref" href="#id19">BaseServer</a></h3>
<p> 对调用者提供的方法：</p>
<ul class="simple">
<li>__init__(server_address, RequestHandlerClass)</li>
<li>serve_forever(poll_interval=0.5)</li>
<li>shutdown()</li>
<li>handle_request()  # if you do not use serve_forever()</li>
<li>fileno() -&gt; int   # for select()</li>
</ul>
<p> 对 MinIn 或者子类提供的可重载的方法：</p>
<ul class="simple">
<li>server_bind()</li>
<li>server_activate()</li>
<li>get_request() -&gt; request, client_address</li>
<li>handle_timeout()</li>
<li>verify_request(request, client_address)</li>
<li>server_close()</li>
<li>process_request(request, client_address)</li>
<li>shutdown_request(request)</li>
<li>close_request(request)</li>
<li>handle_error()</li>
</ul>
<p> 提供给子类的方法：</p>
<ul class="simple">
<li>finish_request(request, client_address)</li>
</ul>
<p> 提供给子类或者实例，可用于重载的属性：</p>
<ul class="simple">
<li>timeout</li>
<li>address_family</li>
<li>socket_type</li>
<li>allow_reuse_address</li>
</ul>
<p> 实例属性：</p>
<ul class="simple">
<li>RequestHandlerClass</li>
<li>socket</li>
</ul>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BaseServer</span><span class="p">:</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">,</span> <span class="n">RequestHandlerClass</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_address</span> <span class="o">=</span> <span class="n">server_address</span> <span class="c"># 服务绑定的地址 </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RequestHandlerClass</span> <span class="o">=</span> <span class="n">RequestHandlerClass</span> <span class="c"># 处理请求的类 </span>
        <span class="c"># 下面这两个属性主要用来给 self.shutdown 方法使用 </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_shut_down</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span> <span class="c"># 服务结束通知 </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># 服务已关闭的标志位 </span>

    <span class="k">def</span> <span class="nf">server_activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 通过 `__init__` 调用，可被重载。</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_interval</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 一直进行监听及处理请求操作，直到服务被关闭 </span>
<span class="sd">        self.timeout 对本方法不起作用，如果想使用 self.timeout，可以使用 handle_request</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_shut_down</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span><span class="p">:</span>
                <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">_eintr_retry</span><span class="p">(</span><span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span>
                                       <span class="n">poll_interval</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_handle_request_noblock</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__is_shut_down</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 停止服务，该方法必须与 `serve_forever` 在不同的线程中调用，不然会造成死锁 </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_shut_down</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 处理请求，如果你不是使用 serve_forever 来启动服务的话，</span>
        <span class="c"># 可以通过 handle_request 来定制自己处理服务的方式 </span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">gettimeout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
        <span class="n">fd_sets</span> <span class="o">=</span> <span class="n">_eintr_retry</span><span class="p">(</span><span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fd_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle_timeout</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle_request_noblock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handle_request_noblock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 在调用本方法之前，已经确认有客户端连接上来，</span>
        <span class="c"># 所以调用 self.get_request 方法时不会阻塞 </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_request</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">handle_error</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 超时之后，还没有新的请求则会调用该方法。</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">verify_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="c"># 对请求进行校验，如果校验成功，必须返回 True</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="c"># 处理请求 </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">server_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 用于服务停止后的后处理 </span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">finish_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RequestHandlerClass</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shutdown_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">handle_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="c"># 优雅地处理 error，可被重载。</span>
        <span class="c"># 默认的行为是打印出出错的异常信息，然后继续处理请求。</span>
        <span class="c"># 注意：print 输出的信息会输出到 stdout, 异常信息会输出到 stderr，蛋疼 </span>
        <span class="k">print</span> <span class="s">&#39;-&#39;</span><span class="o">*</span><span class="mi">40</span>
        <span class="k">print</span> <span class="s">&#39;Exception happened during processing of request from&#39;</span><span class="p">,</span>
        <span class="k">print</span> <span class="n">client_address</span>
        <span class="kn">import</span> <span class="nn">traceback</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span> <span class="c"># 此处的信息会输出到 stderr</span>
        <span class="k">print</span> <span class="s">&#39;-&#39;</span><span class="o">*</span><span class="mi">40</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="tcpserver">
<h3><a class="toc-backref" href="#id20">TCPServer</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">BaseServer</span><span class="p">):</span>

    <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span> <span class="c"># TCP 对应的 socket 簇 </span>

    <span class="n">socket_type</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span> <span class="c"># TCP 对应的 socket 类型 </span>

    <span class="n">request_queue_size</span> <span class="o">=</span> <span class="mi">5</span> <span class="c"># 等待连接队列的最大长度，术语 `backlog`</span>

    <span class="n">allow_reuse_address</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">,</span> <span class="n">RequestHandlerClass</span><span class="p">,</span> <span class="n">bind_and_activate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">BaseServer</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">,</span> <span class="n">RequestHandlerClass</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">address_family</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bind_and_activate</span><span class="p">:</span> <span class="c"># 是否在服务实例化是时就激活地址绑定及监听操作 </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">server_bind</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">server_activate</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">server_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 服务端 socket 地址绑定 &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_reuse_address</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">server_address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">server_activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 服务端启用监听操作 &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_queue_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">server_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 返回 socket 文件句柄数 </span>

<span class="sd">        给 `serve_forever` 中的 `select.select` 操作用 </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 获取一个有请求需要处理的 socket&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">shutdown_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">request</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_WR</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="c"># 某些平台会抛出 `ENOTCONN` 异常 </span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="n">request</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</td></tr></table><div class="section" id="allow-reuse-address">
<h4><a class="toc-backref" href="#id21">allow_reuse_address</a></h4>
<p> 指示套接字是否应该重用地址。</p>
<p> 在程序终止之后 , 如果需要在同一个端口立即重启服务器 , 那么该设置会很有用（其他情况下 , 你必须等待几分钟）。</p>
</div>
<div class="section" id="socketclose-shutdown">
<h4><a class="toc-backref" href="#id22">socket 的 close&amp;&amp;shutdown</a></h4>
<div class="section" id="close">
<h5><a class="toc-backref" href="#id23">close</a></h5>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include&lt;unistd.h&gt;</span>

<span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
</pre></div>
</td></tr></table><p> 关闭本进程的 socketfd，但链接还是开着的，用这个 socketfd 的其它进程还能用这个链接，能读或写这个 socketfd。</p>
</div>
<div class="section" id="shutdown">
<h5><a class="toc-backref" href="#id24">shutdown</a></h5>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;sys/socket.h&gt;</span>

<span class="kt">int</span> <span class="nf">shutdown</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">how</span><span class="p">);</span>
</pre></div>
</td></tr></table><p>how 的方式有三种分别是 </p>
<blockquote>
<p>SHUT_RD（0）：关闭 sockfd 上的读功能，此选项将不允许 sockfd 进行读操作。</p>
<p>SHUT_WR（1）：关闭 sockfd 的写功能，此选项将不允许 sockfd 进行写操作。</p>
<p>SHUT_RDWR（2）：关闭 sockfd 的读写功能。</p>
</blockquote>
<p> 则破坏了 socket 连接，读的时候可能侦探到 EOF 结束符，写的时候可能会收到一个 SIGPIPE 信号，这个信号可能直到 socket buffer 被填充了才收到。</p>
</div>
<div class="section" id="id4">
<h5><a class="toc-backref" href="#id25"> 总结 </a></h5>
<p>shutdown 算是比较优雅（更细粒度）地关闭 socket 连接，但是不释放本地资源（socketfd）。</p>
<p>close 则比较简单粗暴一点，直接释放 socketfd。但它也不是立即释放 socketfd，socketfd 有一个引用计数的问题，当一个 socketfd 的引用计数为 0 时，系统才会进行释放。</p>
</div>
</div>
</div>
<div class="section" id="udpserver">
<h3><a class="toc-backref" href="#id26">UDPServer</a></h3>
<p>UDP 是面向无连接的 socket。</p>
<p> 既然是无连接的，那就没有监控的操作，以及关闭连接的操作。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UDPServer</span><span class="p">(</span><span class="n">TCPServer</span><span class="p">):</span>

    <span class="n">allow_reuse_address</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">socket_type</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span> <span class="c"># UDP 对应的 socket 类型 </span>

    <span class="n">max_packet_size</span> <span class="o">=</span> <span class="mi">8192</span> <span class="c"># 每次接收数据的最大长度 </span>

    <span class="k">def</span> <span class="nf">get_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_packet_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="p">),</span> <span class="n">client_addr</span>

    <span class="k">def</span> <span class="nf">server_activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">shutdown_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</td></tr></table><div class="section" id="get-request">
<h4><a class="toc-backref" href="#id27">get_request</a></h4>
<p> 该方法的返回值和 <cite>TCPServer</cite> 不一样。</p>
<p> 它是在 <cite>Server</cite> 框架里面就获取到了数据，而不是在 <cite>RequestHandler</cite> 中来进行数据的获取。</p>
<p> 具体原因下面的 <cite>DatagramRequestHandler</cite> 章节会有提到。</p>
</div>
<div class="section" id="class-udpserver-tcpserver">
<h4><a class="toc-backref" href="#id28">class UDPServer(TCPServer)</a></h4>
<p> 这种继承方式有点不合理，感觉是纯粹为了代码复用而进行的继承。</p>
<p> 最好让 <cite>TCPServer</cite> 和 <cite>UDPServer</cite> 共同继承自同一个模板基类。</p>
<p> 它们的相同代码全在模板类中，不同代码在各自的类中。</p>
</div>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id29">MixIn</a></h2>
<div class="section" id="forkingmixin">
<h3><a class="toc-backref" href="#id30">ForkingMixIn</a></h3>
<p> 使用多进程来处理请求，一个进程对应一个请求。</p>
<p> 由于一个进程占用的系统资源比较多，且操作系统都会限制进程数，所以不能无限制的开启进程，代码中对应进程数进行了限制，不过这样也限制了在多进程模式下，并发处理请求的能力。</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"> 该功能只支持 Unix 平台，在 Windows 上不可用，具体原因看下面的注释。</p>
</div>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ForkingMixIn</span><span class="p">:</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">300</span>
    <span class="n">active_children</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># 当前正在处理请求的子进程 PID 集合 </span>
    <span class="n">max_children</span> <span class="o">=</span> <span class="mi">40</span> <span class="c"># 支持的最大并发请求数 </span>

    <span class="k">def</span> <span class="nf">collect_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 回收子进程 &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="c"># 如果子进程数超过上限，则一直等待，直到子进程数低于上限 </span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_children</span><span class="p">:</span>
            <span class="c"># 阻塞模式：等待当前进程组的任何子进程的返回值，</span>
            <span class="c"># 注意：不仅仅是通过 ForkingMixIn 生成的子进程。</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pid</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">os</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="n">pid</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="c"># 如果不是 ForkingMixIn 生成的子进程，则忽略掉 </span>
            <span class="k">if</span> <span class="n">pid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="p">:</span> <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>

        <span class="c"># 下面代码主要是检查是否有已经退出的子进程，如果有则将之对应的保存的 pid 删除掉 </span>
        <span class="c"># 作者在这里说，下面的代码中进行了太多次的系统调用，</span>
        <span class="c"># 原本可以通过将所有子进程设置成一个进程组，</span>
        <span class="c"># 然后只需要使用 os.waitpid(pgid) 获取该进程组内任意结束的子进程 ID，</span>
        <span class="c"># 但是他没有办法获取到一个不冲突的进程组 ID。</span>

        <span class="c"># PS: 虽说对一个列表迭代时同时删除列表中的元素不是不可以，</span>
        <span class="c"># 但是这样做太容易出错，一定要小心处理。</span>
        <span class="c"># 对一个字典边迭代边删除就会抛异常了，具体原因涉及到 Python 字典的实现原理，细节暂不表了。</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># 如果没有任何子进程退出则立即返回 (0, 0)</span>
                <span class="c"># 有，则返回该子进程的 pid，及返回值 </span>
                <span class="c"># 相当于非阻塞模式 </span>
                <span class="n">pid</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">WNOHANG</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">os</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="n">pid</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pid</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">. x=</span><span class="si">%d</span><span class="s"> and list=</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">handle_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collect_children</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collect_children</span><span class="p">()</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span> <span class="c"># fork 只在 Unix 平台上有效 </span>
        <span class="k">if</span> <span class="n">pid</span><span class="p">:</span> <span class="c"># 父进程 </span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="c"># 父进程只负责生成子进程来处理请求，本身不会处理请求 </span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># 子进程 </span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finish_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">handle_error</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c"># Python2.5 版本之前不支持 except/finally 同时使用 </span>
            <span class="c"># 所以才有这种比较蛋疼的写法 </span>
</pre></div>
</td></tr></table><div class="section" id="os-waitpid-0-0">
<h4><a class="toc-backref" href="#id31">os.waitpid(0, 0)</a></h4>
<p> 表示等待并获取当前进程组中的任何子进程的返回值。</p>
<p> 关于该函数的具体说明参见 <a class="reference external" href="https://docs.python.org/2/library/os.html#os.waitpid">os.waitpid</a></p>
</div>
<div class="section" id="os-exit">
<h4><a class="toc-backref" href="#id32">os._exit</a></h4>
<p> 它会将进程直接终止，之后的所有代码都不会继续执行。</p>
<p> 该函数和 <cite>sys.exit</cite> 有点不一样， <cite>sys.exit</cite> 会抛出 <cite>SystemExit</cite> 异常，如果捕获该异常，Python 还是会继续执行捕获该异常的代码的。</p>
<p> 具体可以参见： <a class="reference external" href="http://stackoverflow.com/questions/6501121/the-difference-between-exit-and-sys-exit-in-python">The difference between exit() and sys.exit() in python?</a></p>
</div>
</div>
<div class="section" id="threadingmixin">
<h3><a class="toc-backref" href="#id33">ThreadingMixIn</a></h3>
<p> 使用线程来处理请求，一个请求对应一个线程。</p>
<p> 线程相对进程来说比较轻量，所以代码里没有对应线程数进行控制，不过这里还是有问题的，如果短时间内有大量的并发请求，生成大量的线程，Python 会 Hold 不住，Python 的性能会急剧下降（大量的 CPU 时间用于线程切换了），到那时候基本就是拒绝服务了。</p>
<p> 所以 <cite>ThreadingMinIn</cite> 多用于性能要求不高的环境，或者使用 gevent 来 monkey patch 一下，性能会有较大的提升。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ThreadingMixIn</span><span class="p">:</span>
    <span class="c"># 可以设置该属性来决定当主线程退出时，处理请求的子线程是否也随之退出 </span>
    <span class="n">daemon_threads</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">process_request_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finish_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle_error</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
        <span class="c"># 此处不用 finally 来调用：self.shutdown_request(request)</span>
        <span class="c"># 是因为 Python2.5 之前版本不支持 except &amp;&amp; finally 同时使用。</span>

    <span class="k">def</span> <span class="nf">process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="c"># 重载了 process_request 方法，生成一个线程来处理请求 </span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_request_thread</span><span class="p">,</span>
                             <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">daemon_threads</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id34"> 其它 </a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ForkingUDPServer</span><span class="p">(</span><span class="n">ForkingMixIn</span><span class="p">,</span> <span class="n">UDPServer</span><span class="p">):</span> <span class="k">pass</span>
<span class="k">class</span> <span class="nc">ForkingTCPServer</span><span class="p">(</span><span class="n">ForkingMixIn</span><span class="p">,</span> <span class="n">TCPServer</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ThreadingUDPServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UDPServer</span><span class="p">):</span> <span class="k">pass</span>
<span class="k">class</span> <span class="nc">ThreadingTCPServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">TCPServer</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="s">&#39;AF_UNIX&#39;</span><span class="p">):</span> <span class="c"># Windows 平台不支持 unix domain socket</span>

    <span class="k">class</span> <span class="nc">UnixStreamServer</span><span class="p">(</span><span class="n">TCPServer</span><span class="p">):</span>
        <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNIX</span>

    <span class="k">class</span> <span class="nc">UnixDatagramServer</span><span class="p">(</span><span class="n">UDPServer</span><span class="p">):</span>
        <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNIX</span>

    <span class="k">class</span> <span class="nc">ThreadingUnixStreamServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UnixStreamServer</span><span class="p">):</span> <span class="k">pass</span>

    <span class="k">class</span> <span class="nc">ThreadingUnixDatagramServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UnixDatagramServer</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</td></tr></table><p> 该模块提供了现成的支持多线程 / 多进程的服务类，但是当你使用基于 TCP/UDP 的上层协议的服务类时，</p>
<p> 为了要支持多线程 / 多进程，你还是要自己手写的。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">SimpleXMLRPCServer</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="k">class</span> <span class="nc">ThreadXMLRPCServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">SimpleXMLRPCServer</span><span class="p">):</span>
   <span class="k">pass</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id35">RequestHandler</a></h2>
<p><cite>BaseRequestHandler</cite> 定义了基本的请求处理框架。</p>
<p><cite>StreamRequestHandler</cite> 和 <cite>DatagramRequestHandler</cite> 都将 socket 的数据读写操作抽象成了文件的读写。</p>
<div class="section" id="baserequesthandler">
<h3><a class="toc-backref" href="#id36">BaseRequestHandler</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BaseRequestHandler</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">,</span> <span class="n">server</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span> <span class="o">=</span> <span class="n">request</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span> <span class="o">=</span> <span class="n">client_address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">server</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="streamrequesthandler">
<h3><a class="toc-backref" href="#id37">StreamRequestHandler</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StreamRequestHandler</span><span class="p">(</span><span class="n">BaseRequestHandler</span><span class="p">):</span>

    <span class="n">rbufsize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c"># 默认有缓存 </span>
    <span class="n">wbufsize</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># 默认无缓存 </span>

    <span class="n">timeout</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c"># Nagle 算法开关，最好仅在 wbufsize != 0 时打开，用来避免传递大量小的数据包。</span>
    <span class="n">disable_nagle_algorithm</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">disable_nagle_algorithm</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_TCP</span><span class="p">,</span>
                                       <span class="n">socket</span><span class="o">.</span><span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;rb&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbufsize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;wb&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wbufsize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="c"># socket 结束时可能会有错误发生，比如 `ECONNABORTED`</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</td></tr></table><div class="section" id="rbufsize-wbufsize">
<h4><a class="toc-backref" href="#id38">rbufsize&amp;&amp;wbufsize</a></h4>
<p>rbufsize: 如果读取大量数据时，没有缓存会导致处理速度很慢。</p>
<p>wbufsize: 在写入大量数据时，底层的 stdio 会进行优化。</p>
</div>
<div class="section" id="nagle">
<h4><a class="toc-backref" href="#id39">Nagle 算法 </a></h4>
<p>TCP/IP 协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送 ACK 表示确认。为了尽可能的利用网络带宽，TCP 总是希望尽可能的发送足够大的数据。（一个连接会设置 MSS 参数，因此，TCP/IP 希望每次都能够以 MSS 尺寸的数据块来发送数据）。</p>
<p>Nagle 算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。</p>
<p> 想具体了解该算法请参见 <a class="reference external" href="http://baike.baidu.com/view/2468335.htm?fr=aladdin">Nagle 算法 </a></p>
</div>
<div class="section" id="econnaborted">
<h4><a class="toc-backref" href="#id40">ECONNABORTED</a></h4>
<p> 该错误被描述为 ”software caused connection abort”，即 “ 软件引起的连接中止 ”。</p>
<p> 原因在于当服务和客户进程在完成用于 TCP 连接的 “ 三次握手 ” 后，客户 TCP 却发送了一个 RST （复位）分节，在服务进程看来，就在该连接已由 TCP 排队，等着服务进程调用 accept 的时候 RST 却到达了。POSIX 规定此时的 errno 值必须 ECONNABORTED。</p>
<p> 源自 Berkeley 的实现完全在内核中处理中止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用 accept。</p>
</div>
</div>
<div class="section" id="datagramrequesthandler">
<h3><a class="toc-backref" href="#id41">DatagramRequestHandler</a></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DatagramRequestHandler</span><span class="p">(</span><span class="n">BaseRequestHandler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">cStringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">StringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>
</pre></div>
</td></tr></table><div class="section" id="self-packet-self-socket-self-request">
<h4><a class="toc-backref" href="#id42">self.packet, self.socket = self.request</a></h4>
<p> 这里的 self.request 对象是一个元组，第一个是从 self.socket 中获取的数据，第二个为 self.socket。</p>
<p> 至于为什么不在 <cite>DatagramRequestHandler</cite> 中直接获取数据，作者在注释里作了如下说明 :</p>
<blockquote>
# XXX Regrettably, I cannot get this working on Linux;
# s.recvfrom() doesn't return a meaningful client address.</blockquote>
</div>
</div>
</div>

            
            <section>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="http://chenjiee815.github.io/socketserverbiao-zhun-ku-yuan-ma-xue-xi.html#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
                    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'chenjiee815blog';
        var disqus_identifier = 'http://chenjiee815.github.io/socketserverbiao-zhun-ku-yuan-ma-xue-xi.html';
    var disqus_url = 'http://chenjiee815.github.io/socketserverbiao-zhun-ku-yuan-ma-xue-xi.html';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

                </div>
            </div>
        </div>
    </div>
</div>
</section>

            <hr/>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2014-10-28T11:48:00.039635">Oct 28, 2014</time>
            <h4>Category</h4>
            <a class="category-link" href="http://chenjiee815.github.io/categories.html#python-ref">Python</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="http://chenjiee815.github.io/tags.html#python-ref">python
                    <span>18</span>
</a></li>
                <li><a href="http://chenjiee815.github.io/tags.html#stdlibs-ref">stdlibs
                    <span>9</span>
</a></li>
            </ul>
<h4>Contact</h4>
    <a href="http://www.htdp.org/" title="My HTDP Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-htdp sidebar-social-links"></i></a>
    <a href="http://mitpress.mit.edu/sicp/" title="My SICP Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-sicp sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>

                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

            <script type="text/javascript">
var disqus_shortname = 'chenjiee815blog';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
<script  language="javascript" type="text/javascript">
function uncollapse() {
    if (window.location.hash.match(/^#comment-\d+$/)) {
        $('#disqus_thread').collapse('show');
    }
}
</script>
<script type="text/javascript" language="JavaScript">
uncollapse();
window.onhashchange=function(){
    if (window.location.hash.match(/^#comment-\d+$/))
        window.location.reload(true);
}
</script>
<script>
$('#disqus_thread').on('shown', function () {
    var link = document.getElementsByClassName('accordion-toggle');
    var old_innerHTML = link[0].innerHTML;
    $(link[0]).fadeOut(500, function() {
        $(this).text('Click here to hide comments').fadeIn(500);
    });
    $('#disqus_thread').on('hidden', function () {
        $(link[0]).fadeOut(500, function() {
            $(this).text(old_innerHTML).fadeIn(500);
        });
    })
})
</script>


    </body>
    <!-- Theme: Elegant built for Pelican
    License : http://oncrashreboot.com/pelican-elegant -->
</html>